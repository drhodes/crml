#! /usr/bin/env python

'''
A tool for native client applications. 

incbin.py will create obj files from binary files.
Possible uses include linking media files directly into the nexe.

it fails if one file has a bad name.
a good name is composed of: letters nums _ . /
all other characters fail.
all dots are converted to underscores.
all slashes are converted to two underscores.

it produces a _header_ file with externs

in any code that uses media.
#include "./path/to/(_header_)"

each name is global and starts with _path_to_filename_ext

incbin.py requires that the root directory has a file .incbin-root
'''
import os
import sys

safetyfile = ".incbin-root"

if ".incbin-root" not in os.listdir("./"):
    print "-> ", safetyfile, " <- not found in this directory."
    print "If you are sure this is the directory you would"
    print "like to run incbin.py from, then:"
    print "$ touch .incbin-root\n"

s_template = '''
.section ".rodata"
.globl GLOBNAME
.type GLOBNAME,@object
GLOBNAME:
.incbin "FILENAME"
.byte 0
.size GLOBNAME,.-GLOBNAME
'''

def badname(n):
    bad = []
    for char in n:
        if char not in "qwertyuiopasdfghjklzxcvbnm1234567890_./":
            bad.append(char)
    return bad

def check_name(name, dir_=None):
    err = badname(name)
    if err:
        print "!! incbin.py Error"
        if dir_:
            print "Bad characters found in filename."
            print "dir : ", dir_
            print "file: ", name       
        else:
            print "Bad characters found in directory name."
            print "dir : ", name
        print "char: ", err
        sys.exit()
       
def get_file_infos():
    tree = os.walk("./")
    tree.next() # ignore files in ./

    result = []
    for el in tree:        
        d = el[0]
        check_name(d)

        fs = el[2]
        for f in fs:                    
            check_name(f, d)
            result.append({ 'globname': make_globname(d[2:]) + "__" + make_globname(f),
                            'filename': d + "/" + f
                            })                            
    return result

def make_globname(n):
    n = n.replace('.', '_')
    n = n.replace('/', "__")
    return n

def make_s_file_string(info):
    s = s_template.replace("GLOBNAME", info['globname'])
    s = s.replace("FILENAME", info["filename"])
    return s

def create_file(info):
    fn = info["globname"] + ".s"
    print "creating file:", fn
    outfile = open(fn, 'w')
    outfile.write(make_s_file_string(info))
    outfile.close()

def execute(cmd):
    print cmd
    result = os.popen(cmd).read()
    if result:
        print result
       
def assemble_obj(info):
    cmd = "nacl-as %s.s -o %s.o" % (info["globname"], info["globname"])
    execute(cmd)

def remove_obj(info):
    cmd = "rm %s.s %s.o" % (info["globname"], info["globname"])
    execute(cmd)

def create_archive(infos):
    cmd = "nacl-ar -rcs media-blob.a"
    for i in infos:
        cmd += " %s.o" % i["globname"]
    execute(cmd)

def create_header():
    lines = os.popen("size ./media-blob.a").readlines()[1:]
    outfile = open("./media-blob.h", 'w')
    s = "// machine generated by incbin, probably not a good idea to hand edit.\n\n"
    s += "#ifndef MEDIA_BLOB_H_\n"
    s += "#define MEDIA_BLOB_H_\n"
    
    for l in lines:
        columns = l.strip().split("\t")
        size = columns[0]
        name = columns[5].split(".o ")[0]
        s += "extern char " + name + "[%s];\n" % size
        #//s += "int " + name + "_SIZE =" + size + ";\n"
    s += "\n#endif  // MEDIA_BLOB_H_\n"
    outfile.write(s)
    

if __name__ == "__main__":
    infos = get_file_infos()
    for i in infos:
        create_file(i)
        assemble_obj(i)    

    create_archive(infos)
    
    for i in infos:
        remove_obj(i)

    create_header()
    print "success."
