<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>crml: /home/derek/dev/crml/crml/tools/cpplint.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>/home/derek/dev/crml/crml/tools/cpplint.py</h1><a href="cpplint_8py.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a><a class="code" href="namespacecpplint.html">00001</a> <span class="comment">#!/usr/bin/env python</span>
<a name="l00002"></a>00002 <span class="comment">#</span>
<a name="l00003"></a>00003 <span class="comment"># Copyright (c) 2009 Google Inc. All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">#</span>
<a name="l00005"></a>00005 <span class="comment"># Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment"># modification, are permitted provided that the following conditions are</span>
<a name="l00007"></a>00007 <span class="comment"># met:</span>
<a name="l00008"></a>00008 <span class="comment">#</span>
<a name="l00009"></a>00009 <span class="comment">#    * Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"># notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment">#    * Redistributions in binary form must reproduce the above</span>
<a name="l00012"></a>00012 <span class="comment"># copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00013"></a>00013 <span class="comment"># in the documentation and/or other materials provided with the</span>
<a name="l00014"></a>00014 <span class="comment"># distribution.</span>
<a name="l00015"></a>00015 <span class="comment">#    * Neither the name of Google Inc. nor the names of its</span>
<a name="l00016"></a>00016 <span class="comment"># contributors may be used to endorse or promote products derived from</span>
<a name="l00017"></a>00017 <span class="comment"># this software without specific prior written permission.</span>
<a name="l00018"></a>00018 <span class="comment">#</span>
<a name="l00019"></a>00019 <span class="comment"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00020"></a>00020 <span class="comment"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00021"></a>00021 <span class="comment"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00022"></a>00022 <span class="comment"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00023"></a>00023 <span class="comment"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00024"></a>00024 <span class="comment"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00025"></a>00025 <span class="comment"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00026"></a>00026 <span class="comment"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00027"></a>00027 <span class="comment"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00028"></a>00028 <span class="comment"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00029"></a>00029 <span class="comment"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment"># Here are some issues that I&#39;ve had people identify in my code during reviews,</span>
<a name="l00032"></a>00032 <span class="comment"># that I think are possible to flag automatically in a lint tool.  If these were</span>
<a name="l00033"></a>00033 <span class="comment"># caught by lint, it would save time both for myself and that of my reviewers.</span>
<a name="l00034"></a>00034 <span class="comment"># Most likely, some of these are beyond the scope of the current lint framework,</span>
<a name="l00035"></a>00035 <span class="comment"># but I think it is valuable to retain these wish-list items even if they cannot</span>
<a name="l00036"></a>00036 <span class="comment"># be immediately implemented.</span>
<a name="l00037"></a>00037 <span class="comment">#</span>
<a name="l00038"></a>00038 <span class="comment">#  Suggestions</span>
<a name="l00039"></a>00039 <span class="comment">#  -----------</span>
<a name="l00040"></a>00040 <span class="comment">#  - Check for no &#39;explicit&#39; for multi-arg ctor</span>
<a name="l00041"></a>00041 <span class="comment">#  - Check for boolean assign RHS in parens</span>
<a name="l00042"></a>00042 <span class="comment">#  - Check for ctor initializer-list colon position and spacing</span>
<a name="l00043"></a>00043 <span class="comment">#  - Check that if there&#39;s a ctor, there should be a dtor</span>
<a name="l00044"></a>00044 <span class="comment">#  - Check accessors that return non-pointer member variables are</span>
<a name="l00045"></a>00045 <span class="comment">#    declared const</span>
<a name="l00046"></a>00046 <span class="comment">#  - Check accessors that return non-const pointer member vars are</span>
<a name="l00047"></a>00047 <span class="comment">#    *not* declared const</span>
<a name="l00048"></a>00048 <span class="comment">#  - Check for using public includes for testing</span>
<a name="l00049"></a>00049 <span class="comment">#  - Check for spaces between brackets in one-line inline method</span>
<a name="l00050"></a>00050 <span class="comment">#  - Check for no assert()</span>
<a name="l00051"></a>00051 <span class="comment">#  - Check for spaces surrounding operators</span>
<a name="l00052"></a>00052 <span class="comment">#  - Check for 0 in pointer context (should be NULL)</span>
<a name="l00053"></a>00053 <span class="comment">#  - Check for 0 in char context (should be &#39;\0&#39;)</span>
<a name="l00054"></a>00054 <span class="comment">#  - Check for camel-case method name conventions for methods</span>
<a name="l00055"></a>00055 <span class="comment">#    that are not simple inline getters and setters</span>
<a name="l00056"></a>00056 <span class="comment">#  - Check that base classes have virtual destructors</span>
<a name="l00057"></a>00057 <span class="comment">#    put &quot;  // namespace&quot; after } that closes a namespace, with</span>
<a name="l00058"></a>00058 <span class="comment">#    namespace&#39;s name after &#39;namespace&#39; if it is named.</span>
<a name="l00059"></a>00059 <span class="comment">#  - Do not indent namespace contents</span>
<a name="l00060"></a>00060 <span class="comment">#  - Avoid inlining non-trivial constructors in header files</span>
<a name="l00061"></a>00061 <span class="comment">#    include base/basictypes.h if DISALLOW_EVIL_CONSTRUCTORS is used</span>
<a name="l00062"></a>00062 <span class="comment">#  - Check for old-school (void) cast for call-sites of functions</span>
<a name="l00063"></a>00063 <span class="comment">#    ignored return value</span>
<a name="l00064"></a>00064 <span class="comment">#  - Check gUnit usage of anonymous namespace</span>
<a name="l00065"></a>00065 <span class="comment">#  - Check for class declaration order (typedefs, consts, enums,</span>
<a name="l00066"></a>00066 <span class="comment">#    ctor(s?), dtor, friend declarations, methods, member vars)</span>
<a name="l00067"></a>00067 <span class="comment">#</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="stringliteral">&quot;&quot;&quot;Does google-lint on c++ files.</span>
<a name="l00070"></a>00070 <span class="stringliteral"></span>
<a name="l00071"></a>00071 <span class="stringliteral">The goal of this script is to identify places in the code that *may*</span>
<a name="l00072"></a>00072 <span class="stringliteral">be in non-compliance with google style.  It does not attempt to fix</span>
<a name="l00073"></a>00073 <span class="stringliteral">up these problems -- the point is to educate.  It does also not</span>
<a name="l00074"></a>00074 <span class="stringliteral">attempt to find all problems, or to ensure that everything it does</span>
<a name="l00075"></a>00075 <span class="stringliteral">find is legitimately a problem.</span>
<a name="l00076"></a>00076 <span class="stringliteral"></span>
<a name="l00077"></a>00077 <span class="stringliteral">In particular, we can get very confused by /* and // inside strings!</span>
<a name="l00078"></a>00078 <span class="stringliteral">We do a small hack, which is to ignore //&#39;s with &quot;&#39;s after them on the</span>
<a name="l00079"></a>00079 <span class="stringliteral">same line, but it is far from perfect (in either direction).</span>
<a name="l00080"></a>00080 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keyword">import</span> codecs
<a name="l00083"></a>00083 <span class="keyword">import</span> getopt
<a name="l00084"></a>00084 <span class="keyword">import</span> math  <span class="comment"># for log</span>
<a name="l00085"></a>00085 <span class="keyword">import</span> os
<a name="l00086"></a>00086 <span class="keyword">import</span> re
<a name="l00087"></a>00087 <span class="keyword">import</span> sre_compile
<a name="l00088"></a>00088 <span class="keyword">import</span> string
<a name="l00089"></a>00089 <span class="keyword">import</span> sys
<a name="l00090"></a>00090 <span class="keyword">import</span> unicodedata
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="namespacecpplint.html#afefe1ab8eeab7350e1a7d96d41c86fb8">00093</a> _USAGE = <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00094"></a>00094 <span class="stringliteral">Syntax: cpplint.py [--verbose=#] [--output=vs7] [--filter=-x,+y,...]</span>
<a name="l00095"></a>00095 <span class="stringliteral">                   [--counting=total|toplevel|detailed]</span>
<a name="l00096"></a>00096 <span class="stringliteral">        &lt;file&gt; [file] ...</span>
<a name="l00097"></a>00097 <span class="stringliteral"></span>
<a name="l00098"></a>00098 <span class="stringliteral">  The style guidelines this tries to follow are those in</span>
<a name="l00099"></a>00099 <span class="stringliteral">    http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</span>
<a name="l00100"></a>00100 <span class="stringliteral"></span>
<a name="l00101"></a>00101 <span class="stringliteral">  Every problem is given a confidence score from 1-5, with 5 meaning we are</span>
<a name="l00102"></a>00102 <span class="stringliteral">  certain of the problem, and 1 meaning it could be a legitimate construct.</span>
<a name="l00103"></a>00103 <span class="stringliteral">  This will miss some errors, and is not a substitute for a code review.</span>
<a name="l00104"></a>00104 <span class="stringliteral"></span>
<a name="l00105"></a>00105 <span class="stringliteral">  To suppress false-positive errors of a certain category, add a</span>
<a name="l00106"></a>00106 <span class="stringliteral">  &#39;NOLINT(category)&#39; comment to the line.  NOLINT or NOLINT(*)</span>
<a name="l00107"></a>00107 <span class="stringliteral">  suppresses errors of all categories on that line.</span>
<a name="l00108"></a>00108 <span class="stringliteral"></span>
<a name="l00109"></a>00109 <span class="stringliteral">  The files passed in will be linted; at least one file must be provided.</span>
<a name="l00110"></a>00110 <span class="stringliteral">  Linted extensions are .cc, .cpp, and .h.  Other file types will be ignored.</span>
<a name="l00111"></a>00111 <span class="stringliteral"></span>
<a name="l00112"></a>00112 <span class="stringliteral">  Flags:</span>
<a name="l00113"></a>00113 <span class="stringliteral"></span>
<a name="l00114"></a>00114 <span class="stringliteral">    output=vs7</span>
<a name="l00115"></a>00115 <span class="stringliteral">      By default, the output is formatted to ease emacs parsing.  Visual Studio</span>
<a name="l00116"></a>00116 <span class="stringliteral">      compatible output (vs7) may also be used.  Other formats are unsupported.</span>
<a name="l00117"></a>00117 <span class="stringliteral"></span>
<a name="l00118"></a>00118 <span class="stringliteral">    verbose=#</span>
<a name="l00119"></a>00119 <span class="stringliteral">      Specify a number 0-5 to restrict errors to certain verbosity levels.</span>
<a name="l00120"></a>00120 <span class="stringliteral"></span>
<a name="l00121"></a>00121 <span class="stringliteral">    filter=-x,+y,...</span>
<a name="l00122"></a>00122 <span class="stringliteral">      Specify a comma-separated list of category-filters to apply: only</span>
<a name="l00123"></a>00123 <span class="stringliteral">      error messages whose category names pass the filters will be printed.</span>
<a name="l00124"></a>00124 <span class="stringliteral">      (Category names are printed with the message and look like</span>
<a name="l00125"></a>00125 <span class="stringliteral">      &quot;[whitespace/indent]&quot;.)  Filters are evaluated left to right.</span>
<a name="l00126"></a>00126 <span class="stringliteral">      &quot;-FOO&quot; and &quot;FOO&quot; means &quot;do not print categories that start with FOO&quot;.</span>
<a name="l00127"></a>00127 <span class="stringliteral">      &quot;+FOO&quot; means &quot;do print categories that start with FOO&quot;.</span>
<a name="l00128"></a>00128 <span class="stringliteral"></span>
<a name="l00129"></a>00129 <span class="stringliteral">      Examples: --filter=-whitespace,+whitespace/braces</span>
<a name="l00130"></a>00130 <span class="stringliteral">                --filter=whitespace,runtime/printf,+runtime/printf_format</span>
<a name="l00131"></a>00131 <span class="stringliteral">                --filter=-,+build/include_what_you_use</span>
<a name="l00132"></a>00132 <span class="stringliteral"></span>
<a name="l00133"></a>00133 <span class="stringliteral">      To see a list of all the categories used in cpplint, pass no arg:</span>
<a name="l00134"></a>00134 <span class="stringliteral">         --filter=</span>
<a name="l00135"></a>00135 <span class="stringliteral"></span>
<a name="l00136"></a>00136 <span class="stringliteral">    counting=total|toplevel|detailed</span>
<a name="l00137"></a>00137 <span class="stringliteral">      The total number of errors found is always printed. If</span>
<a name="l00138"></a>00138 <span class="stringliteral">      &#39;toplevel&#39; is provided, then the count of errors in each of</span>
<a name="l00139"></a>00139 <span class="stringliteral">      the top-level categories like &#39;build&#39; and &#39;whitespace&#39; will</span>
<a name="l00140"></a>00140 <span class="stringliteral">      also be printed. If &#39;detailed&#39; is provided, then a count</span>
<a name="l00141"></a>00141 <span class="stringliteral">      is provided for each category like &#39;build/class&#39;.</span>
<a name="l00142"></a>00142 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment"># We categorize each error message we print.  Here are the categories.</span>
<a name="l00145"></a>00145 <span class="comment"># We want an explicit list so we can list them all in cpplint --filter=.</span>
<a name="l00146"></a>00146 <span class="comment"># If you add a new error message with a new category, add it to the list</span>
<a name="l00147"></a>00147 <span class="comment"># here!  cpplint_unittest.py should tell you if you forget to do this.</span>
<a name="l00148"></a>00148 <span class="comment"># \ used for clearer layout -- pylint: disable-msg=C6013</span>
<a name="l00149"></a><a class="code" href="namespacecpplint.html#a7a498bc09903cee9029cccc023641ede">00149</a> _ERROR_CATEGORIES = [
<a name="l00150"></a>00150   <span class="stringliteral">&#39;build/class&#39;</span>,
<a name="l00151"></a>00151   <span class="stringliteral">&#39;build/deprecated&#39;</span>,
<a name="l00152"></a>00152   <span class="stringliteral">&#39;build/endif_comment&#39;</span>,
<a name="l00153"></a>00153   <span class="stringliteral">&#39;build/forward_decl&#39;</span>,
<a name="l00154"></a>00154   <span class="stringliteral">&#39;build/header_guard&#39;</span>,
<a name="l00155"></a>00155   <span class="stringliteral">&#39;build/include&#39;</span>,
<a name="l00156"></a>00156   <span class="stringliteral">&#39;build/include_alpha&#39;</span>,
<a name="l00157"></a>00157   <span class="stringliteral">&#39;build/include_order&#39;</span>,
<a name="l00158"></a>00158   <span class="stringliteral">&#39;build/include_what_you_use&#39;</span>,
<a name="l00159"></a>00159   <span class="stringliteral">&#39;build/namespaces&#39;</span>,
<a name="l00160"></a>00160   <span class="stringliteral">&#39;build/printf_format&#39;</span>,
<a name="l00161"></a>00161   <span class="stringliteral">&#39;build/storage_class&#39;</span>,
<a name="l00162"></a>00162   <span class="stringliteral">&#39;legal/copyright&#39;</span>,
<a name="l00163"></a>00163   <span class="stringliteral">&#39;readability/braces&#39;</span>,
<a name="l00164"></a>00164   <span class="stringliteral">&#39;readability/casting&#39;</span>,
<a name="l00165"></a>00165   <span class="stringliteral">&#39;readability/check&#39;</span>,
<a name="l00166"></a>00166   <span class="stringliteral">&#39;readability/constructors&#39;</span>,
<a name="l00167"></a>00167   <span class="stringliteral">&#39;readability/fn_size&#39;</span>,
<a name="l00168"></a>00168   <span class="stringliteral">&#39;readability/function&#39;</span>,
<a name="l00169"></a>00169   <span class="stringliteral">&#39;readability/multiline_comment&#39;</span>,
<a name="l00170"></a>00170   <span class="stringliteral">&#39;readability/multiline_string&#39;</span>,
<a name="l00171"></a>00171   <span class="stringliteral">&#39;readability/nolint&#39;</span>,
<a name="l00172"></a>00172   <span class="stringliteral">&#39;readability/streams&#39;</span>,
<a name="l00173"></a>00173   <span class="stringliteral">&#39;readability/todo&#39;</span>,
<a name="l00174"></a>00174   <span class="stringliteral">&#39;readability/utf8&#39;</span>,
<a name="l00175"></a>00175   <span class="stringliteral">&#39;runtime/arrays&#39;</span>,
<a name="l00176"></a>00176   <span class="stringliteral">&#39;runtime/casting&#39;</span>,
<a name="l00177"></a>00177   <span class="stringliteral">&#39;runtime/explicit&#39;</span>,
<a name="l00178"></a>00178   <span class="stringliteral">&#39;runtime/int&#39;</span>,
<a name="l00179"></a>00179   <span class="stringliteral">&#39;runtime/init&#39;</span>,
<a name="l00180"></a>00180   <span class="stringliteral">&#39;runtime/invalid_increment&#39;</span>,
<a name="l00181"></a>00181   <span class="stringliteral">&#39;runtime/member_string_references&#39;</span>,
<a name="l00182"></a>00182   <span class="stringliteral">&#39;runtime/memset&#39;</span>,
<a name="l00183"></a>00183   <span class="stringliteral">&#39;runtime/operator&#39;</span>,
<a name="l00184"></a>00184   <span class="stringliteral">&#39;runtime/printf&#39;</span>,
<a name="l00185"></a>00185   <span class="stringliteral">&#39;runtime/printf_format&#39;</span>,
<a name="l00186"></a>00186   <span class="stringliteral">&#39;runtime/references&#39;</span>,
<a name="l00187"></a>00187   <span class="stringliteral">&#39;runtime/rtti&#39;</span>,
<a name="l00188"></a>00188   <span class="stringliteral">&#39;runtime/sizeof&#39;</span>,
<a name="l00189"></a>00189   <span class="stringliteral">&#39;runtime/string&#39;</span>,
<a name="l00190"></a>00190   <span class="stringliteral">&#39;runtime/threadsafe_fn&#39;</span>,
<a name="l00191"></a>00191   <span class="stringliteral">&#39;runtime/virtual&#39;</span>,
<a name="l00192"></a>00192   <span class="stringliteral">&#39;whitespace/blank_line&#39;</span>,
<a name="l00193"></a>00193   <span class="stringliteral">&#39;whitespace/braces&#39;</span>,
<a name="l00194"></a>00194   <span class="stringliteral">&#39;whitespace/comma&#39;</span>,
<a name="l00195"></a>00195   <span class="stringliteral">&#39;whitespace/comments&#39;</span>,
<a name="l00196"></a>00196   <span class="stringliteral">&#39;whitespace/end_of_line&#39;</span>,
<a name="l00197"></a>00197   <span class="stringliteral">&#39;whitespace/ending_newline&#39;</span>,
<a name="l00198"></a>00198   <span class="stringliteral">&#39;whitespace/indent&#39;</span>,
<a name="l00199"></a>00199   <span class="stringliteral">&#39;whitespace/labels&#39;</span>,
<a name="l00200"></a>00200   <span class="stringliteral">&#39;whitespace/line_length&#39;</span>,
<a name="l00201"></a>00201   <span class="stringliteral">&#39;whitespace/newline&#39;</span>,
<a name="l00202"></a>00202   <span class="stringliteral">&#39;whitespace/operators&#39;</span>,
<a name="l00203"></a>00203   <span class="stringliteral">&#39;whitespace/parens&#39;</span>,
<a name="l00204"></a>00204   <span class="stringliteral">&#39;whitespace/semicolon&#39;</span>,
<a name="l00205"></a>00205   <span class="stringliteral">&#39;whitespace/tab&#39;</span>,
<a name="l00206"></a>00206   <span class="stringliteral">&#39;whitespace/todo&#39;</span>
<a name="l00207"></a>00207   ]
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment"># The default state of the category filter. This is overrided by the --filter=</span>
<a name="l00210"></a>00210 <span class="comment"># flag. By default all errors are on, so only add here categories that should be</span>
<a name="l00211"></a>00211 <span class="comment"># off by default (i.e., categories that must be enabled by the --filter= flags).</span>
<a name="l00212"></a>00212 <span class="comment"># All entries here should start with a &#39;-&#39; or &#39;+&#39;, as in the --filter= flag.</span>
<a name="l00213"></a><a class="code" href="namespacecpplint.html#a40307223380a2e065996f7113e2f8f4c">00213</a> _DEFAULT_FILTERS = [ <span class="stringliteral">&#39;-build/include_alpha&#39;</span> ]
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="comment"># We used to check for high-bit characters, but after much discussion we</span>
<a name="l00216"></a>00216 <span class="comment"># decided those were OK, as long as they were in UTF-8 and didn&#39;t represent</span>
<a name="l00217"></a>00217 <span class="comment"># hard-coded international strings, which belong in a seperate i18n file.</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment"># Headers that we consider STL headers.</span>
<a name="l00220"></a><a class="code" href="namespacecpplint.html#a76f8ec9e9e1ea46197f611bd5a995962">00220</a> _STL_HEADERS = frozenset([
<a name="l00221"></a>00221     <span class="stringliteral">&#39;algobase.h&#39;</span>, <span class="stringliteral">&#39;algorithm&#39;</span>, <span class="stringliteral">&#39;alloc.h&#39;</span>, <span class="stringliteral">&#39;bitset&#39;</span>, <span class="stringliteral">&#39;deque&#39;</span>, <span class="stringliteral">&#39;exception&#39;</span>,
<a name="l00222"></a>00222     <span class="stringliteral">&#39;function.h&#39;</span>, <span class="stringliteral">&#39;functional&#39;</span>, <span class="stringliteral">&#39;hash_map&#39;</span>, <span class="stringliteral">&#39;hash_map.h&#39;</span>, <span class="stringliteral">&#39;hash_set&#39;</span>,
<a name="l00223"></a>00223     <span class="stringliteral">&#39;hash_set.h&#39;</span>, <span class="stringliteral">&#39;iterator&#39;</span>, <span class="stringliteral">&#39;list&#39;</span>, <span class="stringliteral">&#39;list.h&#39;</span>, <span class="stringliteral">&#39;map&#39;</span>, <span class="stringliteral">&#39;memory&#39;</span>, <span class="stringliteral">&#39;new&#39;</span>,
<a name="l00224"></a>00224     <span class="stringliteral">&#39;pair.h&#39;</span>, <span class="stringliteral">&#39;pthread_alloc&#39;</span>, <span class="stringliteral">&#39;queue&#39;</span>, <span class="stringliteral">&#39;set&#39;</span>, <span class="stringliteral">&#39;set.h&#39;</span>, <span class="stringliteral">&#39;sstream&#39;</span>, <span class="stringliteral">&#39;stack&#39;</span>,
<a name="l00225"></a>00225     <span class="stringliteral">&#39;stl_alloc.h&#39;</span>, <span class="stringliteral">&#39;stl_relops.h&#39;</span>, <span class="stringliteral">&#39;type_traits.h&#39;</span>,
<a name="l00226"></a>00226     <span class="stringliteral">&#39;utility&#39;</span>, <span class="stringliteral">&#39;vector&#39;</span>, <span class="stringliteral">&#39;vector.h&#39;</span>,
<a name="l00227"></a>00227     ])
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="comment"># Non-STL C++ system headers.</span>
<a name="l00231"></a><a class="code" href="namespacecpplint.html#a8b16f3827d7722217dd3a2f50f24087d">00231</a> _CPP_HEADERS = frozenset([
<a name="l00232"></a>00232     <span class="stringliteral">&#39;algo.h&#39;</span>, <span class="stringliteral">&#39;builtinbuf.h&#39;</span>, <span class="stringliteral">&#39;bvector.h&#39;</span>, <span class="stringliteral">&#39;cassert&#39;</span>, <span class="stringliteral">&#39;cctype&#39;</span>,
<a name="l00233"></a>00233     <span class="stringliteral">&#39;cerrno&#39;</span>, <span class="stringliteral">&#39;cfloat&#39;</span>, <span class="stringliteral">&#39;ciso646&#39;</span>, <span class="stringliteral">&#39;climits&#39;</span>, <span class="stringliteral">&#39;clocale&#39;</span>, <span class="stringliteral">&#39;cmath&#39;</span>,
<a name="l00234"></a>00234     <span class="stringliteral">&#39;complex&#39;</span>, <span class="stringliteral">&#39;complex.h&#39;</span>, <span class="stringliteral">&#39;csetjmp&#39;</span>, <span class="stringliteral">&#39;csignal&#39;</span>, <span class="stringliteral">&#39;cstdarg&#39;</span>, <span class="stringliteral">&#39;cstddef&#39;</span>,
<a name="l00235"></a>00235     <span class="stringliteral">&#39;cstdio&#39;</span>, <span class="stringliteral">&#39;cstdlib&#39;</span>, <span class="stringliteral">&#39;cstring&#39;</span>, <span class="stringliteral">&#39;ctime&#39;</span>, <span class="stringliteral">&#39;cwchar&#39;</span>, <span class="stringliteral">&#39;cwctype&#39;</span>,
<a name="l00236"></a>00236     <span class="stringliteral">&#39;defalloc.h&#39;</span>, <span class="stringliteral">&#39;deque.h&#39;</span>, <span class="stringliteral">&#39;editbuf.h&#39;</span>, <span class="stringliteral">&#39;exception&#39;</span>, <span class="stringliteral">&#39;fstream&#39;</span>,
<a name="l00237"></a>00237     <span class="stringliteral">&#39;fstream.h&#39;</span>, <span class="stringliteral">&#39;hashtable.h&#39;</span>, <span class="stringliteral">&#39;heap.h&#39;</span>, <span class="stringliteral">&#39;indstream.h&#39;</span>, <span class="stringliteral">&#39;iomanip&#39;</span>,
<a name="l00238"></a>00238     <span class="stringliteral">&#39;iomanip.h&#39;</span>, <span class="stringliteral">&#39;ios&#39;</span>, <span class="stringliteral">&#39;iosfwd&#39;</span>, <span class="stringliteral">&#39;iostream&#39;</span>, <span class="stringliteral">&#39;iostream.h&#39;</span>, <span class="stringliteral">&#39;istream.h&#39;</span>,
<a name="l00239"></a>00239     <span class="stringliteral">&#39;iterator.h&#39;</span>, <span class="stringliteral">&#39;limits&#39;</span>, <span class="stringliteral">&#39;map.h&#39;</span>, <span class="stringliteral">&#39;multimap.h&#39;</span>, <span class="stringliteral">&#39;multiset.h&#39;</span>,
<a name="l00240"></a>00240     <span class="stringliteral">&#39;numeric&#39;</span>, <span class="stringliteral">&#39;ostream.h&#39;</span>, <span class="stringliteral">&#39;parsestream.h&#39;</span>, <span class="stringliteral">&#39;pfstream.h&#39;</span>, <span class="stringliteral">&#39;PlotFile.h&#39;</span>,
<a name="l00241"></a>00241     <span class="stringliteral">&#39;procbuf.h&#39;</span>, <span class="stringliteral">&#39;pthread_alloc.h&#39;</span>, <span class="stringliteral">&#39;rope&#39;</span>, <span class="stringliteral">&#39;rope.h&#39;</span>, <span class="stringliteral">&#39;ropeimpl.h&#39;</span>,
<a name="l00242"></a>00242     <span class="stringliteral">&#39;SFile.h&#39;</span>, <span class="stringliteral">&#39;slist&#39;</span>, <span class="stringliteral">&#39;slist.h&#39;</span>, <span class="stringliteral">&#39;stack.h&#39;</span>, <span class="stringliteral">&#39;stdexcept&#39;</span>,
<a name="l00243"></a>00243     <span class="stringliteral">&#39;stdiostream.h&#39;</span>, <span class="stringliteral">&#39;streambuf.h&#39;</span>, <span class="stringliteral">&#39;stream.h&#39;</span>, <span class="stringliteral">&#39;strfile.h&#39;</span>, <span class="stringliteral">&#39;string&#39;</span>,
<a name="l00244"></a>00244     <span class="stringliteral">&#39;strstream&#39;</span>, <span class="stringliteral">&#39;strstream.h&#39;</span>, <span class="stringliteral">&#39;tempbuf.h&#39;</span>, <span class="stringliteral">&#39;tree.h&#39;</span>, <span class="stringliteral">&#39;typeinfo&#39;</span>, <span class="stringliteral">&#39;valarray&#39;</span>,
<a name="l00245"></a>00245     ])
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment"># Assertion macros.  These are defined in base/logging.h and</span>
<a name="l00249"></a>00249 <span class="comment"># testing/base/gunit.h.  Note that the _M versions need to come first</span>
<a name="l00250"></a>00250 <span class="comment"># for substring matching to work.</span>
<a name="l00251"></a><a class="code" href="namespacecpplint.html#aab5915e25e8ef5ed9d9c223a5183d6bc">00251</a> _CHECK_MACROS = [
<a name="l00252"></a>00252     <span class="stringliteral">&#39;DCHECK&#39;</span>, <span class="stringliteral">&#39;CHECK&#39;</span>,
<a name="l00253"></a>00253     <span class="stringliteral">&#39;EXPECT_TRUE_M&#39;</span>, <span class="stringliteral">&#39;EXPECT_TRUE&#39;</span>,
<a name="l00254"></a>00254     <span class="stringliteral">&#39;ASSERT_TRUE_M&#39;</span>, <span class="stringliteral">&#39;ASSERT_TRUE&#39;</span>,
<a name="l00255"></a>00255     <span class="stringliteral">&#39;EXPECT_FALSE_M&#39;</span>, <span class="stringliteral">&#39;EXPECT_FALSE&#39;</span>,
<a name="l00256"></a>00256     <span class="stringliteral">&#39;ASSERT_FALSE_M&#39;</span>, <span class="stringliteral">&#39;ASSERT_FALSE&#39;</span>,
<a name="l00257"></a>00257     ]
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment"># Replacement macros for CHECK/DCHECK/EXPECT_TRUE/EXPECT_FALSE</span>
<a name="l00260"></a><a class="code" href="namespacecpplint.html#ad966b15edc61d0e0fa98cf4ce1a0135a">00260</a> _CHECK_REPLACEMENT = dict([(m, {}) <span class="keywordflow">for</span> m <span class="keywordflow">in</span> _CHECK_MACROS])
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="keywordflow">for</span> op, replacement <span class="keywordflow">in</span> [(<span class="stringliteral">&#39;==&#39;</span>, <span class="stringliteral">&#39;EQ&#39;</span>), (<span class="stringliteral">&#39;!=&#39;</span>, <span class="stringliteral">&#39;NE&#39;</span>),
<a name="l00263"></a>00263                         (<span class="stringliteral">&#39;&gt;=&#39;</span>, <span class="stringliteral">&#39;GE&#39;</span>), (<span class="stringliteral">&#39;&gt;&#39;</span>, <span class="stringliteral">&#39;GT&#39;</span>),
<a name="l00264"></a>00264                         (<span class="stringliteral">&#39;&lt;=&#39;</span>, <span class="stringliteral">&#39;LE&#39;</span>), (<span class="stringliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&#39;LT&#39;</span>)]:
<a name="l00265"></a>00265   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;DCHECK&#39;</span>][op] = <span class="stringliteral">&#39;DCHECK_%s&#39;</span> % replacement
<a name="l00266"></a>00266   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;CHECK&#39;</span>][op] = <span class="stringliteral">&#39;CHECK_%s&#39;</span> % replacement
<a name="l00267"></a>00267   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;EXPECT_TRUE&#39;</span>][op] = <span class="stringliteral">&#39;EXPECT_%s&#39;</span> % replacement
<a name="l00268"></a>00268   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;ASSERT_TRUE&#39;</span>][op] = <span class="stringliteral">&#39;ASSERT_%s&#39;</span> % replacement
<a name="l00269"></a>00269   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;EXPECT_TRUE_M&#39;</span>][op] = <span class="stringliteral">&#39;EXPECT_%s_M&#39;</span> % replacement
<a name="l00270"></a>00270   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;ASSERT_TRUE_M&#39;</span>][op] = <span class="stringliteral">&#39;ASSERT_%s_M&#39;</span> % replacement
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="keywordflow">for</span> op, inv_replacement <span class="keywordflow">in</span> [(<span class="stringliteral">&#39;==&#39;</span>, <span class="stringliteral">&#39;NE&#39;</span>), (<span class="stringliteral">&#39;!=&#39;</span>, <span class="stringliteral">&#39;EQ&#39;</span>),
<a name="l00273"></a>00273                             (<span class="stringliteral">&#39;&gt;=&#39;</span>, <span class="stringliteral">&#39;LT&#39;</span>), (<span class="stringliteral">&#39;&gt;&#39;</span>, <span class="stringliteral">&#39;LE&#39;</span>),
<a name="l00274"></a>00274                             (<span class="stringliteral">&#39;&lt;=&#39;</span>, <span class="stringliteral">&#39;GT&#39;</span>), (<span class="stringliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&#39;GE&#39;</span>)]:
<a name="l00275"></a>00275   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;EXPECT_FALSE&#39;</span>][op] = <span class="stringliteral">&#39;EXPECT_%s&#39;</span> % inv_replacement
<a name="l00276"></a>00276   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;ASSERT_FALSE&#39;</span>][op] = <span class="stringliteral">&#39;ASSERT_%s&#39;</span> % inv_replacement
<a name="l00277"></a>00277   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;EXPECT_FALSE_M&#39;</span>][op] = <span class="stringliteral">&#39;EXPECT_%s_M&#39;</span> % inv_replacement
<a name="l00278"></a>00278   _CHECK_REPLACEMENT[<span class="stringliteral">&#39;ASSERT_FALSE_M&#39;</span>][op] = <span class="stringliteral">&#39;ASSERT_%s_M&#39;</span> % inv_replacement
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment"># These constants define types of headers for use with</span>
<a name="l00282"></a>00282 <span class="comment"># _IncludeState.CheckNextIncludeOrder().</span>
<a name="l00283"></a><a class="code" href="namespacecpplint.html#a6703b407df0f07ff6162c225070ddc9e">00283</a> _C_SYS_HEADER = 1
<a name="l00284"></a><a class="code" href="namespacecpplint.html#a89c3b71932122fc90afd2f47c07574f4">00284</a> _CPP_SYS_HEADER = 2
<a name="l00285"></a><a class="code" href="namespacecpplint.html#a5d6aba92ab2575ff645a1aacad5b5216">00285</a> _LIKELY_MY_HEADER = 3
<a name="l00286"></a><a class="code" href="namespacecpplint.html#a40cf12907322271bf94416a9fe602d96">00286</a> _POSSIBLE_MY_HEADER = 4
<a name="l00287"></a><a class="code" href="namespacecpplint.html#ace812856f1cd6c6b4375ab5c92294323">00287</a> _OTHER_HEADER = 5
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="namespacecpplint.html#a3eea0656ee957fff7d4511579c92d250">00290</a> _regexp_compile_cache = {}
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment"># Finds occurrences of NOLINT or NOLINT(...).</span>
<a name="l00293"></a><a class="code" href="namespacecpplint.html#af6a02614cf018ab890ede0b3a936ba6e">00293</a> _RE_SUPPRESSION = re.compile(<span class="stringliteral">r&#39;\bNOLINT\b(\([^)]*\))?&#39;</span>)
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment"># {str, set(int)}: a map from error categories to sets of linenumbers</span>
<a name="l00296"></a>00296 <span class="comment"># on which those errors are expected and should be suppressed.</span>
<a name="l00297"></a>00297 _error_suppressions = {}
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="keyword">def </span>ParseNolintSuppressions(filename, raw_line, linenum, error):
<a name="l00300"></a>00300   <span class="stringliteral">&quot;&quot;&quot;Updates the global list of error-suppressions.</span>
<a name="l00301"></a>00301 <span class="stringliteral"></span>
<a name="l00302"></a>00302 <span class="stringliteral">  Parses any NOLINT comments on the current line, updating the global</span>
<a name="l00303"></a>00303 <span class="stringliteral">  error_suppressions store.  Reports an error if the NOLINT comment</span>
<a name="l00304"></a>00304 <span class="stringliteral">  was malformed.</span>
<a name="l00305"></a>00305 <span class="stringliteral"></span>
<a name="l00306"></a>00306 <span class="stringliteral">  Args:</span>
<a name="l00307"></a>00307 <span class="stringliteral">    filename: str, the name of the input file.</span>
<a name="l00308"></a>00308 <span class="stringliteral">    raw_line: str, the line of input text, with comments.</span>
<a name="l00309"></a>00309 <span class="stringliteral">    linenum: int, the number of the current line.</span>
<a name="l00310"></a>00310 <span class="stringliteral">    error: function, an error handler.</span>
<a name="l00311"></a>00311 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00312"></a>00312   <span class="comment"># FIXME(adonovan): &quot;NOLINT(&quot; is misparsed as NOLINT(*).</span>
<a name="l00313"></a>00313   m = _RE_SUPPRESSION.search(raw_line)
<a name="l00314"></a>00314   <span class="keywordflow">if</span> m:
<a name="l00315"></a>00315     category = m.group(1)
<a name="l00316"></a>00316     <span class="keywordflow">if</span> category <span class="keywordflow">in</span> (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;(*)&#39;</span>):  <span class="comment"># =&gt; &quot;suppress all&quot;</span>
<a name="l00317"></a>00317       _error_suppressions.setdefault(<span class="keywordtype">None</span>, set()).add(linenum)
<a name="l00318"></a>00318     <span class="keywordflow">else</span>:
<a name="l00319"></a>00319       <span class="keywordflow">if</span> category.startswith(<span class="stringliteral">&#39;(&#39;</span>) <span class="keywordflow">and</span> category.endswith(<span class="stringliteral">&#39;)&#39;</span>):
<a name="l00320"></a>00320         category = category[1:-1]
<a name="l00321"></a>00321         <span class="keywordflow">if</span> category <span class="keywordflow">in</span> _ERROR_CATEGORIES:
<a name="l00322"></a>00322           _error_suppressions.setdefault(category, set()).add(linenum)
<a name="l00323"></a>00323         <span class="keywordflow">else</span>:
<a name="l00324"></a>00324           error(filename, linenum, <span class="stringliteral">&#39;readability/nolint&#39;</span>, 5,
<a name="l00325"></a>00325             <span class="stringliteral">&#39;Unknown NOLINT error category: %s&#39;</span> % category)
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="keyword">def </span>ResetNolintSuppressions():
<a name="l00329"></a>00329   <span class="stringliteral">&quot;Resets the set of NOLINT suppressions to empty.&quot;</span>
<a name="l00330"></a>00330   _error_suppressions.clear()
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="keyword">def </span>IsErrorSuppressedByNolint(category, linenum):
<a name="l00334"></a>00334   <span class="stringliteral">&quot;&quot;&quot;Returns true if the specified error category is suppressed on this line.</span>
<a name="l00335"></a>00335 <span class="stringliteral"></span>
<a name="l00336"></a>00336 <span class="stringliteral">  Consults the global error_suppressions map populated by</span>
<a name="l00337"></a>00337 <span class="stringliteral">  ParseNolintSuppressions/ResetNolintSuppressions.</span>
<a name="l00338"></a>00338 <span class="stringliteral"></span>
<a name="l00339"></a>00339 <span class="stringliteral">  Args:</span>
<a name="l00340"></a>00340 <span class="stringliteral">    category: str, the category of the error.</span>
<a name="l00341"></a>00341 <span class="stringliteral">    linenum: int, the current line number.</span>
<a name="l00342"></a>00342 <span class="stringliteral">  Returns:</span>
<a name="l00343"></a>00343 <span class="stringliteral">    bool, True iff the error should be suppressed due to a NOLINT comment.</span>
<a name="l00344"></a>00344 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00345"></a>00345   <span class="keywordflow">return</span> (linenum <span class="keywordflow">in</span> _error_suppressions.get(category, set()) <span class="keywordflow">or</span>
<a name="l00346"></a>00346           linenum <span class="keywordflow">in</span> _error_suppressions.get(<span class="keywordtype">None</span>, set()))
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="keyword">def </span>Match(pattern, s):
<a name="l00349"></a>00349   <span class="stringliteral">&quot;&quot;&quot;Matches the string with the pattern, caching the compiled regexp.&quot;&quot;&quot;</span>
<a name="l00350"></a>00350   <span class="comment"># The regexp compilation caching is inlined in both Match and Search for</span>
<a name="l00351"></a>00351   <span class="comment"># performance reasons; factoring it out into a separate function turns out</span>
<a name="l00352"></a>00352   <span class="comment"># to be noticeably expensive.</span>
<a name="l00353"></a>00353   <span class="keywordflow">if</span> <span class="keywordflow">not</span> pattern <span class="keywordflow">in</span> _regexp_compile_cache:
<a name="l00354"></a>00354     _regexp_compile_cache[pattern] = sre_compile.compile(pattern)
<a name="l00355"></a>00355   <span class="keywordflow">return</span> _regexp_compile_cache[pattern].match(s)
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="keyword">def </span>Search(pattern, s):
<a name="l00359"></a>00359   <span class="stringliteral">&quot;&quot;&quot;Searches the string for the pattern, caching the compiled regexp.&quot;&quot;&quot;</span>
<a name="l00360"></a>00360   <span class="keywordflow">if</span> <span class="keywordflow">not</span> pattern <span class="keywordflow">in</span> _regexp_compile_cache:
<a name="l00361"></a>00361     _regexp_compile_cache[pattern] = sre_compile.compile(pattern)
<a name="l00362"></a>00362   <span class="keywordflow">return</span> _regexp_compile_cache[pattern].search(s)
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="keyword">class </span>_IncludeState(dict):
<a name="l00366"></a>00366   <span class="stringliteral">&quot;&quot;&quot;Tracks line numbers for includes, and the order in which includes appear.</span>
<a name="l00367"></a>00367 <span class="stringliteral"></span>
<a name="l00368"></a>00368 <span class="stringliteral">  As a dict, an _IncludeState object serves as a mapping between include</span>
<a name="l00369"></a>00369 <span class="stringliteral">  filename and line number on which that file was included.</span>
<a name="l00370"></a>00370 <span class="stringliteral"></span>
<a name="l00371"></a>00371 <span class="stringliteral">  Call CheckNextIncludeOrder() once for each header in the file, passing</span>
<a name="l00372"></a>00372 <span class="stringliteral">  in the type constants defined above. Calls in an illegal order will</span>
<a name="l00373"></a>00373 <span class="stringliteral">  raise an _IncludeError with an appropriate error message.</span>
<a name="l00374"></a>00374 <span class="stringliteral"></span>
<a name="l00375"></a>00375 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00376"></a>00376   <span class="comment"># self._section will move monotonically through this set. If it ever</span>
<a name="l00377"></a>00377   <span class="comment"># needs to move backwards, CheckNextIncludeOrder will raise an error.</span>
<a name="l00378"></a>00378   _INITIAL_SECTION = 0
<a name="l00379"></a>00379   _MY_H_SECTION = 1
<a name="l00380"></a>00380   _C_SECTION = 2
<a name="l00381"></a>00381   _CPP_SECTION = 3
<a name="l00382"></a>00382   _OTHER_H_SECTION = 4
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   _TYPE_NAMES = {
<a name="l00385"></a>00385       _C_SYS_HEADER: <span class="stringliteral">&#39;C system header&#39;</span>,
<a name="l00386"></a>00386       _CPP_SYS_HEADER: <span class="stringliteral">&#39;C++ system header&#39;</span>,
<a name="l00387"></a>00387       _LIKELY_MY_HEADER: <span class="stringliteral">&#39;header this file implements&#39;</span>,
<a name="l00388"></a>00388       _POSSIBLE_MY_HEADER: <span class="stringliteral">&#39;header this file may implement&#39;</span>,
<a name="l00389"></a>00389       _OTHER_HEADER: <span class="stringliteral">&#39;other header&#39;</span>,
<a name="l00390"></a>00390       }
<a name="l00391"></a>00391   _SECTION_NAMES = {
<a name="l00392"></a>00392       _INITIAL_SECTION: <span class="stringliteral">&quot;... nothing. (This can&#39;t be an error.)&quot;</span>,
<a name="l00393"></a>00393       _MY_H_SECTION: <span class="stringliteral">&#39;a header this file implements&#39;</span>,
<a name="l00394"></a>00394       _C_SECTION: <span class="stringliteral">&#39;C system header&#39;</span>,
<a name="l00395"></a>00395       _CPP_SECTION: <span class="stringliteral">&#39;C++ system header&#39;</span>,
<a name="l00396"></a>00396       _OTHER_H_SECTION: <span class="stringliteral">&#39;other header&#39;</span>,
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="keyword">def </span>__init__(self):
<a name="l00400"></a>00400     dict.__init__(self)
<a name="l00401"></a>00401     <span class="comment"># The name of the current section.</span>
<a name="l00402"></a>00402     self._section = self._INITIAL_SECTION
<a name="l00403"></a>00403     <span class="comment"># The path of last found header.</span>
<a name="l00404"></a>00404     self._last_header = <span class="stringliteral">&#39;&#39;</span>
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keyword">def </span>CanonicalizeAlphabeticalOrder(self, header_path):
<a name="l00407"></a>00407     <span class="stringliteral">&quot;&quot;&quot;Returns a path canonicalized for alphabetical comparisson.</span>
<a name="l00408"></a>00408 <span class="stringliteral"></span>
<a name="l00409"></a>00409 <span class="stringliteral">    - replaces &quot;-&quot; with &quot;_&quot; so they both cmp the same.</span>
<a name="l00410"></a>00410 <span class="stringliteral">    - removes &#39;-inl&#39; since we don&#39;t require them to be after the main header.</span>
<a name="l00411"></a>00411 <span class="stringliteral">    - lowercase everything, just in case.</span>
<a name="l00412"></a>00412 <span class="stringliteral"></span>
<a name="l00413"></a>00413 <span class="stringliteral">    Args:</span>
<a name="l00414"></a>00414 <span class="stringliteral">      header_path: Path to be canonicalized.</span>
<a name="l00415"></a>00415 <span class="stringliteral"></span>
<a name="l00416"></a>00416 <span class="stringliteral">    Returns:</span>
<a name="l00417"></a>00417 <span class="stringliteral">      Canonicalized path.</span>
<a name="l00418"></a>00418 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00419"></a>00419     <span class="keywordflow">return</span> header_path.replace(<span class="stringliteral">&#39;-inl.h&#39;</span>, <span class="stringliteral">&#39;.h&#39;</span>).replace(<span class="stringliteral">&#39;-&#39;</span>, <span class="stringliteral">&#39;_&#39;</span>).lower()
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="keyword">def </span>IsInAlphabeticalOrder(self, header_path):
<a name="l00422"></a>00422     <span class="stringliteral">&quot;&quot;&quot;Check if a header is in alphabetical order with the previous header.</span>
<a name="l00423"></a>00423 <span class="stringliteral"></span>
<a name="l00424"></a>00424 <span class="stringliteral">    Args:</span>
<a name="l00425"></a>00425 <span class="stringliteral">      header_path: Header to be checked.</span>
<a name="l00426"></a>00426 <span class="stringliteral"></span>
<a name="l00427"></a>00427 <span class="stringliteral">    Returns:</span>
<a name="l00428"></a>00428 <span class="stringliteral">      Returns true if the header is in alphabetical order.</span>
<a name="l00429"></a>00429 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00430"></a>00430     canonical_header = self.CanonicalizeAlphabeticalOrder(header_path)
<a name="l00431"></a>00431     <span class="keywordflow">if</span> self._last_header &gt; canonical_header:
<a name="l00432"></a>00432       <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00433"></a>00433     self._last_header = canonical_header
<a name="l00434"></a>00434     <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00435"></a>00435 
<a name="l00436"></a>00436   <span class="keyword">def </span>CheckNextIncludeOrder(self, header_type):
<a name="l00437"></a>00437     <span class="stringliteral">&quot;&quot;&quot;Returns a non-empty error message if the next header is out of order.</span>
<a name="l00438"></a>00438 <span class="stringliteral"></span>
<a name="l00439"></a>00439 <span class="stringliteral">    This function also updates the internal state to be ready to check</span>
<a name="l00440"></a>00440 <span class="stringliteral">    the next include.</span>
<a name="l00441"></a>00441 <span class="stringliteral"></span>
<a name="l00442"></a>00442 <span class="stringliteral">    Args:</span>
<a name="l00443"></a>00443 <span class="stringliteral">      header_type: One of the _XXX_HEADER constants defined above.</span>
<a name="l00444"></a>00444 <span class="stringliteral"></span>
<a name="l00445"></a>00445 <span class="stringliteral">    Returns:</span>
<a name="l00446"></a>00446 <span class="stringliteral">      The empty string if the header is in the right order, or an</span>
<a name="l00447"></a>00447 <span class="stringliteral">      error message describing what&#39;s wrong.</span>
<a name="l00448"></a>00448 <span class="stringliteral"></span>
<a name="l00449"></a>00449 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00450"></a>00450     error_message = (<span class="stringliteral">&#39;Found %s after %s&#39;</span> %
<a name="l00451"></a>00451                      (self._TYPE_NAMES[header_type],
<a name="l00452"></a>00452                       self._SECTION_NAMES[self._section]))
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     last_section = self._section
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="keywordflow">if</span> header_type == _C_SYS_HEADER:
<a name="l00457"></a>00457       <span class="keywordflow">if</span> self._section &lt;= self._C_SECTION:
<a name="l00458"></a>00458         self._section = self._C_SECTION
<a name="l00459"></a>00459       <span class="keywordflow">else</span>:
<a name="l00460"></a>00460         self._last_header = <span class="stringliteral">&#39;&#39;</span>
<a name="l00461"></a>00461         <span class="keywordflow">return</span> error_message
<a name="l00462"></a>00462     <span class="keywordflow">elif</span> header_type == _CPP_SYS_HEADER:
<a name="l00463"></a>00463       <span class="keywordflow">if</span> self._section &lt;= self._CPP_SECTION:
<a name="l00464"></a>00464         self._section = self._CPP_SECTION
<a name="l00465"></a>00465       <span class="keywordflow">else</span>:
<a name="l00466"></a>00466         self._last_header = <span class="stringliteral">&#39;&#39;</span>
<a name="l00467"></a>00467         <span class="keywordflow">return</span> error_message
<a name="l00468"></a>00468     <span class="keywordflow">elif</span> header_type == _LIKELY_MY_HEADER:
<a name="l00469"></a>00469       <span class="keywordflow">if</span> self._section &lt;= self._MY_H_SECTION:
<a name="l00470"></a>00470         self._section = self._MY_H_SECTION
<a name="l00471"></a>00471       <span class="keywordflow">else</span>:
<a name="l00472"></a>00472         self._section = self._OTHER_H_SECTION
<a name="l00473"></a>00473     <span class="keywordflow">elif</span> header_type == _POSSIBLE_MY_HEADER:
<a name="l00474"></a>00474       <span class="keywordflow">if</span> self._section &lt;= self._MY_H_SECTION:
<a name="l00475"></a>00475         self._section = self._MY_H_SECTION
<a name="l00476"></a>00476       <span class="keywordflow">else</span>:
<a name="l00477"></a>00477         <span class="comment"># This will always be the fallback because we&#39;re not sure</span>
<a name="l00478"></a>00478         <span class="comment"># enough that the header is associated with this file.</span>
<a name="l00479"></a>00479         self._section = self._OTHER_H_SECTION
<a name="l00480"></a>00480     <span class="keywordflow">else</span>:
<a name="l00481"></a>00481       <span class="keyword">assert</span> header_type == _OTHER_HEADER
<a name="l00482"></a>00482       self._section = self._OTHER_H_SECTION
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keywordflow">if</span> last_section != self._section:
<a name="l00485"></a>00485       self._last_header = <span class="stringliteral">&#39;&#39;</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keyword">class </span>_CppLintState(object):
<a name="l00491"></a>00491   <span class="stringliteral">&quot;&quot;&quot;Maintains module-wide state..&quot;&quot;&quot;</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="keyword">def </span>__init__(self):
<a name="l00494"></a>00494     self.verbose_level = 1  <span class="comment"># global setting.</span>
<a name="l00495"></a>00495     self.error_count = 0    <span class="comment"># global count of reported errors</span>
<a name="l00496"></a>00496     <span class="comment"># filters to apply when emitting error messages</span>
<a name="l00497"></a>00497     self.filters = _DEFAULT_FILTERS[:]
<a name="l00498"></a>00498     self.counting = <span class="stringliteral">&#39;total&#39;</span>  <span class="comment"># In what way are we counting errors?</span>
<a name="l00499"></a>00499     self.errors_by_category = {}  <span class="comment"># string to int dict storing error counts</span>
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     <span class="comment"># output format:</span>
<a name="l00502"></a>00502     <span class="comment"># &quot;emacs&quot; - format that emacs can parse (default)</span>
<a name="l00503"></a>00503     <span class="comment"># &quot;vs7&quot; - format that Microsoft Visual Studio 7 can parse</span>
<a name="l00504"></a>00504     self.output_format = <span class="stringliteral">&#39;emacs&#39;</span>
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keyword">def </span>SetOutputFormat(self, output_format):
<a name="l00507"></a>00507     <span class="stringliteral">&quot;&quot;&quot;Sets the output format for errors.&quot;&quot;&quot;</span>
<a name="l00508"></a>00508     self.output_format = output_format
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="keyword">def </span>SetVerboseLevel(self, level):
<a name="l00511"></a>00511     <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s verbosity, and returns the previous setting.&quot;&quot;&quot;</span>
<a name="l00512"></a>00512     last_verbose_level = self.verbose_level
<a name="l00513"></a>00513     self.verbose_level = level
<a name="l00514"></a>00514     <span class="keywordflow">return</span> last_verbose_level
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="keyword">def </span>SetCountingStyle(self, counting_style):
<a name="l00517"></a>00517     <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s counting options.&quot;&quot;&quot;</span>
<a name="l00518"></a>00518     self.counting = counting_style
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keyword">def </span>SetFilters(self, filters):
<a name="l00521"></a>00521     <span class="stringliteral">&quot;&quot;&quot;Sets the error-message filters.</span>
<a name="l00522"></a>00522 <span class="stringliteral"></span>
<a name="l00523"></a>00523 <span class="stringliteral">    These filters are applied when deciding whether to emit a given</span>
<a name="l00524"></a>00524 <span class="stringliteral">    error message.</span>
<a name="l00525"></a>00525 <span class="stringliteral"></span>
<a name="l00526"></a>00526 <span class="stringliteral">    Args:</span>
<a name="l00527"></a>00527 <span class="stringliteral">      filters: A string of comma-separated filters (eg &quot;+whitespace/indent&quot;).</span>
<a name="l00528"></a>00528 <span class="stringliteral">               Each filter should start with + or -; else we die.</span>
<a name="l00529"></a>00529 <span class="stringliteral"></span>
<a name="l00530"></a>00530 <span class="stringliteral">    Raises:</span>
<a name="l00531"></a>00531 <span class="stringliteral">      ValueError: The comma-separated filters did not all start with &#39;+&#39; or &#39;-&#39;.</span>
<a name="l00532"></a>00532 <span class="stringliteral">                  E.g. &quot;-,+whitespace,-whitespace/indent,whitespace/badfilter&quot;</span>
<a name="l00533"></a>00533 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00534"></a>00534     <span class="comment"># Default filters always have less priority than the flag ones.</span>
<a name="l00535"></a>00535     self.filters = _DEFAULT_FILTERS[:]
<a name="l00536"></a>00536     <span class="keywordflow">for</span> filt <span class="keywordflow">in</span> filters.split(<span class="stringliteral">&#39;,&#39;</span>):
<a name="l00537"></a>00537       clean_filt = filt.strip()
<a name="l00538"></a>00538       <span class="keywordflow">if</span> clean_filt:
<a name="l00539"></a>00539         self.filters.append(clean_filt)
<a name="l00540"></a>00540     <span class="keywordflow">for</span> filt <span class="keywordflow">in</span> self.filters:
<a name="l00541"></a>00541       <span class="keywordflow">if</span> <span class="keywordflow">not</span> (filt.startswith(<span class="stringliteral">&#39;+&#39;</span>) <span class="keywordflow">or</span> filt.startswith(<span class="stringliteral">&#39;-&#39;</span>)):
<a name="l00542"></a>00542         <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Every filter in --filters must start with + or -&#39;</span>
<a name="l00543"></a>00543                          <span class="stringliteral">&#39; (%s does not)&#39;</span> % filt)
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keyword">def </span>ResetErrorCounts(self):
<a name="l00546"></a>00546     <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s error statistic back to zero.&quot;&quot;&quot;</span>
<a name="l00547"></a>00547     self.error_count = 0
<a name="l00548"></a>00548     self.errors_by_category = {}
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="keyword">def </span>IncrementErrorCount(self, category):
<a name="l00551"></a>00551     <span class="stringliteral">&quot;&quot;&quot;Bumps the module&#39;s error statistic.&quot;&quot;&quot;</span>
<a name="l00552"></a>00552     self.error_count += 1
<a name="l00553"></a>00553     <span class="keywordflow">if</span> self.counting <span class="keywordflow">in</span> (<span class="stringliteral">&#39;toplevel&#39;</span>, <span class="stringliteral">&#39;detailed&#39;</span>):
<a name="l00554"></a>00554       <span class="keywordflow">if</span> self.counting != <span class="stringliteral">&#39;detailed&#39;</span>:
<a name="l00555"></a>00555         category = category.split(<span class="stringliteral">&#39;/&#39;</span>)[0]
<a name="l00556"></a>00556       <span class="keywordflow">if</span> category <span class="keywordflow">not</span> <span class="keywordflow">in</span> self.errors_by_category:
<a name="l00557"></a>00557         self.errors_by_category[category] = 0
<a name="l00558"></a>00558       self.errors_by_category[category] += 1
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <span class="keyword">def </span>PrintErrorCounts(self):
<a name="l00561"></a>00561     <span class="stringliteral">&quot;&quot;&quot;Print a summary of errors by category, and the total.&quot;&quot;&quot;</span>
<a name="l00562"></a>00562     <span class="keywordflow">for</span> category, count <span class="keywordflow">in</span> self.errors_by_category.iteritems():
<a name="l00563"></a>00563       sys.stderr.write(<span class="stringliteral">&#39;Category \&#39;%s\&#39; errors found: %d\n&#39;</span> %
<a name="l00564"></a>00564                        (category, count))
<a name="l00565"></a>00565     sys.stderr.write(<span class="stringliteral">&#39;Total errors found: %d\n&#39;</span> % self.error_count)
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 _cpplint_state = _CppLintState()
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keyword">def </span>_OutputFormat():
<a name="l00571"></a>00571   <span class="stringliteral">&quot;&quot;&quot;Gets the module&#39;s output format.&quot;&quot;&quot;</span>
<a name="l00572"></a>00572   <span class="keywordflow">return</span> _cpplint_state.output_format
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keyword">def </span>_SetOutputFormat(output_format):
<a name="l00576"></a>00576   <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s output format.&quot;&quot;&quot;</span>
<a name="l00577"></a>00577   _cpplint_state.SetOutputFormat(output_format)
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="keyword">def </span>_VerboseLevel():
<a name="l00581"></a>00581   <span class="stringliteral">&quot;&quot;&quot;Returns the module&#39;s verbosity setting.&quot;&quot;&quot;</span>
<a name="l00582"></a>00582   <span class="keywordflow">return</span> _cpplint_state.verbose_level
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="keyword">def </span>_SetVerboseLevel(level):
<a name="l00586"></a>00586   <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s verbosity, and returns the previous setting.&quot;&quot;&quot;</span>
<a name="l00587"></a>00587   <span class="keywordflow">return</span> _cpplint_state.SetVerboseLevel(level)
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="keyword">def </span>_SetCountingStyle(level):
<a name="l00591"></a>00591   <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s counting options.&quot;&quot;&quot;</span>
<a name="l00592"></a>00592   _cpplint_state.SetCountingStyle(level)
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="keyword">def </span>_Filters():
<a name="l00596"></a>00596   <span class="stringliteral">&quot;&quot;&quot;Returns the module&#39;s list of output filters, as a list.&quot;&quot;&quot;</span>
<a name="l00597"></a>00597   <span class="keywordflow">return</span> _cpplint_state.filters
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="keyword">def </span>_SetFilters(filters):
<a name="l00601"></a>00601   <span class="stringliteral">&quot;&quot;&quot;Sets the module&#39;s error-message filters.</span>
<a name="l00602"></a>00602 <span class="stringliteral"></span>
<a name="l00603"></a>00603 <span class="stringliteral">  These filters are applied when deciding whether to emit a given</span>
<a name="l00604"></a>00604 <span class="stringliteral">  error message.</span>
<a name="l00605"></a>00605 <span class="stringliteral"></span>
<a name="l00606"></a>00606 <span class="stringliteral">  Args:</span>
<a name="l00607"></a>00607 <span class="stringliteral">    filters: A string of comma-separated filters (eg &quot;whitespace/indent&quot;).</span>
<a name="l00608"></a>00608 <span class="stringliteral">             Each filter should start with + or -; else we die.</span>
<a name="l00609"></a>00609 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00610"></a>00610   _cpplint_state.SetFilters(filters)
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="keyword">class </span>_FunctionState(object):
<a name="l00614"></a>00614   <span class="stringliteral">&quot;&quot;&quot;Tracks current function name and the number of lines in its body.&quot;&quot;&quot;</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   _NORMAL_TRIGGER = 250  <span class="comment"># for --v=0, 500 for --v=1, etc.</span>
<a name="l00617"></a>00617   _TEST_TRIGGER = 400    <span class="comment"># about 50% more than _NORMAL_TRIGGER.</span>
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="keyword">def </span>__init__(self):
<a name="l00620"></a>00620     self.in_a_function = <span class="keyword">False</span>
<a name="l00621"></a>00621     self.lines_in_function = 0
<a name="l00622"></a>00622     self.current_function = <span class="stringliteral">&#39;&#39;</span>
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keyword">def </span>Begin(self, function_name):
<a name="l00625"></a>00625     <span class="stringliteral">&quot;&quot;&quot;Start analyzing function body.</span>
<a name="l00626"></a>00626 <span class="stringliteral"></span>
<a name="l00627"></a>00627 <span class="stringliteral">    Args:</span>
<a name="l00628"></a>00628 <span class="stringliteral">      function_name: The name of the function being tracked.</span>
<a name="l00629"></a>00629 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00630"></a>00630     self.in_a_function = <span class="keyword">True</span>
<a name="l00631"></a>00631     self.lines_in_function = 0
<a name="l00632"></a>00632     self.current_function = function_name
<a name="l00633"></a>00633 
<a name="l00634"></a>00634   <span class="keyword">def </span>Count(self):
<a name="l00635"></a>00635     <span class="stringliteral">&quot;&quot;&quot;Count line in current function body.&quot;&quot;&quot;</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span> self.in_a_function:
<a name="l00637"></a>00637       self.lines_in_function += 1
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="keyword">def </span>Check(self, error, filename, linenum):
<a name="l00640"></a>00640     <span class="stringliteral">&quot;&quot;&quot;Report if too many lines in function body.</span>
<a name="l00641"></a>00641 <span class="stringliteral"></span>
<a name="l00642"></a>00642 <span class="stringliteral">    Args:</span>
<a name="l00643"></a>00643 <span class="stringliteral">      error: The function to call with any errors found.</span>
<a name="l00644"></a>00644 <span class="stringliteral">      filename: The name of the current file.</span>
<a name="l00645"></a>00645 <span class="stringliteral">      linenum: The number of the line to check.</span>
<a name="l00646"></a>00646 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00647"></a>00647     <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;T(EST|est)&#39;</span>, self.current_function):
<a name="l00648"></a>00648       base_trigger = self._TEST_TRIGGER
<a name="l00649"></a>00649     <span class="keywordflow">else</span>:
<a name="l00650"></a>00650       base_trigger = self._NORMAL_TRIGGER
<a name="l00651"></a>00651     trigger = base_trigger * 2**_VerboseLevel()
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     <span class="keywordflow">if</span> self.lines_in_function &gt; trigger:
<a name="l00654"></a>00654       error_level = int(math.log(self.lines_in_function / base_trigger, 2))
<a name="l00655"></a>00655       <span class="comment"># 50 =&gt; 0, 100 =&gt; 1, 200 =&gt; 2, 400 =&gt; 3, 800 =&gt; 4, 1600 =&gt; 5, ...</span>
<a name="l00656"></a>00656       <span class="keywordflow">if</span> error_level &gt; 5:
<a name="l00657"></a>00657         error_level = 5
<a name="l00658"></a>00658       error(filename, linenum, <span class="stringliteral">&#39;readability/fn_size&#39;</span>, error_level,
<a name="l00659"></a>00659             <span class="stringliteral">&#39;Small and focused functions are preferred:&#39;</span>
<a name="l00660"></a>00660             <span class="stringliteral">&#39; %s has %d non-comment lines&#39;</span>
<a name="l00661"></a>00661             <span class="stringliteral">&#39; (error triggered by exceeding %d lines).&#39;</span>  % (
<a name="l00662"></a>00662                 self.current_function, self.lines_in_function, trigger))
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="keyword">def </span>End(self):
<a name="l00665"></a>00665     <span class="stringliteral">&quot;&quot;&quot;Stop analizing function body.&quot;&quot;&quot;</span>
<a name="l00666"></a>00666     self.in_a_function = <span class="keyword">False</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="keyword">class </span>_IncludeError(Exception):
<a name="l00670"></a>00670   <span class="stringliteral">&quot;&quot;&quot;Indicates a problem with the include order in a file.&quot;&quot;&quot;</span>
<a name="l00671"></a>00671   <span class="keywordflow">pass</span>
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="keyword">class </span>FileInfo:
<a name="l00675"></a>00675   <span class="stringliteral">&quot;&quot;&quot;Provides utility functions for filenames.</span>
<a name="l00676"></a>00676 <span class="stringliteral"></span>
<a name="l00677"></a>00677 <span class="stringliteral">  FileInfo provides easy access to the components of a file&#39;s path</span>
<a name="l00678"></a>00678 <span class="stringliteral">  relative to the project root.</span>
<a name="l00679"></a>00679 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="keyword">def </span>__init__(self, filename):
<a name="l00682"></a>00682     self._filename = filename
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="keyword">def </span>FullName(self):
<a name="l00685"></a>00685     <span class="stringliteral">&quot;&quot;&quot;Make Windows paths like Unix.&quot;&quot;&quot;</span>
<a name="l00686"></a>00686     <span class="keywordflow">return</span> os.path.abspath(self._filename).replace(<span class="stringliteral">&#39;\\&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="keyword">def </span>RepositoryName(self):
<a name="l00689"></a>00689     <span class="stringliteral">&quot;&quot;&quot;FullName after removing the local path to the repository.</span>
<a name="l00690"></a>00690 <span class="stringliteral"></span>
<a name="l00691"></a>00691 <span class="stringliteral">    If we have a real absolute path name here we can try to do something smart:</span>
<a name="l00692"></a>00692 <span class="stringliteral">    detecting the root of the checkout and truncating /path/to/checkout from</span>
<a name="l00693"></a>00693 <span class="stringliteral">    the name so that we get header guards that don&#39;t include things like</span>
<a name="l00694"></a>00694 <span class="stringliteral">    &quot;C:\Documents and Settings\...&quot; or &quot;/home/username/...&quot; in them and thus</span>
<a name="l00695"></a>00695 <span class="stringliteral">    people on different computers who have checked the source out to different</span>
<a name="l00696"></a>00696 <span class="stringliteral">    locations won&#39;t see bogus errors.</span>
<a name="l00697"></a>00697 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00698"></a>00698     fullname = self.FullName()
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="keywordflow">if</span> os.path.exists(fullname):
<a name="l00701"></a>00701       project_dir = os.path.dirname(fullname)
<a name="l00702"></a>00702 
<a name="l00703"></a>00703       <span class="keywordflow">if</span> os.path.exists(os.path.join(project_dir, <span class="stringliteral">&quot;.svn&quot;</span>)):
<a name="l00704"></a>00704         <span class="comment"># If there&#39;s a .svn file in the current directory, we recursively look</span>
<a name="l00705"></a>00705         <span class="comment"># up the directory tree for the top of the SVN checkout</span>
<a name="l00706"></a>00706         root_dir = project_dir
<a name="l00707"></a>00707         one_up_dir = os.path.dirname(root_dir)
<a name="l00708"></a>00708         <span class="keywordflow">while</span> os.path.exists(os.path.join(one_up_dir, <span class="stringliteral">&quot;.svn&quot;</span>)):
<a name="l00709"></a>00709           root_dir = os.path.dirname(root_dir)
<a name="l00710"></a>00710           one_up_dir = os.path.dirname(one_up_dir)
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         prefix = os.path.commonprefix([root_dir, project_dir])
<a name="l00713"></a>00713         <span class="keywordflow">return</span> fullname[len(prefix) + 1:]
<a name="l00714"></a>00714 
<a name="l00715"></a>00715       <span class="comment"># Not SVN? Try to find a git or hg top level directory by searching up</span>
<a name="l00716"></a>00716       <span class="comment"># from the current path.</span>
<a name="l00717"></a>00717       root_dir = os.path.dirname(fullname)
<a name="l00718"></a>00718       <span class="keywordflow">while</span> (root_dir != os.path.dirname(root_dir) <span class="keywordflow">and</span>
<a name="l00719"></a>00719              <span class="keywordflow">not</span> os.path.exists(os.path.join(root_dir, <span class="stringliteral">&quot;.git&quot;</span>)) <span class="keywordflow">and</span>
<a name="l00720"></a>00720              <span class="keywordflow">not</span> os.path.exists(os.path.join(root_dir, <span class="stringliteral">&quot;.hg&quot;</span>))):
<a name="l00721"></a>00721         root_dir = os.path.dirname(root_dir)
<a name="l00722"></a>00722 
<a name="l00723"></a>00723       <span class="keywordflow">if</span> (os.path.exists(os.path.join(root_dir, <span class="stringliteral">&quot;.git&quot;</span>)) <span class="keywordflow">or</span>
<a name="l00724"></a>00724           os.path.exists(os.path.join(root_dir, <span class="stringliteral">&quot;.hg&quot;</span>))):
<a name="l00725"></a>00725         prefix = os.path.commonprefix([root_dir, project_dir])
<a name="l00726"></a>00726         <span class="keywordflow">return</span> fullname[len(prefix) + 1:]
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     <span class="comment"># Don&#39;t know what to do; header guard warnings may be wrong...</span>
<a name="l00729"></a>00729     <span class="keywordflow">return</span> fullname
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <span class="keyword">def </span>Split(self):
<a name="l00732"></a>00732     <span class="stringliteral">&quot;&quot;&quot;Splits the file into the directory, basename, and extension.</span>
<a name="l00733"></a>00733 <span class="stringliteral"></span>
<a name="l00734"></a>00734 <span class="stringliteral">    For &#39;chrome/browser/browser.cc&#39;, Split() would</span>
<a name="l00735"></a>00735 <span class="stringliteral">    return (&#39;chrome/browser&#39;, &#39;browser&#39;, &#39;.cc&#39;)</span>
<a name="l00736"></a>00736 <span class="stringliteral"></span>
<a name="l00737"></a>00737 <span class="stringliteral">    Returns:</span>
<a name="l00738"></a>00738 <span class="stringliteral">      A tuple of (directory, basename, extension).</span>
<a name="l00739"></a>00739 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     googlename = self.RepositoryName()
<a name="l00742"></a>00742     project, rest = os.path.split(googlename)
<a name="l00743"></a>00743     <span class="keywordflow">return</span> (project,) + os.path.splitext(rest)
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <span class="keyword">def </span>BaseName(self):
<a name="l00746"></a>00746     <span class="stringliteral">&quot;&quot;&quot;File base name - text after the final slash, before the final period.&quot;&quot;&quot;</span>
<a name="l00747"></a>00747     <span class="keywordflow">return</span> self.Split()[1]
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="keyword">def </span>Extension(self):
<a name="l00750"></a>00750     <span class="stringliteral">&quot;&quot;&quot;File extension - text following the final period.&quot;&quot;&quot;</span>
<a name="l00751"></a>00751     <span class="keywordflow">return</span> self.Split()[2]
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="keyword">def </span>NoExtension(self):
<a name="l00754"></a>00754     <span class="stringliteral">&quot;&quot;&quot;File has no source file extension.&quot;&quot;&quot;</span>
<a name="l00755"></a>00755     <span class="keywordflow">return</span> <span class="stringliteral">&#39;/&#39;</span>.join(self.Split()[0:2])
<a name="l00756"></a>00756 
<a name="l00757"></a>00757   <span class="keyword">def </span>IsSource(self):
<a name="l00758"></a>00758     <span class="stringliteral">&quot;&quot;&quot;File has a source file extension.&quot;&quot;&quot;</span>
<a name="l00759"></a>00759     <span class="keywordflow">return</span> self.Extension()[1:] <span class="keywordflow">in</span> (<span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;cc&#39;</span>, <span class="stringliteral">&#39;cpp&#39;</span>, <span class="stringliteral">&#39;cxx&#39;</span>)
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="keyword">def </span>_ShouldPrintError(category, confidence, linenum):
<a name="l00763"></a>00763   <span class="stringliteral">&quot;&quot;&quot;Returns true iff confidence &gt;= verbose, category passes</span>
<a name="l00764"></a>00764 <span class="stringliteral">  filter and is not NOLINT-suppressed.&quot;&quot;&quot;</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   <span class="comment"># There are three ways we might decide not to print an error message:</span>
<a name="l00767"></a>00767   <span class="comment"># a &quot;NOLINT(category)&quot; comment appears in the source,</span>
<a name="l00768"></a>00768   <span class="comment"># the verbosity level isn&#39;t high enough, or the filters filter it out.</span>
<a name="l00769"></a>00769   <span class="keywordflow">if</span> IsErrorSuppressedByNolint(category, linenum):
<a name="l00770"></a>00770     <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00771"></a>00771   <span class="keywordflow">if</span> confidence &lt; _cpplint_state.verbose_level:
<a name="l00772"></a>00772     <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00773"></a>00773 
<a name="l00774"></a>00774   is_filtered = <span class="keyword">False</span>
<a name="l00775"></a>00775   <span class="keywordflow">for</span> one_filter <span class="keywordflow">in</span> _Filters():
<a name="l00776"></a>00776     <span class="keywordflow">if</span> one_filter.startswith(<span class="stringliteral">&#39;-&#39;</span>):
<a name="l00777"></a>00777       <span class="keywordflow">if</span> category.startswith(one_filter[1:]):
<a name="l00778"></a>00778         is_filtered = <span class="keyword">True</span>
<a name="l00779"></a>00779     <span class="keywordflow">elif</span> one_filter.startswith(<span class="stringliteral">&#39;+&#39;</span>):
<a name="l00780"></a>00780       <span class="keywordflow">if</span> category.startswith(one_filter[1:]):
<a name="l00781"></a>00781         is_filtered = <span class="keyword">False</span>
<a name="l00782"></a>00782     <span class="keywordflow">else</span>:
<a name="l00783"></a>00783       <span class="keyword">assert</span> <span class="keyword">False</span>  <span class="comment"># should have been checked for in SetFilter.</span>
<a name="l00784"></a>00784   <span class="keywordflow">if</span> is_filtered:
<a name="l00785"></a>00785     <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="keyword">def </span>Error(filename, linenum, category, confidence, message):
<a name="l00791"></a>00791   <span class="stringliteral">&quot;&quot;&quot;Logs the fact we&#39;ve found a lint error.</span>
<a name="l00792"></a>00792 <span class="stringliteral"></span>
<a name="l00793"></a>00793 <span class="stringliteral">  We log where the error was found, and also our confidence in the error,</span>
<a name="l00794"></a>00794 <span class="stringliteral">  that is, how certain we are this is a legitimate style regression, and</span>
<a name="l00795"></a>00795 <span class="stringliteral">  not a misidentification or a use that&#39;s sometimes justified.</span>
<a name="l00796"></a>00796 <span class="stringliteral"></span>
<a name="l00797"></a>00797 <span class="stringliteral">  False positives can be suppressed by the use of</span>
<a name="l00798"></a>00798 <span class="stringliteral">  &quot;cpplint(category)&quot;  comments on the offending line.  These are</span>
<a name="l00799"></a>00799 <span class="stringliteral">  parsed into _error_suppressions.</span>
<a name="l00800"></a>00800 <span class="stringliteral"></span>
<a name="l00801"></a>00801 <span class="stringliteral">  Args:</span>
<a name="l00802"></a>00802 <span class="stringliteral">    filename: The name of the file containing the error.</span>
<a name="l00803"></a>00803 <span class="stringliteral">    linenum: The number of the line containing the error.</span>
<a name="l00804"></a>00804 <span class="stringliteral">    category: A string used to describe the &quot;category&quot; this bug</span>
<a name="l00805"></a>00805 <span class="stringliteral">      falls under: &quot;whitespace&quot;, say, or &quot;runtime&quot;.  Categories</span>
<a name="l00806"></a>00806 <span class="stringliteral">      may have a hierarchy separated by slashes: &quot;whitespace/indent&quot;.</span>
<a name="l00807"></a>00807 <span class="stringliteral">    confidence: A number from 1-5 representing a confidence score for</span>
<a name="l00808"></a>00808 <span class="stringliteral">      the error, with 5 meaning that we are certain of the problem,</span>
<a name="l00809"></a>00809 <span class="stringliteral">      and 1 meaning that it could be a legitimate construct.</span>
<a name="l00810"></a>00810 <span class="stringliteral">    message: The error message.</span>
<a name="l00811"></a>00811 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00812"></a>00812   <span class="keywordflow">if</span> _ShouldPrintError(category, confidence, linenum):
<a name="l00813"></a>00813     _cpplint_state.IncrementErrorCount(category)
<a name="l00814"></a>00814     <span class="keywordflow">if</span> _cpplint_state.output_format == <span class="stringliteral">&#39;vs7&#39;</span>:
<a name="l00815"></a>00815       sys.stderr.write(<span class="stringliteral">&#39;%s(%s):  %s  [%s] [%d]\n&#39;</span> % (
<a name="l00816"></a>00816           filename, linenum, message, category, confidence))
<a name="l00817"></a>00817     <span class="keywordflow">else</span>:
<a name="l00818"></a>00818       sys.stderr.write(<span class="stringliteral">&#39;%s:%s:  %s  [%s] [%d]\n&#39;</span> % (
<a name="l00819"></a>00819           filename, linenum, message, category, confidence))
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="comment"># Matches standard C++ escape esequences per 2.13.2.3 of the C++ standard.</span>
<a name="l00823"></a>00823 _RE_PATTERN_CLEANSE_LINE_ESCAPES = re.compile(
<a name="l00824"></a>00824     <span class="stringliteral">r&#39;\\([abfnrtv?&quot;\\\&#39;]|\d+|x[0-9a-fA-F]+)&#39;</span>)
<a name="l00825"></a>00825 <span class="comment"># Matches strings.  Escape codes should already be removed by ESCAPES.</span>
<a name="l00826"></a>00826 _RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES = re.compile(<span class="stringliteral">r&#39;&quot;[^&quot;]*&quot;&#39;</span>)
<a name="l00827"></a>00827 <span class="comment"># Matches characters.  Escape codes should already be removed by ESCAPES.</span>
<a name="l00828"></a>00828 _RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES = re.compile(<span class="stringliteral">r&quot;&#39;.&#39;&quot;</span>)
<a name="l00829"></a>00829 <span class="comment"># Matches multi-line C++ comments.</span>
<a name="l00830"></a>00830 <span class="comment"># This RE is a little bit more complicated than one might expect, because we</span>
<a name="l00831"></a>00831 <span class="comment"># have to take care of space removals tools so we can handle comments inside</span>
<a name="l00832"></a>00832 <span class="comment"># statements better.</span>
<a name="l00833"></a>00833 <span class="comment"># The current rule is: We only clear spaces from both sides when we&#39;re at the</span>
<a name="l00834"></a>00834 <span class="comment"># end of the line. Otherwise, we try to remove spaces from the right side,</span>
<a name="l00835"></a>00835 <span class="comment"># if this doesn&#39;t work we try on left side but only if there&#39;s a non-character</span>
<a name="l00836"></a>00836 <span class="comment"># on the right.</span>
<a name="l00837"></a>00837 _RE_PATTERN_CLEANSE_LINE_C_COMMENTS = re.compile(
<a name="l00838"></a>00838     <span class="stringliteral">r&quot;&quot;&quot;(\s*/\*.*\*/\s*$|</span>
<a name="l00839"></a>00839 <span class="stringliteral">            /\*.*\*/\s+|</span>
<a name="l00840"></a>00840 <span class="stringliteral">         \s+/\*.*\*/(?=\W)|</span>
<a name="l00841"></a>00841 <span class="stringliteral">            /\*.*\*/)&quot;&quot;&quot;</span>, re.VERBOSE)
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 <span class="keyword">def </span>IsCppString(line):
<a name="l00845"></a>00845   <span class="stringliteral">&quot;&quot;&quot;Does line terminate so, that the next symbol is in string constant.</span>
<a name="l00846"></a>00846 <span class="stringliteral"></span>
<a name="l00847"></a>00847 <span class="stringliteral">  This function does not consider single-line nor multi-line comments.</span>
<a name="l00848"></a>00848 <span class="stringliteral"></span>
<a name="l00849"></a>00849 <span class="stringliteral">  Args:</span>
<a name="l00850"></a>00850 <span class="stringliteral">    line: is a partial line of code starting from the 0..n.</span>
<a name="l00851"></a>00851 <span class="stringliteral"></span>
<a name="l00852"></a>00852 <span class="stringliteral">  Returns:</span>
<a name="l00853"></a>00853 <span class="stringliteral">    True, if next character appended to &#39;line&#39; is inside a</span>
<a name="l00854"></a>00854 <span class="stringliteral">    string constant.</span>
<a name="l00855"></a>00855 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   line = line.replace(<span class="stringliteral">r&#39;\\&#39;</span>, <span class="stringliteral">&#39;XX&#39;</span>)  <span class="comment"># after this, \\&quot; does not match to \&quot;</span>
<a name="l00858"></a>00858   <span class="keywordflow">return</span> ((line.count(<span class="stringliteral">&#39;&quot;&#39;</span>) - line.count(<span class="stringliteral">r&#39;\&quot;&#39;</span>) - line.count(<span class="stringliteral">&quot;&#39;\&quot;&#39;&quot;</span>)) &amp; 1) == 1
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="keyword">def </span>FindNextMultiLineCommentStart(lines, lineix):
<a name="l00862"></a>00862   <span class="stringliteral">&quot;&quot;&quot;Find the beginning marker for a multiline comment.&quot;&quot;&quot;</span>
<a name="l00863"></a>00863   <span class="keywordflow">while</span> lineix &lt; len(lines):
<a name="l00864"></a>00864     <span class="keywordflow">if</span> lines[lineix].strip().startswith(<span class="stringliteral">&#39;/*&#39;</span>):
<a name="l00865"></a>00865       <span class="comment"># Only return this marker if the comment goes beyond this line</span>
<a name="l00866"></a>00866       <span class="keywordflow">if</span> lines[lineix].strip().find(<span class="stringliteral">&#39;*/&#39;</span>, 2) &lt; 0:
<a name="l00867"></a>00867         <span class="keywordflow">return</span> lineix
<a name="l00868"></a>00868     lineix += 1
<a name="l00869"></a>00869   <span class="keywordflow">return</span> len(lines)
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="keyword">def </span>FindNextMultiLineCommentEnd(lines, lineix):
<a name="l00873"></a>00873   <span class="stringliteral">&quot;&quot;&quot;We are inside a comment, find the end marker.&quot;&quot;&quot;</span>
<a name="l00874"></a>00874   <span class="keywordflow">while</span> lineix &lt; len(lines):
<a name="l00875"></a>00875     <span class="keywordflow">if</span> lines[lineix].strip().endswith(<span class="stringliteral">&#39;*/&#39;</span>):
<a name="l00876"></a>00876       <span class="keywordflow">return</span> lineix
<a name="l00877"></a>00877     lineix += 1
<a name="l00878"></a>00878   <span class="keywordflow">return</span> len(lines)
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="keyword">def </span>RemoveMultiLineCommentsFromRange(lines, begin, end):
<a name="l00882"></a>00882   <span class="stringliteral">&quot;&quot;&quot;Clears a range of lines for multi-line comments.&quot;&quot;&quot;</span>
<a name="l00883"></a>00883   <span class="comment"># Having // dummy comments makes the lines non-empty, so we will not get</span>
<a name="l00884"></a>00884   <span class="comment"># unnecessary blank line warnings later in the code.</span>
<a name="l00885"></a>00885   <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(begin, end):
<a name="l00886"></a>00886     lines[i] = <span class="stringliteral">&#39;// dummy&#39;</span>
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">def </span>RemoveMultiLineComments(filename, lines, error):
<a name="l00890"></a>00890   <span class="stringliteral">&quot;&quot;&quot;Removes multiline (c-style) comments from lines.&quot;&quot;&quot;</span>
<a name="l00891"></a>00891   lineix = 0
<a name="l00892"></a>00892   <span class="keywordflow">while</span> lineix &lt; len(lines):
<a name="l00893"></a>00893     lineix_begin = FindNextMultiLineCommentStart(lines, lineix)
<a name="l00894"></a>00894     <span class="keywordflow">if</span> lineix_begin &gt;= len(lines):
<a name="l00895"></a>00895       <span class="keywordflow">return</span>
<a name="l00896"></a>00896     lineix_end = FindNextMultiLineCommentEnd(lines, lineix_begin)
<a name="l00897"></a>00897     <span class="keywordflow">if</span> lineix_end &gt;= len(lines):
<a name="l00898"></a>00898       error(filename, lineix_begin + 1, <span class="stringliteral">&#39;readability/multiline_comment&#39;</span>, 5,
<a name="l00899"></a>00899             <span class="stringliteral">&#39;Could not find end of multi-line comment&#39;</span>)
<a name="l00900"></a>00900       <span class="keywordflow">return</span>
<a name="l00901"></a>00901     RemoveMultiLineCommentsFromRange(lines, lineix_begin, lineix_end + 1)
<a name="l00902"></a>00902     lineix = lineix_end + 1
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keyword">def </span>CleanseComments(line):
<a name="l00906"></a>00906   <span class="stringliteral">&quot;&quot;&quot;Removes //-comments and single-line C-style /* */ comments.</span>
<a name="l00907"></a>00907 <span class="stringliteral"></span>
<a name="l00908"></a>00908 <span class="stringliteral">  Args:</span>
<a name="l00909"></a>00909 <span class="stringliteral">    line: A line of C++ source.</span>
<a name="l00910"></a>00910 <span class="stringliteral"></span>
<a name="l00911"></a>00911 <span class="stringliteral">  Returns:</span>
<a name="l00912"></a>00912 <span class="stringliteral">    The line with single-line comments removed.</span>
<a name="l00913"></a>00913 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00914"></a>00914   commentpos = line.find(<span class="stringliteral">&#39;//&#39;</span>)
<a name="l00915"></a>00915   <span class="keywordflow">if</span> commentpos != -1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> IsCppString(line[:commentpos]):
<a name="l00916"></a>00916     line = line[:commentpos]
<a name="l00917"></a>00917   <span class="comment"># get rid of /* ... */</span>
<a name="l00918"></a>00918   <span class="keywordflow">return</span> _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub(<span class="stringliteral">&#39;&#39;</span>, line)
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 
<a name="l00921"></a>00921 <span class="keyword">class </span>CleansedLines(object):
<a name="l00922"></a>00922   <span class="stringliteral">&quot;&quot;&quot;Holds 3 copies of all lines with different preprocessing applied to them.</span>
<a name="l00923"></a>00923 <span class="stringliteral"></span>
<a name="l00924"></a>00924 <span class="stringliteral">  1) elided member contains lines without strings and comments,</span>
<a name="l00925"></a>00925 <span class="stringliteral">  2) lines member contains lines without comments, and</span>
<a name="l00926"></a>00926 <span class="stringliteral">  3) raw member contains all the lines without processing.</span>
<a name="l00927"></a>00927 <span class="stringliteral">  All these three members are of &lt;type &#39;list&#39;&gt;, and of the same length.</span>
<a name="l00928"></a>00928 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="keyword">def </span>__init__(self, lines):
<a name="l00931"></a>00931     self.elided = []
<a name="l00932"></a>00932     self.lines = []
<a name="l00933"></a>00933     self.raw_lines = lines
<a name="l00934"></a>00934     self.num_lines = len(lines)
<a name="l00935"></a>00935     <span class="keywordflow">for</span> linenum <span class="keywordflow">in</span> range(len(lines)):
<a name="l00936"></a>00936       self.lines.append(CleanseComments(lines[linenum]))
<a name="l00937"></a>00937       elided = self._CollapseStrings(lines[linenum])
<a name="l00938"></a>00938       self.elided.append(CleanseComments(elided))
<a name="l00939"></a>00939 
<a name="l00940"></a>00940   <span class="keyword">def </span>NumLines(self):
<a name="l00941"></a>00941     <span class="stringliteral">&quot;&quot;&quot;Returns the number of lines represented.&quot;&quot;&quot;</span>
<a name="l00942"></a>00942     <span class="keywordflow">return</span> self.num_lines
<a name="l00943"></a>00943 
<a name="l00944"></a>00944   @staticmethod
<a name="l00945"></a>00945   <span class="keyword">def </span>_CollapseStrings(elided):
<a name="l00946"></a>00946     <span class="stringliteral">&quot;&quot;&quot;Collapses strings and chars on a line to simple &quot;&quot; or &#39;&#39; blocks.</span>
<a name="l00947"></a>00947 <span class="stringliteral"></span>
<a name="l00948"></a>00948 <span class="stringliteral">    We nix strings first so we&#39;re not fooled by text like &#39;&quot;http://&quot;&#39;</span>
<a name="l00949"></a>00949 <span class="stringliteral"></span>
<a name="l00950"></a>00950 <span class="stringliteral">    Args:</span>
<a name="l00951"></a>00951 <span class="stringliteral">      elided: The line being processed.</span>
<a name="l00952"></a>00952 <span class="stringliteral"></span>
<a name="l00953"></a>00953 <span class="stringliteral">    Returns:</span>
<a name="l00954"></a>00954 <span class="stringliteral">      The line with collapsed strings.</span>
<a name="l00955"></a>00955 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00956"></a>00956     <span class="keywordflow">if</span> <span class="keywordflow">not</span> _RE_PATTERN_INCLUDE.match(elided):
<a name="l00957"></a>00957       <span class="comment"># Remove escaped characters first to make quote/single quote collapsing</span>
<a name="l00958"></a>00958       <span class="comment"># basic.  Things that look like escaped characters shouldn&#39;t occur</span>
<a name="l00959"></a>00959       <span class="comment"># outside of strings and chars.</span>
<a name="l00960"></a><a class="code" href="namespacecpplint.html#a8559d5bdf881337b323a7253a71a5fed">00960</a>       elided = _RE_PATTERN_CLEANSE_LINE_ESCAPES.sub(<span class="stringliteral">&#39;&#39;</span>, elided)
<a name="l00961"></a>00961       elided = _RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES.sub(<span class="stringliteral">&quot;&#39;&#39;&quot;</span>, elided)
<a name="l00962"></a>00962       elided = _RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES.sub(<span class="stringliteral">&#39;&quot;&quot;&#39;</span>, elided)
<a name="l00963"></a>00963     <span class="keywordflow">return</span> elided
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00966"></a><a class="code" href="namespacecpplint.html#a9713059a1f275ecb548f18733306791d">00966</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#a9713059a1f275ecb548f18733306791d">CloseExpression</a>(clean_lines, linenum, pos):
<a name="l00967"></a>00967   <span class="stringliteral">&quot;&quot;&quot;If input points to ( or { or [, finds the position that closes it.</span>
<a name="l00968"></a>00968 <span class="stringliteral"></span>
<a name="l00969"></a>00969 <span class="stringliteral">  If lines[linenum][pos] points to a &#39;(&#39; or &#39;{&#39; or &#39;[&#39;, finds the the</span>
<a name="l00970"></a>00970 <span class="stringliteral">  linenum/pos that correspond to the closing of the expression.</span>
<a name="l00971"></a>00971 <span class="stringliteral"></span>
<a name="l00972"></a>00972 <span class="stringliteral">  Args:</span>
<a name="l00973"></a>00973 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l00974"></a>00974 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l00975"></a>00975 <span class="stringliteral">    pos: A position on the line.</span>
<a name="l00976"></a>00976 <span class="stringliteral"></span>
<a name="l00977"></a>00977 <span class="stringliteral">  Returns:</span>
<a name="l00978"></a>00978 <span class="stringliteral">    A tuple (line, linenum, pos) pointer *past* the closing brace, or</span>
<a name="l00979"></a>00979 <span class="stringliteral">    (line, len(lines), -1) if we never find a close.  Note we ignore</span>
<a name="l00980"></a>00980 <span class="stringliteral">    strings and comments when matching; and the line we return is the</span>
<a name="l00981"></a>00981 <span class="stringliteral">    &#39;cleansed&#39; line at linenum.</span>
<a name="l00982"></a>00982 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l00983"></a>00983 
<a name="l00984"></a>00984   line = clean_lines.elided[linenum]
<a name="l00985"></a>00985   startchar = line[pos]
<a name="l00986"></a>00986   <span class="keywordflow">if</span> startchar <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;({[&#39;</span>:
<a name="l00987"></a>00987     <span class="keywordflow">return</span> (line, clean_lines.NumLines(), -1)
<a name="l00988"></a>00988   <span class="keywordflow">if</span> startchar == <span class="stringliteral">&#39;(&#39;</span>: endchar = <span class="stringliteral">&#39;)&#39;</span>
<a name="l00989"></a>00989   <span class="keywordflow">if</span> startchar == <span class="stringliteral">&#39;[&#39;</span>: endchar = <span class="stringliteral">&#39;]&#39;</span>
<a name="l00990"></a>00990   <span class="keywordflow">if</span> startchar == <span class="stringliteral">&#39;{&#39;</span>: endchar = <span class="stringliteral">&#39;}&#39;</span>
<a name="l00991"></a>00991 
<a name="l00992"></a>00992   num_open = line.count(startchar) - line.count(endchar)
<a name="l00993"></a>00993   <span class="keywordflow">while</span> linenum &lt; clean_lines.NumLines() <span class="keywordflow">and</span> num_open &gt; 0:
<a name="l00994"></a>00994     linenum += 1
<a name="l00995"></a>00995     line = clean_lines.elided[linenum]
<a name="l00996"></a>00996     num_open += line.count(startchar) - line.count(endchar)
<a name="l00997"></a>00997   <span class="comment"># OK, now find the endchar that actually got us back to even</span>
<a name="l00998"></a>00998   endpos = len(line)
<a name="l00999"></a>00999   <span class="keywordflow">while</span> num_open &gt;= 0:
<a name="l01000"></a>01000     endpos = line.rfind(<span class="stringliteral">&#39;)&#39;</span>, 0, endpos)
<a name="l01001"></a>01001     num_open -= 1                 <span class="comment"># chopped off another )</span>
<a name="l01002"></a>01002   <span class="keywordflow">return</span> (line, linenum, endpos + 1)
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 
<a name="l01005"></a><a class="code" href="namespacecpplint.html#ac9cdecc582bc833c2eb7ac6eed6d2624">01005</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#ac9cdecc582bc833c2eb7ac6eed6d2624">CheckForCopyright</a>(filename, lines, error):
<a name="l01006"></a>01006   <span class="stringliteral">&quot;&quot;&quot;Logs an error if no Copyright message appears at the top of the file.&quot;&quot;&quot;</span>
<a name="l01007"></a>01007 
<a name="l01008"></a>01008   <span class="comment"># We&#39;ll say it should occur by line 10. Don&#39;t forget there&#39;s a</span>
<a name="l01009"></a>01009   <span class="comment"># dummy line at the front.</span>
<a name="l01010"></a>01010   <span class="keywordflow">for</span> line <span class="keywordflow">in</span> xrange(1, min(len(lines), 11)):
<a name="l01011"></a>01011     <span class="keywordflow">if</span> re.search(<span class="stringliteral">r&#39;Copyright&#39;</span>, lines[line], re.I): <span class="keywordflow">break</span>
<a name="l01012"></a>01012   <span class="keywordflow">else</span>:                       <span class="comment"># means no copyright line was found</span>
<a name="l01013"></a>01013     error(filename, 0, <span class="stringliteral">&#39;legal/copyright&#39;</span>, 5,
<a name="l01014"></a>01014           <span class="stringliteral">&#39;No copyright message found.  &#39;</span>
<a name="l01015"></a>01015           <span class="stringliteral">&#39;You should have a line: &quot;Copyright [year] &lt;Copyright Owner&gt;&quot;&#39;</span>)
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a><a class="code" href="namespacecpplint.html#a8eedb7313093d59b41bd7c5b19c2ddaf">01018</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#a8eedb7313093d59b41bd7c5b19c2ddaf">GetHeaderGuardCPPVariable</a>(filename):
<a name="l01019"></a>01019   <span class="stringliteral">&quot;&quot;&quot;Returns the CPP variable that should be used as a header guard.</span>
<a name="l01020"></a>01020 <span class="stringliteral"></span>
<a name="l01021"></a>01021 <span class="stringliteral">  Args:</span>
<a name="l01022"></a>01022 <span class="stringliteral">    filename: The name of a C++ header file.</span>
<a name="l01023"></a>01023 <span class="stringliteral"></span>
<a name="l01024"></a>01024 <span class="stringliteral">  Returns:</span>
<a name="l01025"></a>01025 <span class="stringliteral">    The CPP variable that should be used as a header guard in the</span>
<a name="l01026"></a>01026 <span class="stringliteral">    named file.</span>
<a name="l01027"></a>01027 <span class="stringliteral"></span>
<a name="l01028"></a>01028 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01029"></a>01029 
<a name="l01030"></a>01030   <span class="comment"># Restores original filename in case that cpplint is invoked from Emacs&#39;s</span>
<a name="l01031"></a>01031   <span class="comment"># flymake.</span>
<a name="l01032"></a>01032   filename = re.sub(<span class="stringliteral">r&#39;_flymake\.h$&#39;</span>, <span class="stringliteral">&#39;.h&#39;</span>, filename)
<a name="l01033"></a>01033 
<a name="l01034"></a>01034   fileinfo = FileInfo(filename)
<a name="l01035"></a>01035   <span class="keywordflow">return</span> re.sub(<span class="stringliteral">r&#39;[-./\s]&#39;</span>, <span class="stringliteral">&#39;_&#39;</span>, fileinfo.RepositoryName()).upper() + <span class="stringliteral">&#39;_&#39;</span>
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 
<a name="l01038"></a><a class="code" href="namespacecpplint.html#a6ecd551d11dde0a916ef4a6317b70585">01038</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#a6ecd551d11dde0a916ef4a6317b70585">CheckForHeaderGuard</a>(filename, lines, error):
<a name="l01039"></a>01039   <span class="stringliteral">&quot;&quot;&quot;Checks that the file contains a header guard.</span>
<a name="l01040"></a>01040 <span class="stringliteral"></span>
<a name="l01041"></a>01041 <span class="stringliteral">  Logs an error if no #ifndef header guard is present.  For other</span>
<a name="l01042"></a>01042 <span class="stringliteral">  headers, checks that the full pathname is used.</span>
<a name="l01043"></a>01043 <span class="stringliteral"></span>
<a name="l01044"></a>01044 <span class="stringliteral">  Args:</span>
<a name="l01045"></a>01045 <span class="stringliteral">    filename: The name of the C++ header file.</span>
<a name="l01046"></a>01046 <span class="stringliteral">    lines: An array of strings, each representing a line of the file.</span>
<a name="l01047"></a>01047 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01048"></a>01048 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01049"></a>01049 
<a name="l01050"></a>01050   cppvar = GetHeaderGuardCPPVariable(filename)
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   ifndef = <span class="keywordtype">None</span>
<a name="l01053"></a>01053   ifndef_linenum = 0
<a name="l01054"></a>01054   define = <span class="keywordtype">None</span>
<a name="l01055"></a>01055   endif = <span class="keywordtype">None</span>
<a name="l01056"></a>01056   endif_linenum = 0
<a name="l01057"></a>01057   <span class="keywordflow">for</span> linenum, line <span class="keywordflow">in</span> enumerate(lines):
<a name="l01058"></a>01058     linesplit = line.split()
<a name="l01059"></a>01059     <span class="keywordflow">if</span> len(linesplit) &gt;= 2:
<a name="l01060"></a>01060       <span class="comment"># find the first occurrence of #ifndef and #define, save arg</span>
<a name="l01061"></a>01061       <span class="keywordflow">if</span> <span class="keywordflow">not</span> ifndef <span class="keywordflow">and</span> linesplit[0] == <span class="stringliteral">&#39;#ifndef&#39;</span>:
<a name="l01062"></a>01062         <span class="comment"># set ifndef to the header guard presented on the #ifndef line.</span>
<a name="l01063"></a>01063         ifndef = linesplit[1]
<a name="l01064"></a>01064         ifndef_linenum = linenum
<a name="l01065"></a>01065       <span class="keywordflow">if</span> <span class="keywordflow">not</span> define <span class="keywordflow">and</span> linesplit[0] == <span class="stringliteral">&#39;#define&#39;</span>:
<a name="l01066"></a>01066         define = linesplit[1]
<a name="l01067"></a>01067     <span class="comment"># find the last occurrence of #endif, save entire line</span>
<a name="l01068"></a>01068     <span class="keywordflow">if</span> line.startswith(<span class="stringliteral">&#39;#endif&#39;</span>):
<a name="l01069"></a>01069       endif = line
<a name="l01070"></a>01070       endif_linenum = linenum
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="keywordflow">if</span> <span class="keywordflow">not</span> ifndef <span class="keywordflow">or</span> <span class="keywordflow">not</span> define <span class="keywordflow">or</span> ifndef != define:
<a name="l01073"></a>01073     error(filename, 0, <span class="stringliteral">&#39;build/header_guard&#39;</span>, 5,
<a name="l01074"></a>01074           <span class="stringliteral">&#39;No #ifndef header guard found, suggested CPP variable is: %s&#39;</span> %
<a name="l01075"></a>01075           cppvar)
<a name="l01076"></a>01076     <span class="keywordflow">return</span>
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   <span class="comment"># The guard should be PATH_FILE_H_, but we also allow PATH_FILE_H__</span>
<a name="l01079"></a>01079   <span class="comment"># for backward compatibility.</span>
<a name="l01080"></a>01080   <span class="keywordflow">if</span> ifndef != cppvar:
<a name="l01081"></a>01081     error_level = 0
<a name="l01082"></a>01082     <span class="keywordflow">if</span> ifndef != cppvar + <span class="stringliteral">&#39;_&#39;</span>:
<a name="l01083"></a>01083       error_level = 5
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     ParseNolintSuppressions(filename, lines[ifndef_linenum], ifndef_linenum,
<a name="l01086"></a>01086                             error)
<a name="l01087"></a>01087     error(filename, ifndef_linenum, <span class="stringliteral">&#39;build/header_guard&#39;</span>, error_level,
<a name="l01088"></a>01088           <span class="stringliteral">&#39;#ifndef header guard has wrong style, please use: %s&#39;</span> % cppvar)
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   <span class="keywordflow">if</span> endif != (<span class="stringliteral">&#39;#endif  // %s&#39;</span> % cppvar):
<a name="l01091"></a>01091     error_level = 0
<a name="l01092"></a>01092     <span class="keywordflow">if</span> endif != (<span class="stringliteral">&#39;#endif  // %s&#39;</span> % (cppvar + <span class="stringliteral">&#39;_&#39;</span>)):
<a name="l01093"></a>01093       error_level = 5
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     ParseNolintSuppressions(filename, lines[endif_linenum], endif_linenum,
<a name="l01096"></a>01096                             error)
<a name="l01097"></a>01097     error(filename, endif_linenum, <span class="stringliteral">&#39;build/header_guard&#39;</span>, error_level,
<a name="l01098"></a>01098           <span class="stringliteral">&#39;#endif line should be &quot;#endif  // %s&quot;&#39;</span> % cppvar)
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 
<a name="l01101"></a><a class="code" href="namespacecpplint.html#a04dd8f7483533a2ec7df687c180e9d22">01101</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#a04dd8f7483533a2ec7df687c180e9d22">CheckForUnicodeReplacementCharacters</a>(filename, lines, error):
<a name="l01102"></a>01102   <span class="stringliteral">&quot;&quot;&quot;Logs an error for each line containing Unicode replacement characters.</span>
<a name="l01103"></a>01103 <span class="stringliteral"></span>
<a name="l01104"></a>01104 <span class="stringliteral">  These indicate that either the file contained invalid UTF-8 (likely)</span>
<a name="l01105"></a>01105 <span class="stringliteral">  or Unicode replacement characters (which it shouldn&#39;t).  Note that</span>
<a name="l01106"></a>01106 <span class="stringliteral">  it&#39;s possible for this to throw off line numbering if the invalid</span>
<a name="l01107"></a>01107 <span class="stringliteral">  UTF-8 occurred adjacent to a newline.</span>
<a name="l01108"></a>01108 <span class="stringliteral"></span>
<a name="l01109"></a>01109 <span class="stringliteral">  Args:</span>
<a name="l01110"></a>01110 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01111"></a>01111 <span class="stringliteral">    lines: An array of strings, each representing a line of the file.</span>
<a name="l01112"></a>01112 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01113"></a>01113 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01114"></a>01114   <span class="keywordflow">for</span> linenum, line <span class="keywordflow">in</span> enumerate(lines):
<a name="l01115"></a>01115     <span class="keywordflow">if</span> <span class="stringliteral">u&#39;\ufffd&#39;</span> <span class="keywordflow">in</span> line:
<a name="l01116"></a>01116       error(filename, linenum, <span class="stringliteral">&#39;readability/utf8&#39;</span>, 5,
<a name="l01117"></a>01117             <span class="stringliteral">&#39;Line contains invalid UTF-8 (or Unicode replacement character).&#39;</span>)
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 
<a name="l01120"></a><a class="code" href="namespacecpplint.html#a84408591ac7ff7e427560a252360070b">01120</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#a84408591ac7ff7e427560a252360070b">CheckForNewlineAtEOF</a>(filename, lines, error):
<a name="l01121"></a>01121   <span class="stringliteral">&quot;&quot;&quot;Logs an error if there is no newline char at the end of the file.</span>
<a name="l01122"></a>01122 <span class="stringliteral"></span>
<a name="l01123"></a>01123 <span class="stringliteral">  Args:</span>
<a name="l01124"></a>01124 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01125"></a>01125 <span class="stringliteral">    lines: An array of strings, each representing a line of the file.</span>
<a name="l01126"></a>01126 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01127"></a>01127 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01128"></a>01128 
<a name="l01129"></a>01129   <span class="comment"># The array lines() was created by adding two newlines to the</span>
<a name="l01130"></a>01130   <span class="comment"># original file (go figure), then splitting on \n.</span>
<a name="l01131"></a>01131   <span class="comment"># To verify that the file ends in \n, we just have to make sure the</span>
<a name="l01132"></a>01132   <span class="comment"># last-but-two element of lines() exists and is empty.</span>
<a name="l01133"></a>01133   <span class="keywordflow">if</span> len(lines) &lt; 3 <span class="keywordflow">or</span> lines[-2]:
<a name="l01134"></a>01134     error(filename, len(lines) - 2, <span class="stringliteral">&#39;whitespace/ending_newline&#39;</span>, 5,
<a name="l01135"></a>01135           <span class="stringliteral">&#39;Could not find a newline character at the end of the file.&#39;</span>)
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 
<a name="l01138"></a><a class="code" href="namespacecpplint.html#ae319b3dce42ad005bcddfd3d4df9656d">01138</a> <span class="keyword">def </span><a class="code" href="namespacecpplint.html#ae319b3dce42ad005bcddfd3d4df9656d">CheckForMultilineCommentsAndStrings</a>(filename, clean_lines, linenum, error):
<a name="l01139"></a>01139   <span class="stringliteral">&quot;&quot;&quot;Logs an error if we see /* ... */ or &quot;...&quot; that extend past one line.</span>
<a name="l01140"></a>01140 <span class="stringliteral"></span>
<a name="l01141"></a>01141 <span class="stringliteral">  /* ... */ comments are legit inside macros, for one line.</span>
<a name="l01142"></a>01142 <span class="stringliteral">  Otherwise, we prefer // comments, so it&#39;s ok to warn about the</span>
<a name="l01143"></a>01143 <span class="stringliteral">  other.  Likewise, it&#39;s ok for strings to extend across multiple</span>
<a name="l01144"></a>01144 <span class="stringliteral">  lines, as long as a line continuation character (backslash)</span>
<a name="l01145"></a>01145 <span class="stringliteral">  terminates each line. Although not currently prohibited by the C++</span>
<a name="l01146"></a>01146 <span class="stringliteral">  style guide, it&#39;s ugly and unnecessary. We don&#39;t do well with either</span>
<a name="l01147"></a>01147 <span class="stringliteral">  in this lint program, so we warn about both.</span>
<a name="l01148"></a>01148 <span class="stringliteral"></span>
<a name="l01149"></a>01149 <span class="stringliteral">  Args:</span>
<a name="l01150"></a>01150 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01151"></a>01151 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01152"></a>01152 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01153"></a>01153 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01154"></a>01154 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01155"></a>01155   line = clean_lines.elided[linenum]
<a name="l01156"></a>01156 
<a name="l01157"></a>01157   <span class="comment"># Remove all \\ (escaped backslashes) from the line. They are OK, and the</span>
<a name="l01158"></a>01158   <span class="comment"># second (escaped) slash may trigger later \&quot; detection erroneously.</span>
<a name="l01159"></a>01159   line = line.replace(<span class="stringliteral">&#39;\\\\&#39;</span>, <span class="stringliteral">&#39;&#39;</span>)
<a name="l01160"></a>01160 
<a name="l01161"></a>01161   <span class="keywordflow">if</span> line.count(<span class="stringliteral">&#39;/*&#39;</span>) &gt; line.count(<span class="stringliteral">&#39;*/&#39;</span>):
<a name="l01162"></a>01162     error(filename, linenum, <span class="stringliteral">&#39;readability/multiline_comment&#39;</span>, 5,
<a name="l01163"></a>01163           <span class="stringliteral">&#39;Complex multi-line /*...*/-style comment found. &#39;</span>
<a name="l01164"></a>01164           <span class="stringliteral">&#39;Lint may give bogus warnings.  &#39;</span>
<a name="l01165"></a>01165           <span class="stringliteral">&#39;Consider replacing these with //-style comments, &#39;</span>
<a name="l01166"></a>01166           <span class="stringliteral">&#39;with #if 0...#endif, &#39;</span>
<a name="l01167"></a>01167           <span class="stringliteral">&#39;or with more clearly structured multi-line comments.&#39;</span>)
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   <span class="keywordflow">if</span> (line.count(<span class="stringliteral">&#39;&quot;&#39;</span>) - line.count(<span class="stringliteral">&#39;\\&quot;&#39;</span>)) % 2:
<a name="l01170"></a>01170     error(filename, linenum, <span class="stringliteral">&#39;readability/multiline_string&#39;</span>, 5,
<a name="l01171"></a>01171           <span class="stringliteral">&#39;Multi-line string (&quot;...&quot;) found.  This lint script doesn\&#39;t &#39;</span>
<a name="l01172"></a>01172           <span class="stringliteral">&#39;do well with such strings, and may give bogus warnings.  They\&#39;re &#39;</span>
<a name="l01173"></a>01173           <span class="stringliteral">&#39;ugly and unnecessary, and you should use concatenation instead&quot;.&#39;</span>)
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 
<a name="l01176"></a>01176 threading_list = (
<a name="l01177"></a>01177     (<span class="stringliteral">&#39;asctime(&#39;</span>, <span class="stringliteral">&#39;asctime_r(&#39;</span>),
<a name="l01178"></a>01178     (<span class="stringliteral">&#39;ctime(&#39;</span>, <span class="stringliteral">&#39;ctime_r(&#39;</span>),
<a name="l01179"></a>01179     (<span class="stringliteral">&#39;getgrgid(&#39;</span>, <span class="stringliteral">&#39;getgrgid_r(&#39;</span>),
<a name="l01180"></a>01180     (<span class="stringliteral">&#39;getgrnam(&#39;</span>, <span class="stringliteral">&#39;getgrnam_r(&#39;</span>),
<a name="l01181"></a>01181     (<span class="stringliteral">&#39;getlogin(&#39;</span>, <span class="stringliteral">&#39;getlogin_r(&#39;</span>),
<a name="l01182"></a>01182     (<span class="stringliteral">&#39;getpwnam(&#39;</span>, <span class="stringliteral">&#39;getpwnam_r(&#39;</span>),
<a name="l01183"></a>01183     (<span class="stringliteral">&#39;getpwuid(&#39;</span>, <span class="stringliteral">&#39;getpwuid_r(&#39;</span>),
<a name="l01184"></a>01184     (<span class="stringliteral">&#39;gmtime(&#39;</span>, <span class="stringliteral">&#39;gmtime_r(&#39;</span>),
<a name="l01185"></a>01185     (<span class="stringliteral">&#39;localtime(&#39;</span>, <span class="stringliteral">&#39;localtime_r(&#39;</span>),
<a name="l01186"></a>01186     (<span class="stringliteral">&#39;rand(&#39;</span>, <span class="stringliteral">&#39;rand_r(&#39;</span>),
<a name="l01187"></a>01187     (<span class="stringliteral">&#39;readdir(&#39;</span>, <span class="stringliteral">&#39;readdir_r(&#39;</span>),
<a name="l01188"></a>01188     (<span class="stringliteral">&#39;strtok(&#39;</span>, <span class="stringliteral">&#39;strtok_r(&#39;</span>),
<a name="l01189"></a>01189     (<span class="stringliteral">&#39;ttyname(&#39;</span>, <span class="stringliteral">&#39;ttyname_r(&#39;</span>),
<a name="l01190"></a>01190     )
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 
<a name="l01193"></a>01193 <span class="keyword">def </span>CheckPosixThreading(filename, clean_lines, linenum, error):
<a name="l01194"></a>01194   <span class="stringliteral">&quot;&quot;&quot;Checks for calls to thread-unsafe functions.</span>
<a name="l01195"></a>01195 <span class="stringliteral"></span>
<a name="l01196"></a>01196 <span class="stringliteral">  Much code has been originally written without consideration of</span>
<a name="l01197"></a>01197 <span class="stringliteral">  multi-threading. Also, engineers are relying on their old experience;</span>
<a name="l01198"></a>01198 <span class="stringliteral">  they have learned posix before threading extensions were added. These</span>
<a name="l01199"></a>01199 <span class="stringliteral">  tests guide the engineers to use thread-safe functions (when using</span>
<a name="l01200"></a>01200 <span class="stringliteral">  posix directly).</span>
<a name="l01201"></a>01201 <span class="stringliteral"></span>
<a name="l01202"></a>01202 <span class="stringliteral">  Args:</span>
<a name="l01203"></a>01203 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01204"></a>01204 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01205"></a>01205 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01206"></a>01206 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01207"></a>01207 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01208"></a>01208   line = clean_lines.elided[linenum]
<a name="l01209"></a>01209   <span class="keywordflow">for</span> single_thread_function, multithread_safe_function <span class="keywordflow">in</span> threading_list:
<a name="l01210"></a>01210     ix = line.find(single_thread_function)
<a name="l01211"></a>01211     <span class="comment"># Comparisons made explicit for clarity -- pylint: disable-msg=C6403</span>
<a name="l01212"></a>01212     <span class="keywordflow">if</span> ix &gt;= 0 <span class="keywordflow">and</span> (ix == 0 <span class="keywordflow">or</span> (<span class="keywordflow">not</span> line[ix - 1].isalnum() <span class="keywordflow">and</span>
<a name="l01213"></a>01213                                 line[ix - 1] <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;_&#39;</span>, <span class="stringliteral">&#39;.&#39;</span>, <span class="stringliteral">&#39;&gt;&#39;</span>))):
<a name="l01214"></a>01214       error(filename, linenum, <span class="stringliteral">&#39;runtime/threadsafe_fn&#39;</span>, 2,
<a name="l01215"></a>01215             <span class="stringliteral">&#39;Consider using &#39;</span> + multithread_safe_function +
<a name="l01216"></a>01216             <span class="stringliteral">&#39;...) instead of &#39;</span> + single_thread_function +
<a name="l01217"></a>01217             <span class="stringliteral">&#39;...) for improved thread safety.&#39;</span>)
<a name="l01218"></a>01218 
<a name="l01219"></a>01219 
<a name="l01220"></a>01220 <span class="comment"># Matches invalid increment: *count++, which moves pointer instead of</span>
<a name="l01221"></a>01221 <span class="comment"># incrementing a value.</span>
<a name="l01222"></a>01222 _RE_PATTERN_INVALID_INCREMENT = re.compile(
<a name="l01223"></a>01223     <span class="stringliteral">r&#39;^\s*\*\w+(\+\+|--);&#39;</span>)
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="keyword">def </span>CheckInvalidIncrement(filename, clean_lines, linenum, error):
<a name="l01227"></a>01227   <span class="stringliteral">&quot;&quot;&quot;Checks for invalid increment *count++.</span>
<a name="l01228"></a>01228 <span class="stringliteral"></span>
<a name="l01229"></a>01229 <span class="stringliteral">  For example following function:</span>
<a name="l01230"></a>01230 <span class="stringliteral">  void increment_counter(int* count) {</span>
<a name="l01231"></a>01231 <span class="stringliteral">    *count++;</span>
<a name="l01232"></a>01232 <span class="stringliteral">  }</span>
<a name="l01233"></a>01233 <span class="stringliteral">  is invalid, because it effectively does count++, moving pointer, and should</span>
<a name="l01234"></a>01234 <span class="stringliteral">  be replaced with ++*count, (*count)++ or *count += 1.</span>
<a name="l01235"></a>01235 <span class="stringliteral"></span>
<a name="l01236"></a>01236 <span class="stringliteral">  Args:</span>
<a name="l01237"></a>01237 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01238"></a>01238 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01239"></a>01239 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01240"></a>01240 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01241"></a>01241 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01242"></a>01242   line = clean_lines.elided[linenum]
<a name="l01243"></a>01243   <span class="keywordflow">if</span> _RE_PATTERN_INVALID_INCREMENT.match(line):
<a name="l01244"></a>01244     error(filename, linenum, <span class="stringliteral">&#39;runtime/invalid_increment&#39;</span>, 5,
<a name="l01245"></a>01245           <span class="stringliteral">&#39;Changing pointer instead of value (or unused value of operator*).&#39;</span>)
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 <span class="keyword">class </span>_ClassInfo(object):
<a name="l01249"></a>01249   <span class="stringliteral">&quot;&quot;&quot;Stores information about a class.&quot;&quot;&quot;</span>
<a name="l01250"></a>01250 
<a name="l01251"></a>01251   <span class="keyword">def </span>__init__(self, name, linenum):
<a name="l01252"></a>01252     self.name = name
<a name="l01253"></a>01253     self.linenum = linenum
<a name="l01254"></a>01254     self.seen_open_brace = <span class="keyword">False</span>
<a name="l01255"></a>01255     self.is_derived = <span class="keyword">False</span>
<a name="l01256"></a>01256     self.virtual_method_linenumber = <span class="keywordtype">None</span>
<a name="l01257"></a>01257     self.has_virtual_destructor = <span class="keyword">False</span>
<a name="l01258"></a>01258     self.brace_depth = 0
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 
<a name="l01261"></a>01261 <span class="keyword">class </span>_ClassState(object):
<a name="l01262"></a>01262   <span class="stringliteral">&quot;&quot;&quot;Holds the current state of the parse relating to class declarations.</span>
<a name="l01263"></a>01263 <span class="stringliteral"></span>
<a name="l01264"></a>01264 <span class="stringliteral">  It maintains a stack of _ClassInfos representing the parser&#39;s guess</span>
<a name="l01265"></a>01265 <span class="stringliteral">  as to the current nesting of class declarations. The innermost class</span>
<a name="l01266"></a>01266 <span class="stringliteral">  is at the top (back) of the stack. Typically, the stack will either</span>
<a name="l01267"></a>01267 <span class="stringliteral">  be empty or have exactly one entry.</span>
<a name="l01268"></a>01268 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   <span class="keyword">def </span>__init__(self):
<a name="l01271"></a>01271     self.classinfo_stack = []
<a name="l01272"></a>01272 
<a name="l01273"></a>01273   <span class="keyword">def </span>CheckFinished(self, filename, error):
<a name="l01274"></a>01274     <span class="stringliteral">&quot;&quot;&quot;Checks that all classes have been completely parsed.</span>
<a name="l01275"></a>01275 <span class="stringliteral"></span>
<a name="l01276"></a>01276 <span class="stringliteral">    Call this when all lines in a file have been processed.</span>
<a name="l01277"></a>01277 <span class="stringliteral">    Args:</span>
<a name="l01278"></a>01278 <span class="stringliteral">      filename: The name of the current file.</span>
<a name="l01279"></a>01279 <span class="stringliteral">      error: The function to call with any errors found.</span>
<a name="l01280"></a>01280 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l01281"></a>01281     <span class="keywordflow">if</span> self.classinfo_stack:
<a name="l01282"></a>01282       <span class="comment"># Note: This test can result in false positives if #ifdef constructs</span>
<a name="l01283"></a>01283       <span class="comment"># get in the way of brace matching. See the testBuildClass test in</span>
<a name="l01284"></a>01284       <span class="comment"># cpplint_unittest.py for an example of this.</span>
<a name="l01285"></a>01285       error(filename, self.classinfo_stack[0].linenum, <span class="stringliteral">&#39;build/class&#39;</span>, 5,
<a name="l01286"></a>01286             <span class="stringliteral">&#39;Failed to find complete declaration of class %s&#39;</span> %
<a name="l01287"></a>01287             self.classinfo_stack[0].name)
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 
<a name="l01290"></a>01290 <span class="keyword">def </span>CheckForNonStandardConstructs(filename, clean_lines, linenum,
<a name="l01291"></a>01291                                   class_state, error):
<a name="l01292"></a>01292   <span class="stringliteral">&quot;&quot;&quot;Logs an error if we see certain non-ANSI constructs ignored by gcc-2.</span>
<a name="l01293"></a>01293 <span class="stringliteral"></span>
<a name="l01294"></a>01294 <span class="stringliteral">  Complain about several constructs which gcc-2 accepts, but which are</span>
<a name="l01295"></a>01295 <span class="stringliteral">  not standard C++.  Warning about these in lint is one way to ease the</span>
<a name="l01296"></a>01296 <span class="stringliteral">  transition to new compilers.</span>
<a name="l01297"></a>01297 <span class="stringliteral">  - put storage class first (e.g. &quot;static const&quot; instead of &quot;const static&quot;).</span>
<a name="l01298"></a>01298 <span class="stringliteral">  - &quot;%lld&quot; instead of %qd&quot; in printf-type functions.</span>
<a name="l01299"></a>01299 <span class="stringliteral">  - &quot;%1$d&quot; is non-standard in printf-type functions.</span>
<a name="l01300"></a>01300 <span class="stringliteral">  - &quot;\%&quot; is an undefined character escape sequence.</span>
<a name="l01301"></a>01301 <span class="stringliteral">  - text after #endif is not allowed.</span>
<a name="l01302"></a>01302 <span class="stringliteral">  - invalid inner-style forward declaration.</span>
<a name="l01303"></a>01303 <span class="stringliteral">  - &gt;? and &lt;? operators, and their &gt;?= and &lt;?= cousins.</span>
<a name="l01304"></a>01304 <span class="stringliteral">  - classes with virtual methods need virtual destructors (compiler warning</span>
<a name="l01305"></a>01305 <span class="stringliteral">    available, but not turned on yet.)</span>
<a name="l01306"></a>01306 <span class="stringliteral"></span>
<a name="l01307"></a>01307 <span class="stringliteral">  Additionally, check for constructor/destructor style violations and reference</span>
<a name="l01308"></a>01308 <span class="stringliteral">  members, as it is very convenient to do so while checking for</span>
<a name="l01309"></a>01309 <span class="stringliteral">  gcc-2 compliance.</span>
<a name="l01310"></a>01310 <span class="stringliteral"></span>
<a name="l01311"></a>01311 <span class="stringliteral">  Args:</span>
<a name="l01312"></a>01312 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01313"></a>01313 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01314"></a>01314 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01315"></a>01315 <span class="stringliteral">    class_state: A _ClassState instance which maintains information about</span>
<a name="l01316"></a>01316 <span class="stringliteral">                 the current stack of nested class declarations being parsed.</span>
<a name="l01317"></a>01317 <span class="stringliteral">    error: A callable to which errors are reported, which takes 4 arguments:</span>
<a name="l01318"></a>01318 <span class="stringliteral">           filename, line number, error level, and message</span>
<a name="l01319"></a>01319 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01320"></a>01320 
<a name="l01321"></a>01321   <span class="comment"># Remove comments from the line, but leave in strings for now.</span>
<a name="l01322"></a>01322   line = clean_lines.lines[linenum]
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;printf\s*\(.*&quot;.*%[-+ ]?\d*q&#39;</span>, line):
<a name="l01325"></a>01325     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf_format&#39;</span>, 3,
<a name="l01326"></a>01326           <span class="stringliteral">&#39;%q in format strings is deprecated.  Use %ll instead.&#39;</span>)
<a name="l01327"></a>01327 
<a name="l01328"></a>01328   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;printf\s*\(.*&quot;.*%\d+\$&#39;</span>, line):
<a name="l01329"></a>01329     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf_format&#39;</span>, 2,
<a name="l01330"></a>01330           <span class="stringliteral">&#39;%N$ formats are unconventional.  Try rewriting to avoid them.&#39;</span>)
<a name="l01331"></a>01331 
<a name="l01332"></a>01332   <span class="comment"># Remove escaped backslashes before looking for undefined escapes.</span>
<a name="l01333"></a>01333   line = line.replace(<span class="stringliteral">&#39;\\\\&#39;</span>, <span class="stringliteral">&#39;&#39;</span>)
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;(&quot;|\&#39;).*\\(%|\[|\(|{)&#39;</span>, line):
<a name="l01336"></a>01336     error(filename, linenum, <span class="stringliteral">&#39;build/printf_format&#39;</span>, 3,
<a name="l01337"></a>01337           <span class="stringliteral">&#39;%, [, (, and { are undefined character escapes.  Unescape them.&#39;</span>)
<a name="l01338"></a>01338 
<a name="l01339"></a>01339   <span class="comment"># For the rest, work with both comments and strings removed.</span>
<a name="l01340"></a>01340   line = clean_lines.elided[linenum]
<a name="l01341"></a>01341 
<a name="l01342"></a>01342   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\b(const|volatile|void|char|short|int|long&#39;</span>
<a name="l01343"></a>01343             <span class="stringliteral">r&#39;|float|double|signed|unsigned&#39;</span>
<a name="l01344"></a>01344             <span class="stringliteral">r&#39;|schar|u?int8|u?int16|u?int32|u?int64)&#39;</span>
<a name="l01345"></a>01345             <span class="stringliteral">r&#39;\s+(auto|register|static|extern|typedef)\b&#39;</span>,
<a name="l01346"></a>01346             line):
<a name="l01347"></a>01347     error(filename, linenum, <span class="stringliteral">&#39;build/storage_class&#39;</span>, 5,
<a name="l01348"></a>01348           <span class="stringliteral">&#39;Storage class (static, extern, typedef, etc) should be first.&#39;</span>)
<a name="l01349"></a>01349 
<a name="l01350"></a>01350   <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*#\s*endif\s*[^/\s]+&#39;</span>, line):
<a name="l01351"></a>01351     error(filename, linenum, <span class="stringliteral">&#39;build/endif_comment&#39;</span>, 5,
<a name="l01352"></a>01352           <span class="stringliteral">&#39;Uncommented text after #endif is non-standard.  Use a comment.&#39;</span>)
<a name="l01353"></a>01353 
<a name="l01354"></a>01354   <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*class\s+(\w+\s*::\s*)+\w+\s*;&#39;</span>, line):
<a name="l01355"></a>01355     error(filename, linenum, <span class="stringliteral">&#39;build/forward_decl&#39;</span>, 5,
<a name="l01356"></a>01356           <span class="stringliteral">&#39;Inner-style forward declarations are invalid.  Remove this line.&#39;</span>)
<a name="l01357"></a>01357 
<a name="l01358"></a>01358   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;(\w+|[+-]?\d+(\.\d*)?)\s*(&lt;|&gt;)\?=?\s*(\w+|[+-]?\d+)(\.\d*)?&#39;</span>,
<a name="l01359"></a>01359             line):
<a name="l01360"></a>01360     error(filename, linenum, <span class="stringliteral">&#39;build/deprecated&#39;</span>, 3,
<a name="l01361"></a>01361           <span class="stringliteral">&#39;&gt;? and &lt;? (max and min) operators are non-standard and deprecated.&#39;</span>)
<a name="l01362"></a>01362 
<a name="l01363"></a>01363   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;^\s*const\s*string\s*&amp;\s*\w+\s*;&#39;</span>, line):
<a name="l01364"></a>01364     <span class="comment"># TODO(unknown): Could it be expanded safely to arbitrary references,</span>
<a name="l01365"></a>01365     <span class="comment"># without triggering too many false positives? The first</span>
<a name="l01366"></a>01366     <span class="comment"># attempt triggered 5 warnings for mostly benign code in the regtest, hence</span>
<a name="l01367"></a>01367     <span class="comment"># the restriction.</span>
<a name="l01368"></a>01368     <span class="comment"># Here&#39;s the original regexp, for the reference:</span>
<a name="l01369"></a>01369     <span class="comment"># type_name = r&#39;\w+((\s*::\s*\w+)|(\s*&lt;\s*\w+?\s*&gt;))?&#39;</span>
<a name="l01370"></a>01370     <span class="comment"># r&#39;\s*const\s*&#39; + type_name + &#39;\s*&amp;\s*\w+\s*;&#39;</span>
<a name="l01371"></a>01371     error(filename, linenum, <span class="stringliteral">&#39;runtime/member_string_references&#39;</span>, 2,
<a name="l01372"></a>01372           <span class="stringliteral">&#39;const string&amp; members are dangerous. It is much better to use &#39;</span>
<a name="l01373"></a>01373           <span class="stringliteral">&#39;alternatives, such as pointers or simple constants.&#39;</span>)
<a name="l01374"></a>01374 
<a name="l01375"></a>01375   <span class="comment"># Track class entry and exit, and attempt to find cases within the</span>
<a name="l01376"></a>01376   <span class="comment"># class declaration that don&#39;t meet the C++ style</span>
<a name="l01377"></a>01377   <span class="comment"># guidelines. Tracking is very dependent on the code matching Google</span>
<a name="l01378"></a>01378   <span class="comment"># style guidelines, but it seems to perform well enough in testing</span>
<a name="l01379"></a>01379   <span class="comment"># to be a worthwhile addition to the checks.</span>
<a name="l01380"></a>01380   classinfo_stack = class_state.classinfo_stack
<a name="l01381"></a>01381   <span class="comment"># Look for a class declaration</span>
<a name="l01382"></a>01382   class_decl_match = Match(
<a name="l01383"></a>01383       <span class="stringliteral">r&#39;\s*(template\s*&lt;[\w\s&lt;&gt;,:]*&gt;\s*)?(class|struct)\s+(\w+(::\w+)*)&#39;</span>, line)
<a name="l01384"></a>01384   <span class="keywordflow">if</span> class_decl_match:
<a name="l01385"></a>01385     classinfo_stack.append(_ClassInfo(class_decl_match.group(3), linenum))
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="comment"># Everything else in this function uses the top of the stack if it&#39;s</span>
<a name="l01388"></a>01388   <span class="comment"># not empty.</span>
<a name="l01389"></a>01389   <span class="keywordflow">if</span> <span class="keywordflow">not</span> classinfo_stack:
<a name="l01390"></a>01390     <span class="keywordflow">return</span>
<a name="l01391"></a>01391 
<a name="l01392"></a>01392   classinfo = classinfo_stack[-1]
<a name="l01393"></a>01393 
<a name="l01394"></a>01394   <span class="comment"># If the opening brace hasn&#39;t been seen look for it and also</span>
<a name="l01395"></a>01395   <span class="comment"># parent class declarations.</span>
<a name="l01396"></a>01396   <span class="keywordflow">if</span> <span class="keywordflow">not</span> classinfo.seen_open_brace:
<a name="l01397"></a>01397     <span class="comment"># If the line has a &#39;;&#39; in it, assume it&#39;s a forward declaration or</span>
<a name="l01398"></a>01398     <span class="comment"># a single-line class declaration, which we won&#39;t process.</span>
<a name="l01399"></a>01399     <span class="keywordflow">if</span> line.find(<span class="stringliteral">&#39;;&#39;</span>) != -1:
<a name="l01400"></a>01400       classinfo_stack.pop()
<a name="l01401"></a>01401       <span class="keywordflow">return</span>
<a name="l01402"></a>01402     classinfo.seen_open_brace = (line.find(<span class="stringliteral">&#39;{&#39;</span>) != -1)
<a name="l01403"></a>01403     <span class="comment"># Look for a bare &#39;:&#39;</span>
<a name="l01404"></a>01404     <span class="keywordflow">if</span> Search(<span class="stringliteral">&#39;(^|[^:]):($|[^:])&#39;</span>, line):
<a name="l01405"></a>01405       classinfo.is_derived = <span class="keyword">True</span>
<a name="l01406"></a>01406     <span class="keywordflow">if</span> <span class="keywordflow">not</span> classinfo.seen_open_brace:
<a name="l01407"></a>01407       <span class="keywordflow">return</span>  <span class="comment"># Everything else in this function is for after open brace</span>
<a name="l01408"></a>01408 
<a name="l01409"></a>01409   <span class="comment"># The class may have been declared with namespace or classname qualifiers.</span>
<a name="l01410"></a>01410   <span class="comment"># The constructor and destructor will not have those qualifiers.</span>
<a name="l01411"></a>01411   base_classname = classinfo.name.split(<span class="stringliteral">&#39;::&#39;</span>)[-1]
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="comment"># Look for single-argument constructors that aren&#39;t marked explicit.</span>
<a name="l01414"></a>01414   <span class="comment"># Technically a valid construct, but against style.</span>
<a name="l01415"></a>01415   args = Match(<span class="stringliteral">r&#39;(?&lt;!explicit)\s+%s\s*\(([^,()]+)\)&#39;</span>
<a name="l01416"></a>01416                % re.escape(base_classname),
<a name="l01417"></a>01417                line)
<a name="l01418"></a>01418   <span class="keywordflow">if</span> (args <span class="keywordflow">and</span>
<a name="l01419"></a>01419       args.group(1) != <span class="stringliteral">&#39;void&#39;</span> <span class="keywordflow">and</span>
<a name="l01420"></a>01420       <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;(const\s+)?%s\s*&amp;&#39;</span> % re.escape(base_classname),
<a name="l01421"></a>01421                 args.group(1).strip())):
<a name="l01422"></a>01422     error(filename, linenum, <span class="stringliteral">&#39;runtime/explicit&#39;</span>, 5,
<a name="l01423"></a>01423           <span class="stringliteral">&#39;Single-argument constructors should be marked explicit.&#39;</span>)
<a name="l01424"></a>01424 
<a name="l01425"></a>01425   <span class="comment"># Look for methods declared virtual.</span>
<a name="l01426"></a>01426   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\bvirtual\b&#39;</span>, line):
<a name="l01427"></a>01427     classinfo.virtual_method_linenumber = linenum
<a name="l01428"></a>01428     <span class="comment"># Only look for a destructor declaration on the same line. It would</span>
<a name="l01429"></a>01429     <span class="comment"># be extremely unlikely for the destructor declaration to occupy</span>
<a name="l01430"></a>01430     <span class="comment"># more than one line.</span>
<a name="l01431"></a>01431     <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;~%s\s*\(&#39;</span> % base_classname, line):
<a name="l01432"></a>01432       classinfo.has_virtual_destructor = <span class="keyword">True</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <span class="comment"># Look for class end.</span>
<a name="l01435"></a>01435   brace_depth = classinfo.brace_depth
<a name="l01436"></a>01436   brace_depth = brace_depth + line.count(<span class="stringliteral">&#39;{&#39;</span>) - line.count(<span class="stringliteral">&#39;}&#39;</span>)
<a name="l01437"></a>01437   <span class="keywordflow">if</span> brace_depth &lt;= 0:
<a name="l01438"></a>01438     classinfo = classinfo_stack.pop()
<a name="l01439"></a>01439     <span class="comment"># Try to detect missing virtual destructor declarations.</span>
<a name="l01440"></a>01440     <span class="comment"># For now, only warn if a non-derived class with virtual methods lacks</span>
<a name="l01441"></a>01441     <span class="comment"># a virtual destructor. This is to make it less likely that people will</span>
<a name="l01442"></a>01442     <span class="comment"># declare derived virtual destructors without declaring the base</span>
<a name="l01443"></a>01443     <span class="comment"># destructor virtual.</span>
<a name="l01444"></a>01444     <span class="keywordflow">if</span> ((classinfo.virtual_method_linenumber <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span>
<a name="l01445"></a>01445         (<span class="keywordflow">not</span> classinfo.has_virtual_destructor) <span class="keywordflow">and</span>
<a name="l01446"></a>01446         (<span class="keywordflow">not</span> classinfo.is_derived)):  <span class="comment"># Only warn for base classes</span>
<a name="l01447"></a>01447       error(filename, classinfo.linenum, <span class="stringliteral">&#39;runtime/virtual&#39;</span>, 4,
<a name="l01448"></a>01448             <span class="stringliteral">&#39;The class %s probably needs a virtual destructor due to &#39;</span>
<a name="l01449"></a>01449             <span class="stringliteral">&#39;having virtual method(s), one declared at line %d.&#39;</span>
<a name="l01450"></a>01450             % (classinfo.name, classinfo.virtual_method_linenumber))
<a name="l01451"></a>01451   <span class="keywordflow">else</span>:
<a name="l01452"></a>01452     classinfo.brace_depth = brace_depth
<a name="l01453"></a>01453 
<a name="l01454"></a>01454 
<a name="l01455"></a>01455 <span class="keyword">def </span>CheckSpacingForFunctionCall(filename, line, linenum, error):
<a name="l01456"></a>01456   <span class="stringliteral">&quot;&quot;&quot;Checks for the correctness of various spacing around function calls.</span>
<a name="l01457"></a>01457 <span class="stringliteral"></span>
<a name="l01458"></a>01458 <span class="stringliteral">  Args:</span>
<a name="l01459"></a>01459 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01460"></a>01460 <span class="stringliteral">    line: The text of the line to check.</span>
<a name="l01461"></a>01461 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01462"></a>01462 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01463"></a>01463 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="comment"># Since function calls often occur inside if/for/while/switch</span>
<a name="l01466"></a>01466   <span class="comment"># expressions - which have their own, more liberal conventions - we</span>
<a name="l01467"></a>01467   <span class="comment"># first see if we should be looking inside such an expression for a</span>
<a name="l01468"></a>01468   <span class="comment"># function call, to which we can apply more strict standards.</span>
<a name="l01469"></a>01469   fncall = line    <span class="comment"># if there&#39;s no control flow construct, look at whole line</span>
<a name="l01470"></a>01470   <span class="keywordflow">for</span> pattern <span class="keywordflow">in</span> (<span class="stringliteral">r&#39;\bif\s*\((.*)\)\s*{&#39;</span>,
<a name="l01471"></a>01471                   <span class="stringliteral">r&#39;\bfor\s*\((.*)\)\s*{&#39;</span>,
<a name="l01472"></a>01472                   <span class="stringliteral">r&#39;\bwhile\s*\((.*)\)\s*[{;]&#39;</span>,
<a name="l01473"></a>01473                   <span class="stringliteral">r&#39;\bswitch\s*\((.*)\)\s*{&#39;</span>):
<a name="l01474"></a>01474     match = Search(pattern, line)
<a name="l01475"></a>01475     <span class="keywordflow">if</span> match:
<a name="l01476"></a>01476       fncall = match.group(1)    <span class="comment"># look inside the parens for function calls</span>
<a name="l01477"></a>01477       <span class="keywordflow">break</span>
<a name="l01478"></a>01478 
<a name="l01479"></a>01479   <span class="comment"># Except in if/for/while/switch, there should never be space</span>
<a name="l01480"></a>01480   <span class="comment"># immediately inside parens (eg &quot;f( 3, 4 )&quot;).  We make an exception</span>
<a name="l01481"></a>01481   <span class="comment"># for nested parens ( (a+b) + c ).  Likewise, there should never be</span>
<a name="l01482"></a>01482   <span class="comment"># a space before a ( when it&#39;s a function argument.  I assume it&#39;s a</span>
<a name="l01483"></a>01483   <span class="comment"># function argument when the char before the whitespace is legal in</span>
<a name="l01484"></a>01484   <span class="comment"># a function name (alnum + _) and we&#39;re not starting a macro. Also ignore</span>
<a name="l01485"></a>01485   <span class="comment"># pointers and references to arrays and functions coz they&#39;re too tricky:</span>
<a name="l01486"></a>01486   <span class="comment"># we use a very simple way to recognize these:</span>
<a name="l01487"></a>01487   <span class="comment"># &quot; (something)(maybe-something)&quot; or</span>
<a name="l01488"></a>01488   <span class="comment"># &quot; (something)(maybe-something,&quot; or</span>
<a name="l01489"></a>01489   <span class="comment"># &quot; (something)[something]&quot;</span>
<a name="l01490"></a>01490   <span class="comment"># Note that we assume the contents of [] to be short enough that</span>
<a name="l01491"></a>01491   <span class="comment"># they&#39;ll never need to wrap.</span>
<a name="l01492"></a>01492   <span class="keywordflow">if</span> (  <span class="comment"># Ignore control structures.</span>
<a name="l01493"></a>01493       <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;\b(if|for|while|switch|return|delete)\b&#39;</span>, fncall) <span class="keywordflow">and</span>
<a name="l01494"></a>01494       <span class="comment"># Ignore pointers/references to functions.</span>
<a name="l01495"></a>01495       <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39; \([^)]+\)\([^)]*(\)|,$)&#39;</span>, fncall) <span class="keywordflow">and</span>
<a name="l01496"></a>01496       <span class="comment"># Ignore pointers/references to arrays.</span>
<a name="l01497"></a>01497       <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39; \([^)]+\)\[[^\]]+\]&#39;</span>, fncall)):
<a name="l01498"></a>01498     <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\w\s*\(\s(?!\s*\\$)&#39;</span>, fncall):      <span class="comment"># a ( used for a fn call</span>
<a name="l01499"></a>01499       error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 4,
<a name="l01500"></a>01500             <span class="stringliteral">&#39;Extra space after ( in function call&#39;</span>)
<a name="l01501"></a>01501     <span class="keywordflow">elif</span> Search(<span class="stringliteral">r&#39;\(\s+(?!(\s*\\)|\()&#39;</span>, fncall):
<a name="l01502"></a>01502       error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 2,
<a name="l01503"></a>01503             <span class="stringliteral">&#39;Extra space after (&#39;</span>)
<a name="l01504"></a>01504     <span class="keywordflow">if</span> (Search(<span class="stringliteral">r&#39;\w\s+\(&#39;</span>, fncall) <span class="keywordflow">and</span>
<a name="l01505"></a>01505         <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;#\s*define|typedef&#39;</span>, fncall)):
<a name="l01506"></a>01506       error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 4,
<a name="l01507"></a>01507             <span class="stringliteral">&#39;Extra space before ( in function call&#39;</span>)
<a name="l01508"></a>01508     <span class="comment"># If the ) is followed only by a newline or a { + newline, assume it&#39;s</span>
<a name="l01509"></a>01509     <span class="comment"># part of a control statement (if/while/etc), and don&#39;t complain</span>
<a name="l01510"></a>01510     <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;[^)]\s+\)\s*[^{\s]&#39;</span>, fncall):
<a name="l01511"></a>01511       error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 2,
<a name="l01512"></a>01512             <span class="stringliteral">&#39;Extra space before )&#39;</span>)
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="keyword">def </span>IsBlankLine(line):
<a name="l01516"></a>01516   <span class="stringliteral">&quot;&quot;&quot;Returns true if the given line is blank.</span>
<a name="l01517"></a>01517 <span class="stringliteral"></span>
<a name="l01518"></a>01518 <span class="stringliteral">  We consider a line to be blank if the line is empty or consists of</span>
<a name="l01519"></a>01519 <span class="stringliteral">  only white spaces.</span>
<a name="l01520"></a>01520 <span class="stringliteral"></span>
<a name="l01521"></a>01521 <span class="stringliteral">  Args:</span>
<a name="l01522"></a>01522 <span class="stringliteral">    line: A line of a string.</span>
<a name="l01523"></a>01523 <span class="stringliteral"></span>
<a name="l01524"></a>01524 <span class="stringliteral">  Returns:</span>
<a name="l01525"></a>01525 <span class="stringliteral">    True, if the given line is blank.</span>
<a name="l01526"></a>01526 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01527"></a>01527   <span class="keywordflow">return</span> <span class="keywordflow">not</span> line <span class="keywordflow">or</span> line.isspace()
<a name="l01528"></a>01528 
<a name="l01529"></a>01529 
<a name="l01530"></a>01530 <span class="keyword">def </span>CheckForFunctionLengths(filename, clean_lines, linenum,
<a name="l01531"></a>01531                             function_state, error):
<a name="l01532"></a>01532   <span class="stringliteral">&quot;&quot;&quot;Reports for long function bodies.</span>
<a name="l01533"></a>01533 <span class="stringliteral"></span>
<a name="l01534"></a>01534 <span class="stringliteral">  For an overview why this is done, see:</span>
<a name="l01535"></a>01535 <span class="stringliteral">  http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Write_Short_Functions</span>
<a name="l01536"></a>01536 <span class="stringliteral"></span>
<a name="l01537"></a>01537 <span class="stringliteral">  Uses a simplistic algorithm assuming other style guidelines</span>
<a name="l01538"></a>01538 <span class="stringliteral">  (especially spacing) are followed.</span>
<a name="l01539"></a>01539 <span class="stringliteral">  Only checks unindented functions, so class members are unchecked.</span>
<a name="l01540"></a>01540 <span class="stringliteral">  Trivial bodies are unchecked, so constructors with huge initializer lists</span>
<a name="l01541"></a>01541 <span class="stringliteral">  may be missed.</span>
<a name="l01542"></a>01542 <span class="stringliteral">  Blank/comment lines are not counted so as to avoid encouraging the removal</span>
<a name="l01543"></a>01543 <span class="stringliteral">  of vertical space and commments just to get through a lint check.</span>
<a name="l01544"></a>01544 <span class="stringliteral">  NOLINT *on the last line of a function* disables this check.</span>
<a name="l01545"></a>01545 <span class="stringliteral"></span>
<a name="l01546"></a>01546 <span class="stringliteral">  Args:</span>
<a name="l01547"></a>01547 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01548"></a>01548 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01549"></a>01549 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01550"></a>01550 <span class="stringliteral">    function_state: Current function name and lines in body so far.</span>
<a name="l01551"></a>01551 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01552"></a>01552 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01553"></a>01553   lines = clean_lines.lines
<a name="l01554"></a>01554   line = lines[linenum]
<a name="l01555"></a>01555   raw = clean_lines.raw_lines
<a name="l01556"></a>01556   raw_line = raw[linenum]
<a name="l01557"></a>01557   joined_line = <span class="stringliteral">&#39;&#39;</span>
<a name="l01558"></a>01558 
<a name="l01559"></a>01559   starting_func = <span class="keyword">False</span>
<a name="l01560"></a>01560   regexp = <span class="stringliteral">r&#39;(\w(\w|::|\*|\&amp;|\s)*)\(&#39;</span>  <span class="comment"># decls * &amp; space::name( ...</span>
<a name="l01561"></a>01561   match_result = Match(regexp, line)
<a name="l01562"></a>01562   <span class="keywordflow">if</span> match_result:
<a name="l01563"></a>01563     <span class="comment"># If the name is all caps and underscores, figure it&#39;s a macro and</span>
<a name="l01564"></a>01564     <span class="comment"># ignore it, unless it&#39;s TEST or TEST_F.</span>
<a name="l01565"></a>01565     function_name = match_result.group(1).split()[-1]
<a name="l01566"></a>01566     <span class="keywordflow">if</span> function_name == <span class="stringliteral">&#39;TEST&#39;</span> <span class="keywordflow">or</span> function_name == <span class="stringliteral">&#39;TEST_F&#39;</span> <span class="keywordflow">or</span> (
<a name="l01567"></a>01567         <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;[A-Z_]+$&#39;</span>, function_name)):
<a name="l01568"></a>01568       starting_func = <span class="keyword">True</span>
<a name="l01569"></a>01569 
<a name="l01570"></a>01570   <span class="keywordflow">if</span> starting_func:
<a name="l01571"></a>01571     body_found = <span class="keyword">False</span>
<a name="l01572"></a>01572     <span class="keywordflow">for</span> start_linenum <span class="keywordflow">in</span> xrange(linenum, clean_lines.NumLines()):
<a name="l01573"></a>01573       start_line = lines[start_linenum]
<a name="l01574"></a>01574       joined_line += <span class="stringliteral">&#39; &#39;</span> + start_line.lstrip()
<a name="l01575"></a>01575       <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;(;|})&#39;</span>, start_line):  <span class="comment"># Declarations and trivial functions</span>
<a name="l01576"></a>01576         body_found = <span class="keyword">True</span>
<a name="l01577"></a>01577         <span class="keywordflow">break</span>                              <span class="comment"># ... ignore</span>
<a name="l01578"></a>01578       <span class="keywordflow">elif</span> Search(<span class="stringliteral">r&#39;{&#39;</span>, start_line):
<a name="l01579"></a>01579         body_found = <span class="keyword">True</span>
<a name="l01580"></a>01580         function = Search(<span class="stringliteral">r&#39;((\w|:)*)\(&#39;</span>, line).group(1)
<a name="l01581"></a>01581         <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;TEST&#39;</span>, function):    <span class="comment"># Handle TEST... macros</span>
<a name="l01582"></a>01582           parameter_regexp = Search(<span class="stringliteral">r&#39;(\(.*\))&#39;</span>, joined_line)
<a name="l01583"></a>01583           <span class="keywordflow">if</span> parameter_regexp:             <span class="comment"># Ignore bad syntax</span>
<a name="l01584"></a>01584             function += parameter_regexp.group(1)
<a name="l01585"></a>01585         <span class="keywordflow">else</span>:
<a name="l01586"></a>01586           function += <span class="stringliteral">&#39;()&#39;</span>
<a name="l01587"></a>01587         function_state.Begin(function)
<a name="l01588"></a>01588         <span class="keywordflow">break</span>
<a name="l01589"></a>01589     <span class="keywordflow">if</span> <span class="keywordflow">not</span> body_found:
<a name="l01590"></a>01590       <span class="comment"># No body for the function (or evidence of a non-function) was found.</span>
<a name="l01591"></a>01591       error(filename, linenum, <span class="stringliteral">&#39;readability/fn_size&#39;</span>, 5,
<a name="l01592"></a>01592             <span class="stringliteral">&#39;Lint failed to find start of function body.&#39;</span>)
<a name="l01593"></a>01593   <span class="keywordflow">elif</span> Match(<span class="stringliteral">r&#39;^\}\s*$&#39;</span>, line):  <span class="comment"># function end</span>
<a name="l01594"></a>01594     function_state.Check(error, filename, linenum)
<a name="l01595"></a>01595     function_state.End()
<a name="l01596"></a>01596   <span class="keywordflow">elif</span> <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;^\s*$&#39;</span>, line):
<a name="l01597"></a>01597     function_state.Count()  <span class="comment"># Count non-blank/non-comment lines.</span>
<a name="l01598"></a>01598 
<a name="l01599"></a>01599 
<a name="l01600"></a>01600 _RE_PATTERN_TODO = re.compile(<span class="stringliteral">r&#39;^//(\s*)TODO(\(.+?\))?:?(\s|$)?&#39;</span>)
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 <span class="keyword">def </span>CheckComment(comment, filename, linenum, error):
<a name="l01604"></a>01604   <span class="stringliteral">&quot;&quot;&quot;Checks for common mistakes in TODO comments.</span>
<a name="l01605"></a>01605 <span class="stringliteral"></span>
<a name="l01606"></a>01606 <span class="stringliteral">  Args:</span>
<a name="l01607"></a>01607 <span class="stringliteral">    comment: The text of the comment from the line in question.</span>
<a name="l01608"></a>01608 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01609"></a>01609 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01610"></a>01610 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01611"></a>01611 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01612"></a>01612   match = _RE_PATTERN_TODO.match(comment)
<a name="l01613"></a>01613   <span class="keywordflow">if</span> match:
<a name="l01614"></a>01614     <span class="comment"># One whitespace is correct; zero whitespace is handled elsewhere.</span>
<a name="l01615"></a>01615     leading_whitespace = match.group(1)
<a name="l01616"></a>01616     <span class="keywordflow">if</span> len(leading_whitespace) &gt; 1:
<a name="l01617"></a>01617       error(filename, linenum, <span class="stringliteral">&#39;whitespace/todo&#39;</span>, 2,
<a name="l01618"></a>01618             <span class="stringliteral">&#39;Too many spaces before TODO&#39;</span>)
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     username = match.group(2)
<a name="l01621"></a>01621     <span class="keywordflow">if</span> <span class="keywordflow">not</span> username:
<a name="l01622"></a>01622       error(filename, linenum, <span class="stringliteral">&#39;readability/todo&#39;</span>, 2,
<a name="l01623"></a>01623             <span class="stringliteral">&#39;Missing username in TODO; it should look like &#39;</span>
<a name="l01624"></a>01624             <span class="stringliteral">&#39;&quot;// TODO(my_username): Stuff.&quot;&#39;</span>)
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     middle_whitespace = match.group(3)
<a name="l01627"></a>01627     <span class="comment"># Comparisons made explicit for correctness -- pylint: disable-msg=C6403</span>
<a name="l01628"></a>01628     <span class="keywordflow">if</span> middle_whitespace != <span class="stringliteral">&#39; &#39;</span> <span class="keywordflow">and</span> middle_whitespace != <span class="stringliteral">&#39;&#39;</span>:
<a name="l01629"></a>01629       error(filename, linenum, <span class="stringliteral">&#39;whitespace/todo&#39;</span>, 2,
<a name="l01630"></a>01630             <span class="stringliteral">&#39;TODO(my_username) should be followed by a space&#39;</span>)
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 
<a name="l01633"></a>01633 <span class="keyword">def </span>CheckSpacing(filename, clean_lines, linenum, error):
<a name="l01634"></a>01634   <span class="stringliteral">&quot;&quot;&quot;Checks for the correctness of various spacing issues in the code.</span>
<a name="l01635"></a>01635 <span class="stringliteral"></span>
<a name="l01636"></a>01636 <span class="stringliteral">  Things we check for: spaces around operators, spaces after</span>
<a name="l01637"></a>01637 <span class="stringliteral">  if/for/while/switch, no spaces around parens in function calls, two</span>
<a name="l01638"></a>01638 <span class="stringliteral">  spaces between code and comment, don&#39;t start a block with a blank</span>
<a name="l01639"></a>01639 <span class="stringliteral">  line, don&#39;t end a function with a blank line, don&#39;t have too many</span>
<a name="l01640"></a>01640 <span class="stringliteral">  blank lines in a row.</span>
<a name="l01641"></a>01641 <span class="stringliteral"></span>
<a name="l01642"></a>01642 <span class="stringliteral">  Args:</span>
<a name="l01643"></a>01643 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01644"></a>01644 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01645"></a>01645 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01646"></a>01646 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01647"></a>01647 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01648"></a>01648 
<a name="l01649"></a>01649   raw = clean_lines.raw_lines
<a name="l01650"></a>01650   line = raw[linenum]
<a name="l01651"></a>01651 
<a name="l01652"></a>01652   <span class="comment"># Before nixing comments, check if the line is blank for no good</span>
<a name="l01653"></a>01653   <span class="comment"># reason.  This includes the first line after a block is opened, and</span>
<a name="l01654"></a>01654   <span class="comment"># blank lines at the end of a function (ie, right before a line like &#39;}&#39;</span>
<a name="l01655"></a>01655   <span class="keywordflow">if</span> IsBlankLine(line):
<a name="l01656"></a>01656     elided = clean_lines.elided
<a name="l01657"></a>01657     prev_line = elided[linenum - 1]
<a name="l01658"></a>01658     prevbrace = prev_line.rfind(<span class="stringliteral">&#39;{&#39;</span>)
<a name="l01659"></a>01659     <span class="comment"># TODO(unknown): Don&#39;t complain if line before blank line, and line after,</span>
<a name="l01660"></a>01660     <span class="comment">#                both start with alnums and are indented the same amount.</span>
<a name="l01661"></a>01661     <span class="comment">#                This ignores whitespace at the start of a namespace block</span>
<a name="l01662"></a>01662     <span class="comment">#                because those are not usually indented.</span>
<a name="l01663"></a>01663     <span class="keywordflow">if</span> (prevbrace != -1 <span class="keywordflow">and</span> prev_line[prevbrace:].find(<span class="stringliteral">&#39;}&#39;</span>) == -1
<a name="l01664"></a>01664         <span class="keywordflow">and</span> prev_line[:prevbrace].find(<span class="stringliteral">&#39;namespace&#39;</span>) == -1):
<a name="l01665"></a>01665       <span class="comment"># OK, we have a blank line at the start of a code block.  Before we</span>
<a name="l01666"></a>01666       <span class="comment"># complain, we check if it is an exception to the rule: The previous</span>
<a name="l01667"></a>01667       <span class="comment"># non-empty line has the paramters of a function header that are indented</span>
<a name="l01668"></a>01668       <span class="comment"># 4 spaces (because they did not fit in a 80 column line when placed on</span>
<a name="l01669"></a>01669       <span class="comment"># the same line as the function name).  We also check for the case where</span>
<a name="l01670"></a>01670       <span class="comment"># the previous line is indented 6 spaces, which may happen when the</span>
<a name="l01671"></a>01671       <span class="comment"># initializers of a constructor do not fit into a 80 column line.</span>
<a name="l01672"></a>01672       exception = <span class="keyword">False</span>
<a name="l01673"></a>01673       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39; {6}\w&#39;</span>, prev_line):  <span class="comment"># Initializer list?</span>
<a name="l01674"></a>01674         <span class="comment"># We are looking for the opening column of initializer list, which</span>
<a name="l01675"></a>01675         <span class="comment"># should be indented 4 spaces to cause 6 space indentation afterwards.</span>
<a name="l01676"></a>01676         search_position = linenum-2
<a name="l01677"></a>01677         <span class="keywordflow">while</span> (search_position &gt;= 0
<a name="l01678"></a>01678                <span class="keywordflow">and</span> Match(<span class="stringliteral">r&#39; {6}\w&#39;</span>, elided[search_position])):
<a name="l01679"></a>01679           search_position -= 1
<a name="l01680"></a>01680         exception = (search_position &gt;= 0
<a name="l01681"></a>01681                      <span class="keywordflow">and</span> elided[search_position][:5] == <span class="stringliteral">&#39;    :&#39;</span>)
<a name="l01682"></a>01682       <span class="keywordflow">else</span>:
<a name="l01683"></a>01683         <span class="comment"># Search for the function arguments or an initializer list.  We use a</span>
<a name="l01684"></a>01684         <span class="comment"># simple heuristic here: If the line is indented 4 spaces; and we have a</span>
<a name="l01685"></a>01685         <span class="comment"># closing paren, without the opening paren, followed by an opening brace</span>
<a name="l01686"></a>01686         <span class="comment"># or colon (for initializer lists) we assume that it is the last line of</span>
<a name="l01687"></a>01687         <span class="comment"># a function header.  If we have a colon indented 4 spaces, it is an</span>
<a name="l01688"></a>01688         <span class="comment"># initializer list.</span>
<a name="l01689"></a>01689         exception = (Match(<span class="stringliteral">r&#39; {4}\w[^\(]*\)\s*(const\s*)?(\{\s*$|:)&#39;</span>,
<a name="l01690"></a>01690                            prev_line)
<a name="l01691"></a>01691                      <span class="keywordflow">or</span> Match(<span class="stringliteral">r&#39; {4}:&#39;</span>, prev_line))
<a name="l01692"></a>01692 
<a name="l01693"></a>01693       <span class="keywordflow">if</span> <span class="keywordflow">not</span> exception:
<a name="l01694"></a>01694         error(filename, linenum, <span class="stringliteral">&#39;whitespace/blank_line&#39;</span>, 2,
<a name="l01695"></a>01695               <span class="stringliteral">&#39;Blank line at the start of a code block.  Is this needed?&#39;</span>)
<a name="l01696"></a>01696     <span class="comment"># This doesn&#39;t ignore whitespace at the end of a namespace block</span>
<a name="l01697"></a>01697     <span class="comment"># because that is too hard without pairing open/close braces;</span>
<a name="l01698"></a>01698     <span class="comment"># however, a special exception is made for namespace closing</span>
<a name="l01699"></a>01699     <span class="comment"># brackets which have a comment containing &quot;namespace&quot;.</span>
<a name="l01700"></a>01700     <span class="comment">#</span>
<a name="l01701"></a>01701     <span class="comment"># Also, ignore blank lines at the end of a block in a long if-else</span>
<a name="l01702"></a>01702     <span class="comment"># chain, like this:</span>
<a name="l01703"></a>01703     <span class="comment">#   if (condition1) {</span>
<a name="l01704"></a>01704     <span class="comment">#     // Something followed by a blank line</span>
<a name="l01705"></a>01705     <span class="comment">#</span>
<a name="l01706"></a>01706     <span class="comment">#   } else if (condition2) {</span>
<a name="l01707"></a>01707     <span class="comment">#     // Something else</span>
<a name="l01708"></a>01708     <span class="comment">#   }</span>
<a name="l01709"></a>01709     <span class="keywordflow">if</span> linenum + 1 &lt; clean_lines.NumLines():
<a name="l01710"></a>01710       next_line = raw[linenum + 1]
<a name="l01711"></a>01711       <span class="keywordflow">if</span> (next_line
<a name="l01712"></a>01712           <span class="keywordflow">and</span> Match(<span class="stringliteral">r&#39;\s*}&#39;</span>, next_line)
<a name="l01713"></a>01713           <span class="keywordflow">and</span> next_line.find(<span class="stringliteral">&#39;namespace&#39;</span>) == -1
<a name="l01714"></a>01714           <span class="keywordflow">and</span> next_line.find(<span class="stringliteral">&#39;} else &#39;</span>) == -1):
<a name="l01715"></a>01715         error(filename, linenum, <span class="stringliteral">&#39;whitespace/blank_line&#39;</span>, 3,
<a name="l01716"></a>01716               <span class="stringliteral">&#39;Blank line at the end of a code block.  Is this needed?&#39;</span>)
<a name="l01717"></a>01717 
<a name="l01718"></a>01718   <span class="comment"># Next, we complain if there&#39;s a comment too near the text</span>
<a name="l01719"></a>01719   commentpos = line.find(<span class="stringliteral">&#39;//&#39;</span>)
<a name="l01720"></a>01720   <span class="keywordflow">if</span> commentpos != -1:
<a name="l01721"></a>01721     <span class="comment"># Check if the // may be in quotes.  If so, ignore it</span>
<a name="l01722"></a>01722     <span class="comment"># Comparisons made explicit for clarity -- pylint: disable-msg=C6403</span>
<a name="l01723"></a>01723     <span class="keywordflow">if</span> (line.count(<span class="stringliteral">&#39;&quot;&#39;</span>, 0, commentpos) -
<a name="l01724"></a>01724         line.count(<span class="stringliteral">&#39;\\&quot;&#39;</span>, 0, commentpos)) % 2 == 0:   <span class="comment"># not in quotes</span>
<a name="l01725"></a>01725       <span class="comment"># Allow one space for new scopes, two spaces otherwise:</span>
<a name="l01726"></a>01726       <span class="keywordflow">if</span> (<span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;^\s*{ //&#39;</span>, line) <span class="keywordflow">and</span>
<a name="l01727"></a>01727           ((commentpos &gt;= 1 <span class="keywordflow">and</span>
<a name="l01728"></a>01728             line[commentpos-1] <span class="keywordflow">not</span> <span class="keywordflow">in</span> string.whitespace) <span class="keywordflow">or</span>
<a name="l01729"></a>01729            (commentpos &gt;= 2 <span class="keywordflow">and</span>
<a name="l01730"></a>01730             line[commentpos-2] <span class="keywordflow">not</span> <span class="keywordflow">in</span> string.whitespace))):
<a name="l01731"></a>01731         error(filename, linenum, <span class="stringliteral">&#39;whitespace/comments&#39;</span>, 2,
<a name="l01732"></a>01732               <span class="stringliteral">&#39;At least two spaces is best between code and comments&#39;</span>)
<a name="l01733"></a>01733       <span class="comment"># There should always be a space between the // and the comment</span>
<a name="l01734"></a>01734       commentend = commentpos + 2
<a name="l01735"></a>01735       <span class="keywordflow">if</span> commentend &lt; len(line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> line[commentend] == <span class="stringliteral">&#39; &#39;</span>:
<a name="l01736"></a>01736         <span class="comment"># but some lines are exceptions -- e.g. if they&#39;re big</span>
<a name="l01737"></a>01737         <span class="comment"># comment delimiters like:</span>
<a name="l01738"></a>01738         <span class="comment"># //----------------------------------------------------------</span>
<a name="l01739"></a>01739         <span class="comment"># or they begin with multiple slashes followed by a space:</span>
<a name="l01740"></a>01740         <span class="comment"># //////// Header comment</span>
<a name="l01741"></a>01741         match = (Search(<span class="stringliteral">r&#39;[=/-]{4,}\s*$&#39;</span>, line[commentend:]) <span class="keywordflow">or</span>
<a name="l01742"></a>01742                  Search(<span class="stringliteral">r&#39;^/+ &#39;</span>, line[commentend:]))
<a name="l01743"></a>01743         <span class="keywordflow">if</span> <span class="keywordflow">not</span> match:
<a name="l01744"></a>01744           error(filename, linenum, <span class="stringliteral">&#39;whitespace/comments&#39;</span>, 4,
<a name="l01745"></a>01745                 <span class="stringliteral">&#39;Should have a space between // and comment&#39;</span>)
<a name="l01746"></a>01746       CheckComment(line[commentpos:], filename, linenum, error)
<a name="l01747"></a>01747 
<a name="l01748"></a>01748   line = clean_lines.elided[linenum]  <span class="comment"># get rid of comments and strings</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750   <span class="comment"># Don&#39;t try to do spacing checks for operator methods</span>
<a name="l01751"></a>01751   line = re.sub(<span class="stringliteral">r&#39;operator(==|!=|&lt;|&lt;&lt;|&lt;=|&gt;=|&gt;&gt;|&gt;)\(&#39;</span>, <span class="stringliteral">&#39;operator\(&#39;</span>, line)
<a name="l01752"></a>01752 
<a name="l01753"></a>01753   <span class="comment"># We allow no-spaces around = within an if: &quot;if ( (a=Foo()) == 0 )&quot;.</span>
<a name="l01754"></a>01754   <span class="comment"># Otherwise not.  Note we only check for non-spaces on *both* sides;</span>
<a name="l01755"></a>01755   <span class="comment"># sometimes people put non-spaces on one side when aligning =&#39;s among</span>
<a name="l01756"></a>01756   <span class="comment"># many lines (not that this is behavior that I approve of...)</span>
<a name="l01757"></a>01757   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;[\w.]=[\w.]&#39;</span>, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;\b(if|while) &#39;</span>, line):
<a name="l01758"></a>01758     error(filename, linenum, <span class="stringliteral">&#39;whitespace/operators&#39;</span>, 4,
<a name="l01759"></a>01759           <span class="stringliteral">&#39;Missing spaces around =&#39;</span>)
<a name="l01760"></a>01760 
<a name="l01761"></a>01761   <span class="comment"># It&#39;s ok not to have spaces around binary operators like + - * /, but if</span>
<a name="l01762"></a>01762   <span class="comment"># there&#39;s too little whitespace, we get concerned.  It&#39;s hard to tell,</span>
<a name="l01763"></a>01763   <span class="comment"># though, so we punt on this one for now.  TODO.</span>
<a name="l01764"></a>01764 
<a name="l01765"></a>01765   <span class="comment"># You should always have whitespace around binary operators.</span>
<a name="l01766"></a>01766   <span class="comment"># Alas, we can&#39;t test &lt; or &gt; because they&#39;re legitimately used sans spaces</span>
<a name="l01767"></a>01767   <span class="comment"># (a-&gt;b, vector&lt;int&gt; a).  The only time we can tell is a &lt; with no &gt;, and</span>
<a name="l01768"></a>01768   <span class="comment"># only if it&#39;s not template params list spilling into the next line.</span>
<a name="l01769"></a>01769   match = Search(<span class="stringliteral">r&#39;[^&lt;&gt;=!\s](==|!=|&lt;=|&gt;=)[^&lt;&gt;=!\s]&#39;</span>, line)
<a name="l01770"></a>01770   <span class="keywordflow">if</span> <span class="keywordflow">not</span> match:
<a name="l01771"></a>01771     <span class="comment"># Note that while it seems that the &#39;&lt;[^&lt;]*&#39; term in the following</span>
<a name="l01772"></a>01772     <span class="comment"># regexp could be simplified to &#39;&lt;.*&#39;, which would indeed match</span>
<a name="l01773"></a>01773     <span class="comment"># the same class of strings, the [^&lt;] means that searching for the</span>
<a name="l01774"></a>01774     <span class="comment"># regexp takes linear rather than quadratic time.</span>
<a name="l01775"></a>01775     <span class="keywordflow">if</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;&lt;[^&lt;]*,\s*$&#39;</span>, line):  <span class="comment"># template params spill</span>
<a name="l01776"></a>01776       match = Search(<span class="stringliteral">r&#39;[^&lt;&gt;=!\s](&lt;)[^&lt;&gt;=!\s]([^&gt;]|-&gt;)*$&#39;</span>, line)
<a name="l01777"></a>01777   <span class="keywordflow">if</span> match:
<a name="l01778"></a>01778     error(filename, linenum, <span class="stringliteral">&#39;whitespace/operators&#39;</span>, 3,
<a name="l01779"></a>01779           <span class="stringliteral">&#39;Missing spaces around %s&#39;</span> % match.group(1))
<a name="l01780"></a>01780   <span class="comment"># We allow no-spaces around &lt;&lt; and &gt;&gt; when used like this: 10&lt;&lt;20, but</span>
<a name="l01781"></a>01781   <span class="comment"># not otherwise (particularly, not when used as streams)</span>
<a name="l01782"></a>01782   match = Search(<span class="stringliteral">r&#39;[^0-9\s](&lt;&lt;|&gt;&gt;)[^0-9\s]&#39;</span>, line)
<a name="l01783"></a>01783   <span class="keywordflow">if</span> match:
<a name="l01784"></a>01784     error(filename, linenum, <span class="stringliteral">&#39;whitespace/operators&#39;</span>, 3,
<a name="l01785"></a>01785           <span class="stringliteral">&#39;Missing spaces around %s&#39;</span> % match.group(1))
<a name="l01786"></a>01786 
<a name="l01787"></a>01787   <span class="comment"># There shouldn&#39;t be space around unary operators</span>
<a name="l01788"></a>01788   match = Search(<span class="stringliteral">r&#39;(!\s|~\s|[\s]--[\s;]|[\s]\+\+[\s;])&#39;</span>, line)
<a name="l01789"></a>01789   <span class="keywordflow">if</span> match:
<a name="l01790"></a>01790     error(filename, linenum, <span class="stringliteral">&#39;whitespace/operators&#39;</span>, 4,
<a name="l01791"></a>01791           <span class="stringliteral">&#39;Extra space for operator %s&#39;</span> % match.group(1))
<a name="l01792"></a>01792 
<a name="l01793"></a>01793   <span class="comment"># A pet peeve of mine: no spaces after an if, while, switch, or for</span>
<a name="l01794"></a>01794   match = Search(<span class="stringliteral">r&#39; (if\(|for\(|while\(|switch\()&#39;</span>, line)
<a name="l01795"></a>01795   <span class="keywordflow">if</span> match:
<a name="l01796"></a>01796     error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 5,
<a name="l01797"></a>01797           <span class="stringliteral">&#39;Missing space before ( in %s&#39;</span> % match.group(1))
<a name="l01798"></a>01798 
<a name="l01799"></a>01799   <span class="comment"># For if/for/while/switch, the left and right parens should be</span>
<a name="l01800"></a>01800   <span class="comment"># consistent about how many spaces are inside the parens, and</span>
<a name="l01801"></a>01801   <span class="comment"># there should either be zero or one spaces inside the parens.</span>
<a name="l01802"></a>01802   <span class="comment"># We don&#39;t want: &quot;if ( foo)&quot; or &quot;if ( foo   )&quot;.</span>
<a name="l01803"></a>01803   <span class="comment"># Exception: &quot;for ( ; foo; bar)&quot; and &quot;for (foo; bar; )&quot; are allowed.</span>
<a name="l01804"></a>01804   match = Search(<span class="stringliteral">r&#39;\b(if|for|while|switch)\s*&#39;</span>
<a name="l01805"></a>01805                  <span class="stringliteral">r&#39;\(([ ]*)(.).*[^ ]+([ ]*)\)\s*{\s*$&#39;</span>,
<a name="l01806"></a>01806                  line)
<a name="l01807"></a>01807   <span class="keywordflow">if</span> match:
<a name="l01808"></a>01808     <span class="keywordflow">if</span> len(match.group(2)) != len(match.group(4)):
<a name="l01809"></a>01809       <span class="keywordflow">if</span> <span class="keywordflow">not</span> (match.group(3) == <span class="stringliteral">&#39;;&#39;</span> <span class="keywordflow">and</span>
<a name="l01810"></a>01810               len(match.group(2)) == 1 + len(match.group(4)) <span class="keywordflow">or</span>
<a name="l01811"></a>01811               <span class="keywordflow">not</span> match.group(2) <span class="keywordflow">and</span> Search(<span class="stringliteral">r&#39;\bfor\s*\(.*; \)&#39;</span>, line)):
<a name="l01812"></a>01812         error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 5,
<a name="l01813"></a>01813               <span class="stringliteral">&#39;Mismatching spaces inside () in %s&#39;</span> % match.group(1))
<a name="l01814"></a>01814     <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(match.group(2)) <span class="keywordflow">in</span> [0, 1]:
<a name="l01815"></a>01815       error(filename, linenum, <span class="stringliteral">&#39;whitespace/parens&#39;</span>, 5,
<a name="l01816"></a>01816             <span class="stringliteral">&#39;Should have zero or one spaces inside ( and ) in %s&#39;</span> %
<a name="l01817"></a>01817             match.group(1))
<a name="l01818"></a>01818 
<a name="l01819"></a>01819   <span class="comment"># You should always have a space after a comma (either as fn arg or operator)</span>
<a name="l01820"></a>01820   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;,[^\s]&#39;</span>, line):
<a name="l01821"></a>01821     error(filename, linenum, <span class="stringliteral">&#39;whitespace/comma&#39;</span>, 3,
<a name="l01822"></a>01822           <span class="stringliteral">&#39;Missing space after ,&#39;</span>)
<a name="l01823"></a>01823 
<a name="l01824"></a>01824   <span class="comment"># Next we will look for issues with function calls.</span>
<a name="l01825"></a>01825   CheckSpacingForFunctionCall(filename, line, linenum, error)
<a name="l01826"></a>01826 
<a name="l01827"></a>01827   <span class="comment"># Except after an opening paren, you should have spaces before your braces.</span>
<a name="l01828"></a>01828   <span class="comment"># And since you should never have braces at the beginning of a line, this is</span>
<a name="l01829"></a>01829   <span class="comment"># an easy test.</span>
<a name="l01830"></a>01830   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;[^ (]{&#39;</span>, line):
<a name="l01831"></a>01831     error(filename, linenum, <span class="stringliteral">&#39;whitespace/braces&#39;</span>, 5,
<a name="l01832"></a>01832           <span class="stringliteral">&#39;Missing space before {&#39;</span>)
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   <span class="comment"># Make sure &#39;} else {&#39; has spaces.</span>
<a name="l01835"></a>01835   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;}else&#39;</span>, line):
<a name="l01836"></a>01836     error(filename, linenum, <span class="stringliteral">&#39;whitespace/braces&#39;</span>, 5,
<a name="l01837"></a>01837           <span class="stringliteral">&#39;Missing space before else&#39;</span>)
<a name="l01838"></a>01838 
<a name="l01839"></a>01839   <span class="comment"># You shouldn&#39;t have spaces before your brackets, except maybe after</span>
<a name="l01840"></a>01840   <span class="comment"># &#39;delete []&#39; or &#39;new char * []&#39;.</span>
<a name="l01841"></a>01841   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\w\s+\[&#39;</span>, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;delete\s+\[&#39;</span>, line):
<a name="l01842"></a>01842     error(filename, linenum, <span class="stringliteral">&#39;whitespace/braces&#39;</span>, 5,
<a name="l01843"></a>01843           <span class="stringliteral">&#39;Extra space before [&#39;</span>)
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   <span class="comment"># You shouldn&#39;t have a space before a semicolon at the end of the line.</span>
<a name="l01846"></a>01846   <span class="comment"># There&#39;s a special case for &quot;for&quot; since the style guide allows space before</span>
<a name="l01847"></a>01847   <span class="comment"># the semicolon there.</span>
<a name="l01848"></a>01848   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;:\s*;\s*$&#39;</span>, line):
<a name="l01849"></a>01849     error(filename, linenum, <span class="stringliteral">&#39;whitespace/semicolon&#39;</span>, 5,
<a name="l01850"></a>01850           <span class="stringliteral">&#39;Semicolon defining empty statement. Use { } instead.&#39;</span>)
<a name="l01851"></a>01851   <span class="keywordflow">elif</span> Search(<span class="stringliteral">r&#39;^\s*;\s*$&#39;</span>, line):
<a name="l01852"></a>01852     error(filename, linenum, <span class="stringliteral">&#39;whitespace/semicolon&#39;</span>, 5,
<a name="l01853"></a>01853           <span class="stringliteral">&#39;Line contains only semicolon. If this should be an empty statement, &#39;</span>
<a name="l01854"></a>01854           <span class="stringliteral">&#39;use { } instead.&#39;</span>)
<a name="l01855"></a>01855   <span class="keywordflow">elif</span> (Search(<span class="stringliteral">r&#39;\s+;\s*$&#39;</span>, line) <span class="keywordflow">and</span>
<a name="l01856"></a>01856         <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;\bfor\b&#39;</span>, line)):
<a name="l01857"></a>01857     error(filename, linenum, <span class="stringliteral">&#39;whitespace/semicolon&#39;</span>, 5,
<a name="l01858"></a>01858           <span class="stringliteral">&#39;Extra space before last semicolon. If this should be an empty &#39;</span>
<a name="l01859"></a>01859           <span class="stringliteral">&#39;statement, use { } instead.&#39;</span>)
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 
<a name="l01862"></a>01862 <span class="keyword">def </span>GetPreviousNonBlankLine(clean_lines, linenum):
<a name="l01863"></a>01863   <span class="stringliteral">&quot;&quot;&quot;Return the most recent non-blank line and its line number.</span>
<a name="l01864"></a>01864 <span class="stringliteral"></span>
<a name="l01865"></a>01865 <span class="stringliteral">  Args:</span>
<a name="l01866"></a>01866 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file contents.</span>
<a name="l01867"></a>01867 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01868"></a>01868 <span class="stringliteral"></span>
<a name="l01869"></a>01869 <span class="stringliteral">  Returns:</span>
<a name="l01870"></a>01870 <span class="stringliteral">    A tuple with two elements.  The first element is the contents of the last</span>
<a name="l01871"></a>01871 <span class="stringliteral">    non-blank line before the current line, or the empty string if this is the</span>
<a name="l01872"></a>01872 <span class="stringliteral">    first non-blank line.  The second is the line number of that line, or -1</span>
<a name="l01873"></a>01873 <span class="stringliteral">    if this is the first non-blank line.</span>
<a name="l01874"></a>01874 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01875"></a>01875 
<a name="l01876"></a>01876   prevlinenum = linenum - 1
<a name="l01877"></a>01877   <span class="keywordflow">while</span> prevlinenum &gt;= 0:
<a name="l01878"></a>01878     prevline = clean_lines.elided[prevlinenum]
<a name="l01879"></a>01879     <span class="keywordflow">if</span> <span class="keywordflow">not</span> IsBlankLine(prevline):     <span class="comment"># if not a blank line...</span>
<a name="l01880"></a>01880       <span class="keywordflow">return</span> (prevline, prevlinenum)
<a name="l01881"></a>01881     prevlinenum -= 1
<a name="l01882"></a>01882   <span class="keywordflow">return</span> (<span class="stringliteral">&#39;&#39;</span>, -1)
<a name="l01883"></a>01883 
<a name="l01884"></a>01884 
<a name="l01885"></a>01885 <span class="keyword">def </span>CheckBraces(filename, clean_lines, linenum, error):
<a name="l01886"></a>01886   <span class="stringliteral">&quot;&quot;&quot;Looks for misplaced braces (e.g. at the end of line).</span>
<a name="l01887"></a>01887 <span class="stringliteral"></span>
<a name="l01888"></a>01888 <span class="stringliteral">  Args:</span>
<a name="l01889"></a>01889 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01890"></a>01890 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l01891"></a>01891 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l01892"></a>01892 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l01893"></a>01893 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01894"></a>01894 
<a name="l01895"></a>01895   line = clean_lines.elided[linenum]        <span class="comment"># get rid of comments and strings</span>
<a name="l01896"></a>01896 
<a name="l01897"></a>01897   <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*{\s*$&#39;</span>, line):
<a name="l01898"></a>01898     <span class="comment"># We allow an open brace to start a line in the case where someone</span>
<a name="l01899"></a>01899     <span class="comment"># is using braces in a block to explicitly create a new scope,</span>
<a name="l01900"></a>01900     <span class="comment"># which is commonly used to control the lifetime of</span>
<a name="l01901"></a>01901     <span class="comment"># stack-allocated variables.  We don&#39;t detect this perfectly: we</span>
<a name="l01902"></a>01902     <span class="comment"># just don&#39;t complain if the last non-whitespace character on the</span>
<a name="l01903"></a>01903     <span class="comment"># previous non-blank line is &#39;;&#39;, &#39;:&#39;, &#39;{&#39;, or &#39;}&#39;.</span>
<a name="l01904"></a>01904     prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]
<a name="l01905"></a>01905     <span class="keywordflow">if</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;[;:}{]\s*$&#39;</span>, prevline):
<a name="l01906"></a>01906       error(filename, linenum, <span class="stringliteral">&#39;whitespace/braces&#39;</span>, 4,
<a name="l01907"></a>01907             <span class="stringliteral">&#39;{ should almost always be at the end of the previous line&#39;</span>)
<a name="l01908"></a>01908 
<a name="l01909"></a>01909   <span class="comment"># An else clause should be on the same line as the preceding closing brace.</span>
<a name="l01910"></a>01910   <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*else\s*&#39;</span>, line):
<a name="l01911"></a>01911     prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]
<a name="l01912"></a>01912     <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*}\s*$&#39;</span>, prevline):
<a name="l01913"></a>01913       error(filename, linenum, <span class="stringliteral">&#39;whitespace/newline&#39;</span>, 4,
<a name="l01914"></a>01914             <span class="stringliteral">&#39;An else should appear on the same line as the preceding }&#39;</span>)
<a name="l01915"></a>01915 
<a name="l01916"></a>01916   <span class="comment"># If braces come on one side of an else, they should be on both.</span>
<a name="l01917"></a>01917   <span class="comment"># However, we have to worry about &quot;else if&quot; that spans multiple lines!</span>
<a name="l01918"></a>01918   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;}\s*else[^{]*$&#39;</span>, line) <span class="keywordflow">or</span> Match(<span class="stringliteral">r&#39;[^}]*else\s*{&#39;</span>, line):
<a name="l01919"></a>01919     <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;}\s*else if([^{]*)$&#39;</span>, line):       <span class="comment"># could be multi-line if</span>
<a name="l01920"></a>01920       <span class="comment"># find the ( after the if</span>
<a name="l01921"></a>01921       pos = line.find(<span class="stringliteral">&#39;else if&#39;</span>)
<a name="l01922"></a>01922       pos = line.find(<span class="stringliteral">&#39;(&#39;</span>, pos)
<a name="l01923"></a>01923       <span class="keywordflow">if</span> pos &gt; 0:
<a name="l01924"></a>01924         (endline, _, endpos) = CloseExpression(clean_lines, linenum, pos)
<a name="l01925"></a>01925         <span class="keywordflow">if</span> endline[endpos:].find(<span class="stringliteral">&#39;{&#39;</span>) == -1:    <span class="comment"># must be brace after if</span>
<a name="l01926"></a>01926           error(filename, linenum, <span class="stringliteral">&#39;readability/braces&#39;</span>, 5,
<a name="l01927"></a>01927                 <span class="stringliteral">&#39;If an else has a brace on one side, it should have it on both&#39;</span>)
<a name="l01928"></a>01928     <span class="keywordflow">else</span>:            <span class="comment"># common case: else not followed by a multi-line if</span>
<a name="l01929"></a>01929       error(filename, linenum, <span class="stringliteral">&#39;readability/braces&#39;</span>, 5,
<a name="l01930"></a>01930             <span class="stringliteral">&#39;If an else has a brace on one side, it should have it on both&#39;</span>)
<a name="l01931"></a>01931 
<a name="l01932"></a>01932   <span class="comment"># Likewise, an else should never have the else clause on the same line</span>
<a name="l01933"></a>01933   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\belse [^\s{]&#39;</span>, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;\belse if\b&#39;</span>, line):
<a name="l01934"></a>01934     error(filename, linenum, <span class="stringliteral">&#39;whitespace/newline&#39;</span>, 4,
<a name="l01935"></a>01935           <span class="stringliteral">&#39;Else clause should never be on same line as else (use 2 lines)&#39;</span>)
<a name="l01936"></a>01936 
<a name="l01937"></a>01937   <span class="comment"># In the same way, a do/while should never be on one line</span>
<a name="l01938"></a>01938   <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s*do [^\s{]&#39;</span>, line):
<a name="l01939"></a>01939     error(filename, linenum, <span class="stringliteral">&#39;whitespace/newline&#39;</span>, 4,
<a name="l01940"></a>01940           <span class="stringliteral">&#39;do/while clauses should not be on a single line&#39;</span>)
<a name="l01941"></a>01941 
<a name="l01942"></a>01942   <span class="comment"># Braces shouldn&#39;t be followed by a ; unless they&#39;re defining a struct</span>
<a name="l01943"></a>01943   <span class="comment"># or initializing an array.</span>
<a name="l01944"></a>01944   <span class="comment"># We can&#39;t tell in general, but we can for some common cases.</span>
<a name="l01945"></a>01945   prevlinenum = linenum
<a name="l01946"></a>01946   <span class="keywordflow">while</span> <span class="keyword">True</span>:
<a name="l01947"></a>01947     (prevline, prevlinenum) = GetPreviousNonBlankLine(clean_lines, prevlinenum)
<a name="l01948"></a>01948     <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\s+{.*}\s*;&#39;</span>, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> prevline.count(<span class="stringliteral">&#39;;&#39;</span>):
<a name="l01949"></a>01949       line = prevline + line
<a name="l01950"></a>01950     <span class="keywordflow">else</span>:
<a name="l01951"></a>01951       <span class="keywordflow">break</span>
<a name="l01952"></a>01952   <span class="keywordflow">if</span> (Search(<span class="stringliteral">r&#39;{.*}\s*;&#39;</span>, line) <span class="keywordflow">and</span>
<a name="l01953"></a>01953       line.count(<span class="stringliteral">&#39;{&#39;</span>) == line.count(<span class="stringliteral">&#39;}&#39;</span>) <span class="keywordflow">and</span>
<a name="l01954"></a>01954       <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;struct|class|enum|\s*=\s*{&#39;</span>, line)):
<a name="l01955"></a>01955     error(filename, linenum, <span class="stringliteral">&#39;readability/braces&#39;</span>, 4,
<a name="l01956"></a>01956           <span class="stringliteral">&quot;You don&#39;t need a ; after a }&quot;</span>)
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 <span class="keyword">def </span>ReplaceableCheck(operator, macro, line):
<a name="l01960"></a>01960   <span class="stringliteral">&quot;&quot;&quot;Determine whether a basic CHECK can be replaced with a more specific one.</span>
<a name="l01961"></a>01961 <span class="stringliteral"></span>
<a name="l01962"></a>01962 <span class="stringliteral">  For example suggest using CHECK_EQ instead of CHECK(a == b) and</span>
<a name="l01963"></a>01963 <span class="stringliteral">  similarly for CHECK_GE, CHECK_GT, CHECK_LE, CHECK_LT, CHECK_NE.</span>
<a name="l01964"></a>01964 <span class="stringliteral"></span>
<a name="l01965"></a>01965 <span class="stringliteral">  Args:</span>
<a name="l01966"></a>01966 <span class="stringliteral">    operator: The C++ operator used in the CHECK.</span>
<a name="l01967"></a>01967 <span class="stringliteral">    macro: The CHECK or EXPECT macro being called.</span>
<a name="l01968"></a>01968 <span class="stringliteral">    line: The current source line.</span>
<a name="l01969"></a>01969 <span class="stringliteral"></span>
<a name="l01970"></a>01970 <span class="stringliteral">  Returns:</span>
<a name="l01971"></a>01971 <span class="stringliteral">    True if the CHECK can be replaced with a more specific one.</span>
<a name="l01972"></a>01972 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l01973"></a>01973 
<a name="l01974"></a>01974   <span class="comment"># This matches decimal and hex integers, strings, and chars (in that order).</span>
<a name="l01975"></a>01975   match_constant = <span class="stringliteral">r&#39;([-+]?(\d+|0[xX][0-9a-fA-F]+)[lLuU]{0,3}|&quot;.*&quot;|\&#39;.*\&#39;)&#39;</span>
<a name="l01976"></a>01976 
<a name="l01977"></a>01977   <span class="comment"># Expression to match two sides of the operator with something that</span>
<a name="l01978"></a>01978   <span class="comment"># looks like a literal, since CHECK(x == iterator) won&#39;t compile.</span>
<a name="l01979"></a>01979   <span class="comment"># This means we can&#39;t catch all the cases where a more specific</span>
<a name="l01980"></a>01980   <span class="comment"># CHECK is possible, but it&#39;s less annoying than dealing with</span>
<a name="l01981"></a>01981   <span class="comment"># extraneous warnings.</span>
<a name="l01982"></a>01982   match_this = (<span class="stringliteral">r&#39;\s*&#39;</span> + macro + <span class="stringliteral">r&#39;\((\s*&#39;</span> +
<a name="l01983"></a>01983                 match_constant + <span class="stringliteral">r&#39;\s*&#39;</span> + operator + <span class="stringliteral">r&#39;[^&lt;&gt;].*|&#39;</span>
<a name="l01984"></a>01984                 <span class="stringliteral">r&#39;.*[^&lt;&gt;]&#39;</span> + operator + <span class="stringliteral">r&#39;\s*&#39;</span> + match_constant +
<a name="l01985"></a>01985                 <span class="stringliteral">r&#39;\s*\))&#39;</span>)
<a name="l01986"></a>01986 
<a name="l01987"></a>01987   <span class="comment"># Don&#39;t complain about CHECK(x == NULL) or similar because</span>
<a name="l01988"></a>01988   <span class="comment"># CHECK_EQ(x, NULL) won&#39;t compile (requires a cast).</span>
<a name="l01989"></a>01989   <span class="comment"># Also, don&#39;t complain about more complex boolean expressions</span>
<a name="l01990"></a>01990   <span class="comment"># involving &amp;&amp; or || such as CHECK(a == b || c == d).</span>
<a name="l01991"></a>01991   <span class="keywordflow">return</span> Match(match_this, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;NULL|&amp;&amp;|\|\|&#39;</span>, line)
<a name="l01992"></a>01992 
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 <span class="keyword">def </span>CheckCheck(filename, clean_lines, linenum, error):
<a name="l01995"></a>01995   <span class="stringliteral">&quot;&quot;&quot;Checks the use of CHECK and EXPECT macros.</span>
<a name="l01996"></a>01996 <span class="stringliteral"></span>
<a name="l01997"></a>01997 <span class="stringliteral">  Args:</span>
<a name="l01998"></a>01998 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l01999"></a>01999 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l02000"></a>02000 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l02001"></a>02001 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02002"></a>02002 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02003"></a>02003 
<a name="l02004"></a>02004   <span class="comment"># Decide the set of replacement macros that should be suggested</span>
<a name="l02005"></a>02005   raw_lines = clean_lines.raw_lines
<a name="l02006"></a>02006   current_macro = <span class="stringliteral">&#39;&#39;</span>
<a name="l02007"></a>02007   <span class="keywordflow">for</span> macro <span class="keywordflow">in</span> _CHECK_MACROS:
<a name="l02008"></a>02008     <span class="keywordflow">if</span> raw_lines[linenum].find(macro) &gt;= 0:
<a name="l02009"></a>02009       current_macro = macro
<a name="l02010"></a>02010       <span class="keywordflow">break</span>
<a name="l02011"></a>02011   <span class="keywordflow">if</span> <span class="keywordflow">not</span> current_macro:
<a name="l02012"></a>02012     <span class="comment"># Don&#39;t waste time here if line doesn&#39;t contain &#39;CHECK&#39; or &#39;EXPECT&#39;</span>
<a name="l02013"></a>02013     <span class="keywordflow">return</span>
<a name="l02014"></a>02014 
<a name="l02015"></a>02015   line = clean_lines.elided[linenum]        <span class="comment"># get rid of comments and strings</span>
<a name="l02016"></a>02016 
<a name="l02017"></a>02017   <span class="comment"># Encourage replacing plain CHECKs with CHECK_EQ/CHECK_NE/etc.</span>
<a name="l02018"></a>02018   <span class="keywordflow">for</span> operator <span class="keywordflow">in</span> [<span class="stringliteral">&#39;==&#39;</span>, <span class="stringliteral">&#39;!=&#39;</span>, <span class="stringliteral">&#39;&gt;=&#39;</span>, <span class="stringliteral">&#39;&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;=&#39;</span>, <span class="stringliteral">&#39;&lt;&#39;</span>]:
<a name="l02019"></a>02019     <span class="keywordflow">if</span> ReplaceableCheck(operator, current_macro, line):
<a name="l02020"></a>02020       error(filename, linenum, <span class="stringliteral">&#39;readability/check&#39;</span>, 2,
<a name="l02021"></a>02021             <span class="stringliteral">&#39;Consider using %s instead of %s(a %s b)&#39;</span> % (
<a name="l02022"></a>02022                 _CHECK_REPLACEMENT[current_macro][operator],
<a name="l02023"></a>02023                 current_macro, operator))
<a name="l02024"></a>02024       <span class="keywordflow">break</span>
<a name="l02025"></a>02025 
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="keyword">def </span>GetLineWidth(line):
<a name="l02028"></a>02028   <span class="stringliteral">&quot;&quot;&quot;Determines the width of the line in column positions.</span>
<a name="l02029"></a>02029 <span class="stringliteral"></span>
<a name="l02030"></a>02030 <span class="stringliteral">  Args:</span>
<a name="l02031"></a>02031 <span class="stringliteral">    line: A string, which may be a Unicode string.</span>
<a name="l02032"></a>02032 <span class="stringliteral"></span>
<a name="l02033"></a>02033 <span class="stringliteral">  Returns:</span>
<a name="l02034"></a>02034 <span class="stringliteral">    The width of the line in column positions, accounting for Unicode</span>
<a name="l02035"></a>02035 <span class="stringliteral">    combining characters and wide characters.</span>
<a name="l02036"></a>02036 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02037"></a>02037   <span class="keywordflow">if</span> isinstance(line, unicode):
<a name="l02038"></a>02038     width = 0
<a name="l02039"></a>02039     <span class="keywordflow">for</span> c <span class="keywordflow">in</span> unicodedata.normalize(<span class="stringliteral">&#39;NFC&#39;</span>, line):
<a name="l02040"></a>02040       <span class="keywordflow">if</span> unicodedata.east_asian_width(c) <span class="keywordflow">in</span> (<span class="stringliteral">&#39;W&#39;</span>, <span class="stringliteral">&#39;F&#39;</span>):
<a name="l02041"></a>02041         width += 2
<a name="l02042"></a>02042       <span class="keywordflow">elif</span> <span class="keywordflow">not</span> unicodedata.combining(c):
<a name="l02043"></a>02043         width += 1
<a name="l02044"></a>02044     <span class="keywordflow">return</span> width
<a name="l02045"></a>02045   <span class="keywordflow">else</span>:
<a name="l02046"></a>02046     <span class="keywordflow">return</span> len(line)
<a name="l02047"></a>02047 
<a name="l02048"></a>02048 
<a name="l02049"></a>02049 <span class="keyword">def </span>CheckStyle(filename, clean_lines, linenum, file_extension, error):
<a name="l02050"></a>02050   <span class="stringliteral">&quot;&quot;&quot;Checks rules from the &#39;C++ style rules&#39; section of cppguide.html.</span>
<a name="l02051"></a>02051 <span class="stringliteral"></span>
<a name="l02052"></a>02052 <span class="stringliteral">  Most of these rules are hard to test (naming, comment style), but we</span>
<a name="l02053"></a>02053 <span class="stringliteral">  do what we can.  In particular we check for 2-space indents, line lengths,</span>
<a name="l02054"></a>02054 <span class="stringliteral">  tab usage, spaces inside code, etc.</span>
<a name="l02055"></a>02055 <span class="stringliteral"></span>
<a name="l02056"></a>02056 <span class="stringliteral">  Args:</span>
<a name="l02057"></a>02057 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l02058"></a>02058 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l02059"></a>02059 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l02060"></a>02060 <span class="stringliteral">    file_extension: The extension (without the dot) of the filename.</span>
<a name="l02061"></a>02061 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02062"></a>02062 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02063"></a>02063 
<a name="l02064"></a>02064   raw_lines = clean_lines.raw_lines
<a name="l02065"></a>02065   line = raw_lines[linenum]
<a name="l02066"></a>02066 
<a name="l02067"></a>02067   <span class="keywordflow">if</span> line.find(<span class="stringliteral">&#39;\t&#39;</span>) != -1:
<a name="l02068"></a>02068     error(filename, linenum, <span class="stringliteral">&#39;whitespace/tab&#39;</span>, 1,
<a name="l02069"></a>02069           <span class="stringliteral">&#39;Tab found; better to use spaces&#39;</span>)
<a name="l02070"></a>02070 
<a name="l02071"></a>02071   <span class="comment"># One or three blank spaces at the beginning of the line is weird; it&#39;s</span>
<a name="l02072"></a>02072   <span class="comment"># hard to reconcile that with 2-space indents.</span>
<a name="l02073"></a>02073   <span class="comment"># NOTE: here are the conditions rob pike used for his tests.  Mine aren&#39;t</span>
<a name="l02074"></a>02074   <span class="comment"># as sophisticated, but it may be worth becoming so:  RLENGTH==initial_spaces</span>
<a name="l02075"></a>02075   <span class="comment"># if(RLENGTH &gt; 20) complain = 0;</span>
<a name="l02076"></a>02076   <span class="comment"># if(match($0, &quot; +(error|private|public|protected):&quot;)) complain = 0;</span>
<a name="l02077"></a>02077   <span class="comment"># if(match(prev, &quot;&amp;&amp; *$&quot;)) complain = 0;</span>
<a name="l02078"></a>02078   <span class="comment"># if(match(prev, &quot;\\|\\| *$&quot;)) complain = 0;</span>
<a name="l02079"></a>02079   <span class="comment"># if(match(prev, &quot;[\&quot;,=&gt;&lt;] *$&quot;)) complain = 0;</span>
<a name="l02080"></a>02080   <span class="comment"># if(match($0, &quot; &lt;&lt;&quot;)) complain = 0;</span>
<a name="l02081"></a>02081   <span class="comment"># if(match(prev, &quot; +for \\(&quot;)) complain = 0;</span>
<a name="l02082"></a>02082   <span class="comment"># if(prevodd &amp;&amp; match(prevprev, &quot; +for \\(&quot;)) complain = 0;</span>
<a name="l02083"></a>02083   initial_spaces = 0
<a name="l02084"></a>02084   cleansed_line = clean_lines.elided[linenum]
<a name="l02085"></a>02085   <span class="keywordflow">while</span> initial_spaces &lt; len(line) <span class="keywordflow">and</span> line[initial_spaces] == <span class="stringliteral">&#39; &#39;</span>:
<a name="l02086"></a>02086     initial_spaces += 1
<a name="l02087"></a>02087   <span class="keywordflow">if</span> line <span class="keywordflow">and</span> line[-1].isspace():
<a name="l02088"></a>02088     error(filename, linenum, <span class="stringliteral">&#39;whitespace/end_of_line&#39;</span>, 4,
<a name="l02089"></a>02089           <span class="stringliteral">&#39;Line ends in whitespace.  Consider deleting these extra spaces.&#39;</span>)
<a name="l02090"></a>02090   <span class="comment"># There are certain situations we allow one space, notably for labels</span>
<a name="l02091"></a>02091   <span class="keywordflow">elif</span> ((initial_spaces == 1 <span class="keywordflow">or</span> initial_spaces == 3) <span class="keywordflow">and</span>
<a name="l02092"></a>02092         <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;\s*\w+\s*:\s*$&#39;</span>, cleansed_line)):
<a name="l02093"></a>02093     error(filename, linenum, <span class="stringliteral">&#39;whitespace/indent&#39;</span>, 3,
<a name="l02094"></a>02094           <span class="stringliteral">&#39;Weird number of spaces at line-start.  &#39;</span>
<a name="l02095"></a>02095           <span class="stringliteral">&#39;Are you using a 2-space indent?&#39;</span>)
<a name="l02096"></a>02096   <span class="comment"># Labels should always be indented at least one space.</span>
<a name="l02097"></a>02097   <span class="keywordflow">elif</span> <span class="keywordflow">not</span> initial_spaces <span class="keywordflow">and</span> line[:2] != <span class="stringliteral">&#39;//&#39;</span> <span class="keywordflow">and</span> Search(<span class="stringliteral">r&#39;[^:]:\s*$&#39;</span>,
<a name="l02098"></a>02098                                                           line):
<a name="l02099"></a>02099     error(filename, linenum, <span class="stringliteral">&#39;whitespace/labels&#39;</span>, 4,
<a name="l02100"></a>02100           <span class="stringliteral">&#39;Labels should always be indented at least one space.  &#39;</span>
<a name="l02101"></a>02101           <span class="stringliteral">&#39;If this is a member-initializer list in a constructor or &#39;</span>
<a name="l02102"></a>02102           <span class="stringliteral">&#39;the base class list in a class definition, the colon should &#39;</span>
<a name="l02103"></a>02103           <span class="stringliteral">&#39;be on the following line.&#39;</span>)
<a name="l02104"></a>02104 
<a name="l02105"></a>02105 
<a name="l02106"></a>02106   <span class="comment"># Check if the line is a header guard.</span>
<a name="l02107"></a>02107   is_header_guard = <span class="keyword">False</span>
<a name="l02108"></a>02108   <span class="keywordflow">if</span> file_extension == <span class="stringliteral">&#39;h&#39;</span>:
<a name="l02109"></a>02109     cppvar = GetHeaderGuardCPPVariable(filename)
<a name="l02110"></a>02110     <span class="keywordflow">if</span> (line.startswith(<span class="stringliteral">&#39;#ifndef %s&#39;</span> % cppvar) <span class="keywordflow">or</span>
<a name="l02111"></a>02111         line.startswith(<span class="stringliteral">&#39;#define %s&#39;</span> % cppvar) <span class="keywordflow">or</span>
<a name="l02112"></a>02112         line.startswith(<span class="stringliteral">&#39;#endif  // %s&#39;</span> % cppvar)):
<a name="l02113"></a>02113       is_header_guard = <span class="keyword">True</span>
<a name="l02114"></a>02114   <span class="comment"># #include lines and header guards can be long, since there&#39;s no clean way to</span>
<a name="l02115"></a>02115   <span class="comment"># split them.</span>
<a name="l02116"></a>02116   <span class="comment">#</span>
<a name="l02117"></a>02117   <span class="comment"># URLs can be long too.  It&#39;s possible to split these, but it makes them</span>
<a name="l02118"></a>02118   <span class="comment"># harder to cut&amp;paste.</span>
<a name="l02119"></a>02119   <span class="keywordflow">if</span> (<span class="keywordflow">not</span> line.startswith(<span class="stringliteral">&#39;#include&#39;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_header_guard <span class="keywordflow">and</span>
<a name="l02120"></a>02120       <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;^\s*//.*http(s?)://\S*$&#39;</span>, line)):
<a name="l02121"></a>02121     line_width = GetLineWidth(line)
<a name="l02122"></a>02122     <span class="keywordflow">if</span> line_width &gt; 100:
<a name="l02123"></a>02123       error(filename, linenum, <span class="stringliteral">&#39;whitespace/line_length&#39;</span>, 4,
<a name="l02124"></a>02124             <span class="stringliteral">&#39;Lines should very rarely be longer than 100 characters&#39;</span>)
<a name="l02125"></a>02125     <span class="keywordflow">elif</span> line_width &gt; 80:
<a name="l02126"></a>02126       error(filename, linenum, <span class="stringliteral">&#39;whitespace/line_length&#39;</span>, 2,
<a name="l02127"></a>02127             <span class="stringliteral">&#39;Lines should be &lt;= 80 characters long&#39;</span>)
<a name="l02128"></a>02128 
<a name="l02129"></a>02129   <span class="keywordflow">if</span> (cleansed_line.count(<span class="stringliteral">&#39;;&#39;</span>) &gt; 1 <span class="keywordflow">and</span>
<a name="l02130"></a>02130       <span class="comment"># for loops are allowed two ;&#39;s (and may run over two lines).</span>
<a name="l02131"></a>02131       cleansed_line.find(<span class="stringliteral">&#39;for&#39;</span>) == -1 <span class="keywordflow">and</span>
<a name="l02132"></a>02132       (GetPreviousNonBlankLine(clean_lines, linenum)[0].find(<span class="stringliteral">&#39;for&#39;</span>) == -1 <span class="keywordflow">or</span>
<a name="l02133"></a>02133        GetPreviousNonBlankLine(clean_lines, linenum)[0].find(<span class="stringliteral">&#39;;&#39;</span>) != -1) <span class="keywordflow">and</span>
<a name="l02134"></a>02134       <span class="comment"># It&#39;s ok to have many commands in a switch case that fits in 1 line</span>
<a name="l02135"></a>02135       <span class="keywordflow">not</span> ((cleansed_line.find(<span class="stringliteral">&#39;case &#39;</span>) != -1 <span class="keywordflow">or</span>
<a name="l02136"></a>02136             cleansed_line.find(<span class="stringliteral">&#39;default:&#39;</span>) != -1) <span class="keywordflow">and</span>
<a name="l02137"></a>02137            cleansed_line.find(<span class="stringliteral">&#39;break;&#39;</span>) != -1)):
<a name="l02138"></a>02138     error(filename, linenum, <span class="stringliteral">&#39;whitespace/newline&#39;</span>, 4,
<a name="l02139"></a>02139           <span class="stringliteral">&#39;More than one command on the same line&#39;</span>)
<a name="l02140"></a>02140 
<a name="l02141"></a>02141   <span class="comment"># Some more style checks</span>
<a name="l02142"></a>02142   CheckBraces(filename, clean_lines, linenum, error)
<a name="l02143"></a>02143   CheckSpacing(filename, clean_lines, linenum, error)
<a name="l02144"></a>02144   CheckCheck(filename, clean_lines, linenum, error)
<a name="l02145"></a>02145 
<a name="l02146"></a>02146 
<a name="l02147"></a>02147 _RE_PATTERN_INCLUDE_NEW_STYLE = re.compile(<span class="stringliteral">r&#39;#include +&quot;[^/]+\.h&quot;&#39;</span>)
<a name="l02148"></a>02148 _RE_PATTERN_INCLUDE = re.compile(<span class="stringliteral">r&#39;^\s*#\s*include\s*([&lt;&quot;])([^&gt;&quot;]*)[&gt;&quot;].*$&#39;</span>)
<a name="l02149"></a>02149 <span class="comment"># Matches the first component of a filename delimited by -s and _s. That is:</span>
<a name="l02150"></a>02150 <span class="comment">#  _RE_FIRST_COMPONENT.match(&#39;foo&#39;).group(0) == &#39;foo&#39;</span>
<a name="l02151"></a>02151 <span class="comment">#  _RE_FIRST_COMPONENT.match(&#39;foo.cc&#39;).group(0) == &#39;foo&#39;</span>
<a name="l02152"></a>02152 <span class="comment">#  _RE_FIRST_COMPONENT.match(&#39;foo-bar_baz.cc&#39;).group(0) == &#39;foo&#39;</span>
<a name="l02153"></a>02153 <span class="comment">#  _RE_FIRST_COMPONENT.match(&#39;foo_bar-baz.cc&#39;).group(0) == &#39;foo&#39;</span>
<a name="l02154"></a>02154 _RE_FIRST_COMPONENT = re.compile(<span class="stringliteral">r&#39;^[^-_.]+&#39;</span>)
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 
<a name="l02157"></a>02157 <span class="keyword">def </span>_DropCommonSuffixes(filename):
<a name="l02158"></a>02158   <span class="stringliteral">&quot;&quot;&quot;Drops common suffixes like _test.cc or -inl.h from filename.</span>
<a name="l02159"></a>02159 <span class="stringliteral"></span>
<a name="l02160"></a>02160 <span class="stringliteral">  For example:</span>
<a name="l02161"></a>02161 <span class="stringliteral">    &gt;&gt;&gt; _DropCommonSuffixes(&#39;foo/foo-inl.h&#39;)</span>
<a name="l02162"></a>02162 <span class="stringliteral">    &#39;foo/foo&#39;</span>
<a name="l02163"></a>02163 <span class="stringliteral">    &gt;&gt;&gt; _DropCommonSuffixes(&#39;foo/bar/foo.cc&#39;)</span>
<a name="l02164"></a>02164 <span class="stringliteral">    &#39;foo/bar/foo&#39;</span>
<a name="l02165"></a>02165 <span class="stringliteral">    &gt;&gt;&gt; _DropCommonSuffixes(&#39;foo/foo_internal.h&#39;)</span>
<a name="l02166"></a>02166 <span class="stringliteral">    &#39;foo/foo&#39;</span>
<a name="l02167"></a>02167 <span class="stringliteral">    &gt;&gt;&gt; _DropCommonSuffixes(&#39;foo/foo_unusualinternal.h&#39;)</span>
<a name="l02168"></a>02168 <span class="stringliteral">    &#39;foo/foo_unusualinternal&#39;</span>
<a name="l02169"></a>02169 <span class="stringliteral"></span>
<a name="l02170"></a>02170 <span class="stringliteral">  Args:</span>
<a name="l02171"></a>02171 <span class="stringliteral">    filename: The input filename.</span>
<a name="l02172"></a>02172 <span class="stringliteral"></span>
<a name="l02173"></a>02173 <span class="stringliteral">  Returns:</span>
<a name="l02174"></a>02174 <span class="stringliteral">    The filename with the common suffix removed.</span>
<a name="l02175"></a>02175 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02176"></a>02176   <span class="keywordflow">for</span> suffix <span class="keywordflow">in</span> (<span class="stringliteral">&#39;test.cc&#39;</span>, <span class="stringliteral">&#39;regtest.cc&#39;</span>, <span class="stringliteral">&#39;unittest.cc&#39;</span>,
<a name="l02177"></a>02177                  <span class="stringliteral">&#39;inl.h&#39;</span>, <span class="stringliteral">&#39;impl.h&#39;</span>, <span class="stringliteral">&#39;internal.h&#39;</span>):
<a name="l02178"></a>02178     <span class="keywordflow">if</span> (filename.endswith(suffix) <span class="keywordflow">and</span> len(filename) &gt; len(suffix) <span class="keywordflow">and</span>
<a name="l02179"></a>02179         filename[-len(suffix) - 1] <span class="keywordflow">in</span> (<span class="stringliteral">&#39;-&#39;</span>, <span class="stringliteral">&#39;_&#39;</span>)):
<a name="l02180"></a>02180       <span class="keywordflow">return</span> filename[:-len(suffix) - 1]
<a name="l02181"></a>02181   <span class="keywordflow">return</span> os.path.splitext(filename)[0]
<a name="l02182"></a>02182 
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 <span class="keyword">def </span>_IsTestFilename(filename):
<a name="l02185"></a>02185   <span class="stringliteral">&quot;&quot;&quot;Determines if the given filename has a suffix that identifies it as a test.</span>
<a name="l02186"></a>02186 <span class="stringliteral"></span>
<a name="l02187"></a>02187 <span class="stringliteral">  Args:</span>
<a name="l02188"></a>02188 <span class="stringliteral">    filename: The input filename.</span>
<a name="l02189"></a>02189 <span class="stringliteral"></span>
<a name="l02190"></a>02190 <span class="stringliteral">  Returns:</span>
<a name="l02191"></a>02191 <span class="stringliteral">    True if &#39;filename&#39; looks like a test, False otherwise.</span>
<a name="l02192"></a>02192 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02193"></a>02193   <span class="keywordflow">if</span> (filename.endswith(<span class="stringliteral">&#39;_test.cc&#39;</span>) <span class="keywordflow">or</span>
<a name="l02194"></a>02194       filename.endswith(<span class="stringliteral">&#39;_unittest.cc&#39;</span>) <span class="keywordflow">or</span>
<a name="l02195"></a>02195       filename.endswith(<span class="stringliteral">&#39;_regtest.cc&#39;</span>)):
<a name="l02196"></a>02196     <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l02197"></a>02197   <span class="keywordflow">else</span>:
<a name="l02198"></a>02198     <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l02199"></a>02199 
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="keyword">def </span>_ClassifyInclude(fileinfo, include, is_system):
<a name="l02202"></a>02202   <span class="stringliteral">&quot;&quot;&quot;Figures out what kind of header &#39;include&#39; is.</span>
<a name="l02203"></a>02203 <span class="stringliteral"></span>
<a name="l02204"></a>02204 <span class="stringliteral">  Args:</span>
<a name="l02205"></a>02205 <span class="stringliteral">    fileinfo: The current file cpplint is running over. A FileInfo instance.</span>
<a name="l02206"></a>02206 <span class="stringliteral">    include: The path to a #included file.</span>
<a name="l02207"></a>02207 <span class="stringliteral">    is_system: True if the #include used &lt;&gt; rather than &quot;&quot;.</span>
<a name="l02208"></a>02208 <span class="stringliteral"></span>
<a name="l02209"></a>02209 <span class="stringliteral">  Returns:</span>
<a name="l02210"></a>02210 <span class="stringliteral">    One of the _XXX_HEADER constants.</span>
<a name="l02211"></a>02211 <span class="stringliteral"></span>
<a name="l02212"></a>02212 <span class="stringliteral">  For example:</span>
<a name="l02213"></a>02213 <span class="stringliteral">    &gt;&gt;&gt; _ClassifyInclude(FileInfo(&#39;foo/foo.cc&#39;), &#39;stdio.h&#39;, True)</span>
<a name="l02214"></a>02214 <span class="stringliteral">    _C_SYS_HEADER</span>
<a name="l02215"></a>02215 <span class="stringliteral">    &gt;&gt;&gt; _ClassifyInclude(FileInfo(&#39;foo/foo.cc&#39;), &#39;string&#39;, True)</span>
<a name="l02216"></a>02216 <span class="stringliteral">    _CPP_SYS_HEADER</span>
<a name="l02217"></a>02217 <span class="stringliteral">    &gt;&gt;&gt; _ClassifyInclude(FileInfo(&#39;foo/foo.cc&#39;), &#39;foo/foo.h&#39;, False)</span>
<a name="l02218"></a>02218 <span class="stringliteral">    _LIKELY_MY_HEADER</span>
<a name="l02219"></a>02219 <span class="stringliteral">    &gt;&gt;&gt; _ClassifyInclude(FileInfo(&#39;foo/foo_unknown_extension.cc&#39;),</span>
<a name="l02220"></a>02220 <span class="stringliteral">    ...                  &#39;bar/foo_other_ext.h&#39;, False)</span>
<a name="l02221"></a>02221 <span class="stringliteral">    _POSSIBLE_MY_HEADER</span>
<a name="l02222"></a>02222 <span class="stringliteral">    &gt;&gt;&gt; _ClassifyInclude(FileInfo(&#39;foo/foo.cc&#39;), &#39;foo/bar.h&#39;, False)</span>
<a name="l02223"></a>02223 <span class="stringliteral">    _OTHER_HEADER</span>
<a name="l02224"></a>02224 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02225"></a>02225   <span class="comment"># This is a list of all standard c++ header files, except</span>
<a name="l02226"></a>02226   <span class="comment"># those already checked for above.</span>
<a name="l02227"></a>02227   is_stl_h = include <span class="keywordflow">in</span> _STL_HEADERS
<a name="l02228"></a>02228   is_cpp_h = is_stl_h <span class="keywordflow">or</span> include <span class="keywordflow">in</span> _CPP_HEADERS
<a name="l02229"></a>02229 
<a name="l02230"></a>02230   <span class="keywordflow">if</span> is_system:
<a name="l02231"></a>02231     <span class="keywordflow">if</span> is_cpp_h:
<a name="l02232"></a>02232       <span class="keywordflow">return</span> _CPP_SYS_HEADER
<a name="l02233"></a>02233     <span class="keywordflow">else</span>:
<a name="l02234"></a>02234       <span class="keywordflow">return</span> _C_SYS_HEADER
<a name="l02235"></a>02235 
<a name="l02236"></a>02236   <span class="comment"># If the target file and the include we&#39;re checking share a</span>
<a name="l02237"></a>02237   <span class="comment"># basename when we drop common extensions, and the include</span>
<a name="l02238"></a>02238   <span class="comment"># lives in . , then it&#39;s likely to be owned by the target file.</span>
<a name="l02239"></a>02239   target_dir, target_base = (
<a name="l02240"></a>02240       os.path.split(_DropCommonSuffixes(fileinfo.RepositoryName())))
<a name="l02241"></a>02241   include_dir, include_base = os.path.split(_DropCommonSuffixes(include))
<a name="l02242"></a>02242   <span class="keywordflow">if</span> target_base == include_base <span class="keywordflow">and</span> (
<a name="l02243"></a>02243       include_dir == target_dir <span class="keywordflow">or</span>
<a name="l02244"></a>02244       include_dir == os.path.normpath(target_dir + <span class="stringliteral">&#39;/../public&#39;</span>)):
<a name="l02245"></a>02245     <span class="keywordflow">return</span> _LIKELY_MY_HEADER
<a name="l02246"></a>02246 
<a name="l02247"></a>02247   <span class="comment"># If the target and include share some initial basename</span>
<a name="l02248"></a>02248   <span class="comment"># component, it&#39;s possible the target is implementing the</span>
<a name="l02249"></a>02249   <span class="comment"># include, so it&#39;s allowed to be first, but we&#39;ll never</span>
<a name="l02250"></a>02250   <span class="comment"># complain if it&#39;s not there.</span>
<a name="l02251"></a>02251   target_first_component = _RE_FIRST_COMPONENT.match(target_base)
<a name="l02252"></a>02252   include_first_component = _RE_FIRST_COMPONENT.match(include_base)
<a name="l02253"></a>02253   <span class="keywordflow">if</span> (target_first_component <span class="keywordflow">and</span> include_first_component <span class="keywordflow">and</span>
<a name="l02254"></a>02254       target_first_component.group(0) ==
<a name="l02255"></a>02255       include_first_component.group(0)):
<a name="l02256"></a>02256     <span class="keywordflow">return</span> _POSSIBLE_MY_HEADER
<a name="l02257"></a>02257 
<a name="l02258"></a>02258   <span class="keywordflow">return</span> _OTHER_HEADER
<a name="l02259"></a>02259 
<a name="l02260"></a>02260 
<a name="l02261"></a>02261 
<a name="l02262"></a>02262 <span class="keyword">def </span>CheckIncludeLine(filename, clean_lines, linenum, include_state, error):
<a name="l02263"></a>02263   <span class="stringliteral">&quot;&quot;&quot;Check rules that are applicable to #include lines.</span>
<a name="l02264"></a>02264 <span class="stringliteral"></span>
<a name="l02265"></a>02265 <span class="stringliteral">  Strings on #include lines are NOT removed from elided line, to make</span>
<a name="l02266"></a>02266 <span class="stringliteral">  certain tasks easier. However, to prevent false positives, checks</span>
<a name="l02267"></a>02267 <span class="stringliteral">  applicable to #include lines in CheckLanguage must be put here.</span>
<a name="l02268"></a>02268 <span class="stringliteral"></span>
<a name="l02269"></a>02269 <span class="stringliteral">  Args:</span>
<a name="l02270"></a>02270 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l02271"></a>02271 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l02272"></a>02272 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l02273"></a>02273 <span class="stringliteral">    include_state: An _IncludeState instance in which the headers are inserted.</span>
<a name="l02274"></a>02274 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02275"></a>02275 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02276"></a>02276   fileinfo = FileInfo(filename)
<a name="l02277"></a>02277 
<a name="l02278"></a>02278   line = clean_lines.lines[linenum]
<a name="l02279"></a>02279 
<a name="l02280"></a>02280   <span class="comment"># &quot;include&quot; should use the new style &quot;foo/bar.h&quot; instead of just &quot;bar.h&quot;</span>
<a name="l02281"></a>02281   <span class="keywordflow">if</span> _RE_PATTERN_INCLUDE_NEW_STYLE.search(line):
<a name="l02282"></a>02282     error(filename, linenum, <span class="stringliteral">&#39;build/include&#39;</span>, 4,
<a name="l02283"></a>02283           <span class="stringliteral">&#39;Include the directory when naming .h files&#39;</span>)
<a name="l02284"></a>02284 
<a name="l02285"></a>02285   <span class="comment"># we shouldn&#39;t include a file more than once. actually, there are a</span>
<a name="l02286"></a>02286   <span class="comment"># handful of instances where doing so is okay, but in general it&#39;s</span>
<a name="l02287"></a>02287   <span class="comment"># not.</span>
<a name="l02288"></a>02288   match = _RE_PATTERN_INCLUDE.search(line)
<a name="l02289"></a>02289   <span class="keywordflow">if</span> match:
<a name="l02290"></a>02290     include = match.group(2)
<a name="l02291"></a>02291     is_system = (match.group(1) == <span class="stringliteral">&#39;&lt;&#39;</span>)
<a name="l02292"></a>02292     <span class="keywordflow">if</span> include <span class="keywordflow">in</span> include_state:
<a name="l02293"></a>02293       error(filename, linenum, <span class="stringliteral">&#39;build/include&#39;</span>, 4,
<a name="l02294"></a>02294             <span class="stringliteral">&#39;&quot;%s&quot; already included at %s:%s&#39;</span> %
<a name="l02295"></a>02295             (include, filename, include_state[include]))
<a name="l02296"></a>02296     <span class="keywordflow">else</span>:
<a name="l02297"></a>02297       include_state[include] = linenum
<a name="l02298"></a>02298 
<a name="l02299"></a>02299       <span class="comment"># We want to ensure that headers appear in the right order:</span>
<a name="l02300"></a>02300       <span class="comment"># 1) for foo.cc, foo.h  (preferred location)</span>
<a name="l02301"></a>02301       <span class="comment"># 2) c system files</span>
<a name="l02302"></a>02302       <span class="comment"># 3) cpp system files</span>
<a name="l02303"></a>02303       <span class="comment"># 4) for foo.cc, foo.h  (deprecated location)</span>
<a name="l02304"></a>02304       <span class="comment"># 5) other google headers</span>
<a name="l02305"></a>02305       <span class="comment">#</span>
<a name="l02306"></a>02306       <span class="comment"># We classify each include statement as one of those 5 types</span>
<a name="l02307"></a>02307       <span class="comment"># using a number of techniques. The include_state object keeps</span>
<a name="l02308"></a>02308       <span class="comment"># track of the highest type seen, and complains if we see a</span>
<a name="l02309"></a>02309       <span class="comment"># lower type after that.</span>
<a name="l02310"></a>02310       error_message = include_state.CheckNextIncludeOrder(
<a name="l02311"></a>02311           _ClassifyInclude(fileinfo, include, is_system))
<a name="l02312"></a>02312       <span class="keywordflow">if</span> error_message:
<a name="l02313"></a>02313         error(filename, linenum, <span class="stringliteral">&#39;build/include_order&#39;</span>, 4,
<a name="l02314"></a>02314               <span class="stringliteral">&#39;%s. Should be: %s.h, c system, c++ system, other.&#39;</span> %
<a name="l02315"></a>02315               (error_message, fileinfo.BaseName()))
<a name="l02316"></a>02316       <span class="keywordflow">if</span> <span class="keywordflow">not</span> include_state.IsInAlphabeticalOrder(include):
<a name="l02317"></a>02317         error(filename, linenum, <span class="stringliteral">&#39;build/include_alpha&#39;</span>, 4,
<a name="l02318"></a>02318               <span class="stringliteral">&#39;Include &quot;%s&quot; not in alphabetical order&#39;</span> % include)
<a name="l02319"></a>02319 
<a name="l02320"></a>02320   <span class="comment"># Look for any of the stream classes that are part of standard C++.</span>
<a name="l02321"></a>02321   match = _RE_PATTERN_INCLUDE.match(line)
<a name="l02322"></a>02322   <span class="keywordflow">if</span> match:
<a name="l02323"></a>02323     include = match.group(2)
<a name="l02324"></a>02324     <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;(f|ind|io|i|o|parse|pf|stdio|str|)?stream$&#39;</span>, include):
<a name="l02325"></a>02325       <span class="comment"># Many unit tests use cout, so we exempt them.</span>
<a name="l02326"></a>02326       <span class="keywordflow">if</span> <span class="keywordflow">not</span> _IsTestFilename(filename):
<a name="l02327"></a>02327         error(filename, linenum, <span class="stringliteral">&#39;readability/streams&#39;</span>, 3,
<a name="l02328"></a>02328               <span class="stringliteral">&#39;Streams are highly discouraged.&#39;</span>)
<a name="l02329"></a>02329 
<a name="l02330"></a>02330 <span class="keyword">def </span>CheckLanguage(filename, clean_lines, linenum, file_extension, include_state,
<a name="l02331"></a>02331                   error):
<a name="l02332"></a>02332   <span class="stringliteral">&quot;&quot;&quot;Checks rules from the &#39;C++ language rules&#39; section of cppguide.html.</span>
<a name="l02333"></a>02333 <span class="stringliteral"></span>
<a name="l02334"></a>02334 <span class="stringliteral">  Some of these rules are hard to test (function overloading, using</span>
<a name="l02335"></a>02335 <span class="stringliteral">  uint32 inappropriately), but we do the best we can.</span>
<a name="l02336"></a>02336 <span class="stringliteral"></span>
<a name="l02337"></a>02337 <span class="stringliteral">  Args:</span>
<a name="l02338"></a>02338 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l02339"></a>02339 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l02340"></a>02340 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l02341"></a>02341 <span class="stringliteral">    file_extension: The extension (without the dot) of the filename.</span>
<a name="l02342"></a>02342 <span class="stringliteral">    include_state: An _IncludeState instance in which the headers are inserted.</span>
<a name="l02343"></a>02343 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02344"></a>02344 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02345"></a>02345   <span class="comment"># If the line is empty or consists of entirely a comment, no need to</span>
<a name="l02346"></a>02346   <span class="comment"># check it.</span>
<a name="l02347"></a>02347   line = clean_lines.elided[linenum]
<a name="l02348"></a>02348   <span class="keywordflow">if</span> <span class="keywordflow">not</span> line:
<a name="l02349"></a>02349     <span class="keywordflow">return</span>
<a name="l02350"></a>02350 
<a name="l02351"></a>02351   match = _RE_PATTERN_INCLUDE.search(line)
<a name="l02352"></a>02352   <span class="keywordflow">if</span> match:
<a name="l02353"></a>02353     CheckIncludeLine(filename, clean_lines, linenum, include_state, error)
<a name="l02354"></a>02354     <span class="keywordflow">return</span>
<a name="l02355"></a>02355 
<a name="l02356"></a>02356   <span class="comment"># Create an extended_line, which is the concatenation of the current and</span>
<a name="l02357"></a>02357   <span class="comment"># next lines, for more effective checking of code that may span more than one</span>
<a name="l02358"></a>02358   <span class="comment"># line.</span>
<a name="l02359"></a>02359   <span class="keywordflow">if</span> linenum + 1 &lt; clean_lines.NumLines():
<a name="l02360"></a>02360     extended_line = line + clean_lines.elided[linenum + 1]
<a name="l02361"></a>02361   <span class="keywordflow">else</span>:
<a name="l02362"></a>02362     extended_line = line
<a name="l02363"></a>02363 
<a name="l02364"></a>02364   <span class="comment"># Make Windows paths like Unix.</span>
<a name="l02365"></a>02365   fullname = os.path.abspath(filename).replace(<span class="stringliteral">&#39;\\&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l02366"></a>02366 
<a name="l02367"></a>02367   <span class="comment"># TODO(unknown): figure out if they&#39;re using default arguments in fn proto.</span>
<a name="l02368"></a>02368 
<a name="l02369"></a>02369   <span class="comment"># Check for non-const references in functions.  This is tricky because &amp;</span>
<a name="l02370"></a>02370   <span class="comment"># is also used to take the address of something.  We allow &lt;&gt; for templates,</span>
<a name="l02371"></a>02371   <span class="comment"># (ignoring whatever is between the braces) and : for classes.</span>
<a name="l02372"></a>02372   <span class="comment"># These are complicated re&#39;s.  They try to capture the following:</span>
<a name="l02373"></a>02373   <span class="comment"># paren (for fn-prototype start), typename, &amp;, varname.  For the const</span>
<a name="l02374"></a>02374   <span class="comment"># version, we&#39;re willing for const to be before typename or after</span>
<a name="l02375"></a>02375   <span class="comment"># Don&#39;t check the implemention on same line.</span>
<a name="l02376"></a>02376   fnline = line.split(<span class="stringliteral">&#39;{&#39;</span>, 1)[0]
<a name="l02377"></a>02377   <span class="keywordflow">if</span> (len(re.findall(<span class="stringliteral">r&#39;\([^()]*\b(?:[\w:]|&lt;[^()]*&gt;)+(\s?&amp;|&amp;\s?)\w+&#39;</span>, fnline)) &gt;
<a name="l02378"></a>02378       len(re.findall(<span class="stringliteral">r&#39;\([^()]*\bconst\s+(?:typename\s+)?(?:struct\s+)?&#39;</span>
<a name="l02379"></a>02379                      <span class="stringliteral">r&#39;(?:[\w:]|&lt;[^()]*&gt;)+(\s?&amp;|&amp;\s?)\w+&#39;</span>, fnline)) +
<a name="l02380"></a>02380       len(re.findall(<span class="stringliteral">r&#39;\([^()]*\b(?:[\w:]|&lt;[^()]*&gt;)+\s+const(\s?&amp;|&amp;\s?)[\w]+&#39;</span>,
<a name="l02381"></a>02381                      fnline))):
<a name="l02382"></a>02382 
<a name="l02383"></a>02383     <span class="comment"># We allow non-const references in a few standard places, like functions</span>
<a name="l02384"></a>02384     <span class="comment"># called &quot;swap()&quot; or iostream operators like &quot;&lt;&lt;&quot; or &quot;&gt;&gt;&quot;.</span>
<a name="l02385"></a>02385     <span class="keywordflow">if</span> <span class="keywordflow">not</span> Search(
<a name="l02386"></a>02386         <span class="stringliteral">r&#39;(swap|Swap|operator[&lt;&gt;][&lt;&gt;])\s*\(\s*(?:[\w:]|&lt;.*&gt;)+\s*&amp;&#39;</span>,
<a name="l02387"></a>02387         fnline):
<a name="l02388"></a>02388       error(filename, linenum, <span class="stringliteral">&#39;runtime/references&#39;</span>, 2,
<a name="l02389"></a>02389             <span class="stringliteral">&#39;Is this a non-const reference? &#39;</span>
<a name="l02390"></a>02390             <span class="stringliteral">&#39;If so, make const or use a pointer.&#39;</span>)
<a name="l02391"></a>02391 
<a name="l02392"></a>02392   <span class="comment"># Check to see if they&#39;re using an conversion function cast.</span>
<a name="l02393"></a>02393   <span class="comment"># I just try to capture the most common basic types, though there are more.</span>
<a name="l02394"></a>02394   <span class="comment"># Parameterless conversion functions, such as bool(), are allowed as they are</span>
<a name="l02395"></a>02395   <span class="comment"># probably a member operator declaration or default constructor.</span>
<a name="l02396"></a>02396   match = Search(
<a name="l02397"></a>02397       <span class="stringliteral">r&#39;(\bnew\s+)?\b&#39;</span>  <span class="comment"># Grab &#39;new&#39; operator, if it&#39;s there</span>
<a name="l02398"></a>02398       <span class="stringliteral">r&#39;(int|float|double|bool|char|int32|uint32|int64|uint64)\([^)]&#39;</span>, line)
<a name="l02399"></a>02399   <span class="keywordflow">if</span> match:
<a name="l02400"></a>02400     <span class="comment"># gMock methods are defined using some variant of MOCK_METHODx(name, type)</span>
<a name="l02401"></a>02401     <span class="comment"># where type may be float(), int(string), etc.  Without context they are</span>
<a name="l02402"></a>02402     <span class="comment"># virtually indistinguishable from int(x) casts.</span>
<a name="l02403"></a>02403     <span class="keywordflow">if</span> (match.group(1) <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span>  <span class="comment"># If new operator, then this isn&#39;t a cast</span>
<a name="l02404"></a>02404         <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;^\s*MOCK_(CONST_)?METHOD\d+(_T)?\(&#39;</span>, line)):
<a name="l02405"></a>02405       error(filename, linenum, <span class="stringliteral">&#39;readability/casting&#39;</span>, 4,
<a name="l02406"></a>02406             <span class="stringliteral">&#39;Using deprecated casting style.  &#39;</span>
<a name="l02407"></a>02407             <span class="stringliteral">&#39;Use static_cast&lt;%s&gt;(...) instead&#39;</span> %
<a name="l02408"></a>02408             match.group(2))
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   CheckCStyleCast(filename, linenum, line, clean_lines.raw_lines[linenum],
<a name="l02411"></a>02411                   <span class="stringliteral">&#39;static_cast&#39;</span>,
<a name="l02412"></a>02412                   <span class="stringliteral">r&#39;\((int|float|double|bool|char|u?int(16|32|64))\)&#39;</span>,
<a name="l02413"></a>02413                   error)
<a name="l02414"></a>02414   <span class="comment"># This doesn&#39;t catch all cases.  Consider (const char * const)&quot;hello&quot;.</span>
<a name="l02415"></a>02415   CheckCStyleCast(filename, linenum, line, clean_lines.raw_lines[linenum],
<a name="l02416"></a>02416                   <span class="stringliteral">&#39;reinterpret_cast&#39;</span>, <span class="stringliteral">r&#39;\((\w+\s?\*+\s?)\)&#39;</span>, error)
<a name="l02417"></a>02417 
<a name="l02418"></a>02418   <span class="comment"># In addition, we look for people taking the address of a cast.  This</span>
<a name="l02419"></a>02419   <span class="comment"># is dangerous -- casts can assign to temporaries, so the pointer doesn&#39;t</span>
<a name="l02420"></a>02420   <span class="comment"># point where you think.</span>
<a name="l02421"></a>02421   <span class="keywordflow">if</span> Search(
<a name="l02422"></a>02422       <span class="stringliteral">r&#39;(&amp;\([^)]+\)[\w(])|(&amp;(static|dynamic|reinterpret)_cast\b)&#39;</span>, line):
<a name="l02423"></a>02423     error(filename, linenum, <span class="stringliteral">&#39;runtime/casting&#39;</span>, 4,
<a name="l02424"></a>02424           (<span class="stringliteral">&#39;Are you taking an address of a cast?  &#39;</span>
<a name="l02425"></a>02425            <span class="stringliteral">&#39;This is dangerous: could be a temp var.  &#39;</span>
<a name="l02426"></a>02426            <span class="stringliteral">&#39;Take the address before doing the cast, rather than after&#39;</span>))
<a name="l02427"></a>02427 
<a name="l02428"></a>02428   <span class="comment"># Check for people declaring static/global STL strings at the top level.</span>
<a name="l02429"></a>02429   <span class="comment"># This is dangerous because the C++ language does not guarantee that</span>
<a name="l02430"></a>02430   <span class="comment"># globals with constructors are initialized before the first access.</span>
<a name="l02431"></a>02431   match = Match(
<a name="l02432"></a>02432       <span class="stringliteral">r&#39;((?:|static +)(?:|const +))string +([a-zA-Z0-9_:]+)\b(.*)&#39;</span>,
<a name="l02433"></a>02433       line)
<a name="l02434"></a>02434   <span class="comment"># Make sure it&#39;s not a function.</span>
<a name="l02435"></a>02435   <span class="comment"># Function template specialization looks like: &quot;string foo&lt;Type&gt;(...&quot;.</span>
<a name="l02436"></a>02436   <span class="comment"># Class template definitions look like: &quot;string Foo&lt;Type&gt;::Method(...&quot;.</span>
<a name="l02437"></a>02437   <span class="keywordflow">if</span> match <span class="keywordflow">and</span> <span class="keywordflow">not</span> Match(<span class="stringliteral">r&#39;\s*(&lt;.*&gt;)?(::[a-zA-Z0-9_]+)?\s*\(([^&quot;]|$)&#39;</span>,
<a name="l02438"></a>02438                          match.group(3)):
<a name="l02439"></a>02439     error(filename, linenum, <span class="stringliteral">&#39;runtime/string&#39;</span>, 4,
<a name="l02440"></a>02440           <span class="stringliteral">&#39;For a static/global string constant, use a C style string instead: &#39;</span>
<a name="l02441"></a>02441           <span class="stringliteral">&#39;&quot;%schar %s[]&quot;.&#39;</span> %
<a name="l02442"></a>02442           (match.group(1), match.group(2)))
<a name="l02443"></a>02443 
<a name="l02444"></a>02444   <span class="comment"># Check that we&#39;re not using RTTI outside of testing code.</span>
<a name="l02445"></a>02445   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\bdynamic_cast&lt;&#39;</span>, line) <span class="keywordflow">and</span> <span class="keywordflow">not</span> _IsTestFilename(filename):
<a name="l02446"></a>02446     error(filename, linenum, <span class="stringliteral">&#39;runtime/rtti&#39;</span>, 5,
<a name="l02447"></a>02447           <span class="stringliteral">&#39;Do not use dynamic_cast&lt;&gt;.  If you need to cast within a class &#39;</span>
<a name="l02448"></a>02448           <span class="stringliteral">&quot;hierarchy, use static_cast&lt;&gt; to upcast.  Google doesn&#39;t support &quot;</span>
<a name="l02449"></a>02449           <span class="stringliteral">&#39;RTTI.&#39;</span>)
<a name="l02450"></a>02450 
<a name="l02451"></a>02451   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\b([A-Za-z0-9_]*_)\(\1\)&#39;</span>, line):
<a name="l02452"></a>02452     error(filename, linenum, <span class="stringliteral">&#39;runtime/init&#39;</span>, 4,
<a name="l02453"></a>02453           <span class="stringliteral">&#39;You seem to be initializing a member variable with itself.&#39;</span>)
<a name="l02454"></a>02454 
<a name="l02455"></a>02455   <span class="keywordflow">if</span> file_extension == <span class="stringliteral">&#39;h&#39;</span>:
<a name="l02456"></a>02456     <span class="comment"># TODO(unknown): check that 1-arg constructors are explicit.</span>
<a name="l02457"></a>02457     <span class="comment">#                How to tell it&#39;s a constructor?</span>
<a name="l02458"></a>02458     <span class="comment">#                (handled in CheckForNonStandardConstructs for now)</span>
<a name="l02459"></a>02459     <span class="comment"># TODO(unknown): check that classes have DISALLOW_EVIL_CONSTRUCTORS</span>
<a name="l02460"></a>02460     <span class="comment">#                (level 1 error)</span>
<a name="l02461"></a>02461     <span class="keywordflow">pass</span>
<a name="l02462"></a>02462 
<a name="l02463"></a>02463   <span class="comment"># Check if people are using the verboten C basic types.  The only exception</span>
<a name="l02464"></a>02464   <span class="comment"># we regularly allow is &quot;unsigned short port&quot; for port.</span>
<a name="l02465"></a>02465   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\bshort port\b&#39;</span>, line):
<a name="l02466"></a>02466     <span class="keywordflow">if</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;\bunsigned short port\b&#39;</span>, line):
<a name="l02467"></a>02467       error(filename, linenum, <span class="stringliteral">&#39;runtime/int&#39;</span>, 4,
<a name="l02468"></a>02468             <span class="stringliteral">&#39;Use &quot;unsigned short&quot; for ports, not &quot;short&quot;&#39;</span>)
<a name="l02469"></a>02469   <span class="keywordflow">else</span>:
<a name="l02470"></a>02470     match = Search(<span class="stringliteral">r&#39;\b(short|long(?! +double)|long long)\b&#39;</span>, line)
<a name="l02471"></a>02471     <span class="keywordflow">if</span> match:
<a name="l02472"></a>02472       error(filename, linenum, <span class="stringliteral">&#39;runtime/int&#39;</span>, 4,
<a name="l02473"></a>02473             <span class="stringliteral">&#39;Use int16/int64/etc, rather than the C type %s&#39;</span> % match.group(1))
<a name="l02474"></a>02474 
<a name="l02475"></a>02475   <span class="comment"># When snprintf is used, the second argument shouldn&#39;t be a literal.</span>
<a name="l02476"></a>02476   match = Search(<span class="stringliteral">r&#39;snprintf\s*\(([^,]*),\s*([0-9]*)\s*,&#39;</span>, line)
<a name="l02477"></a>02477   <span class="keywordflow">if</span> match <span class="keywordflow">and</span> match.group(2) != <span class="stringliteral">&#39;0&#39;</span>:
<a name="l02478"></a>02478     <span class="comment"># If 2nd arg is zero, snprintf is used to calculate size.</span>
<a name="l02479"></a>02479     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf&#39;</span>, 3,
<a name="l02480"></a>02480           <span class="stringliteral">&#39;If you can, use sizeof(%s) instead of %s as the 2nd arg &#39;</span>
<a name="l02481"></a>02481           <span class="stringliteral">&#39;to snprintf.&#39;</span> % (match.group(1), match.group(2)))
<a name="l02482"></a>02482 
<a name="l02483"></a>02483   <span class="comment"># Check if some verboten C functions are being used.</span>
<a name="l02484"></a>02484   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\bsprintf\b&#39;</span>, line):
<a name="l02485"></a>02485     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf&#39;</span>, 5,
<a name="l02486"></a>02486           <span class="stringliteral">&#39;Never use sprintf.  Use snprintf instead.&#39;</span>)
<a name="l02487"></a>02487   match = Search(<span class="stringliteral">r&#39;\b(strcpy|strcat)\b&#39;</span>, line)
<a name="l02488"></a>02488   <span class="keywordflow">if</span> match:
<a name="l02489"></a>02489     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf&#39;</span>, 4,
<a name="l02490"></a>02490           <span class="stringliteral">&#39;Almost always, snprintf is better than %s&#39;</span> % match.group(1))
<a name="l02491"></a>02491 
<a name="l02492"></a>02492   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\bsscanf\b&#39;</span>, line):
<a name="l02493"></a>02493     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf&#39;</span>, 1,
<a name="l02494"></a>02494           <span class="stringliteral">&#39;sscanf can be ok, but is slow and can overflow buffers.&#39;</span>)
<a name="l02495"></a>02495 
<a name="l02496"></a>02496   <span class="comment"># Check if some verboten operator overloading is going on</span>
<a name="l02497"></a>02497   <span class="comment"># TODO(unknown): catch out-of-line unary operator&amp;:</span>
<a name="l02498"></a>02498   <span class="comment">#   class X {};</span>
<a name="l02499"></a>02499   <span class="comment">#   int operator&amp;(const X&amp; x) { return 42; }  // unary operator&amp;</span>
<a name="l02500"></a>02500   <span class="comment"># The trick is it&#39;s hard to tell apart from binary operator&amp;:</span>
<a name="l02501"></a>02501   <span class="comment">#   class Y { int operator&amp;(const Y&amp; x) { return 23; } }; // binary operator&amp;</span>
<a name="l02502"></a>02502   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\boperator\s*&amp;\s*\(\s*\)&#39;</span>, line):
<a name="l02503"></a>02503     error(filename, linenum, <span class="stringliteral">&#39;runtime/operator&#39;</span>, 4,
<a name="l02504"></a>02504           <span class="stringliteral">&#39;Unary operator&amp; is dangerous.  Do not use it.&#39;</span>)
<a name="l02505"></a>02505 
<a name="l02506"></a>02506   <span class="comment"># Check for suspicious usage of &quot;if&quot; like</span>
<a name="l02507"></a>02507   <span class="comment"># } if (a == b) {</span>
<a name="l02508"></a>02508   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\}\s*if\s*\(&#39;</span>, line):
<a name="l02509"></a>02509     error(filename, linenum, <span class="stringliteral">&#39;readability/braces&#39;</span>, 4,
<a name="l02510"></a>02510           <span class="stringliteral">&#39;Did you mean &quot;else if&quot;? If not, start a new line for &quot;if&quot;.&#39;</span>)
<a name="l02511"></a>02511 
<a name="l02512"></a>02512   <span class="comment"># Check for potential format string bugs like printf(foo).</span>
<a name="l02513"></a>02513   <span class="comment"># We constrain the pattern not to pick things like DocidForPrintf(foo).</span>
<a name="l02514"></a>02514   <span class="comment"># Not perfect but it can catch printf(foo.c_str()) and printf(foo-&gt;c_str())</span>
<a name="l02515"></a>02515   match = re.search(<span class="stringliteral">r&#39;\b((?:string)?printf)\s*\(([\w.\-&gt;()]+)\)&#39;</span>, line, re.I)
<a name="l02516"></a>02516   <span class="keywordflow">if</span> match:
<a name="l02517"></a>02517     error(filename, linenum, <span class="stringliteral">&#39;runtime/printf&#39;</span>, 4,
<a name="l02518"></a>02518           <span class="stringliteral">&#39;Potential format string bug. Do %s(&quot;%%s&quot;, %s) instead.&#39;</span>
<a name="l02519"></a>02519           % (match.group(1), match.group(2)))
<a name="l02520"></a>02520 
<a name="l02521"></a>02521   <span class="comment"># Check for potential memset bugs like memset(buf, sizeof(buf), 0).</span>
<a name="l02522"></a>02522   match = Search(<span class="stringliteral">r&#39;memset\s*\(([^,]*),\s*([^,]*),\s*0\s*\)&#39;</span>, line)
<a name="l02523"></a>02523   <span class="keywordflow">if</span> match <span class="keywordflow">and</span> <span class="keywordflow">not</span> Match(<span class="stringliteral">r&quot;^&#39;&#39;|-?[0-9]+|0x[0-9A-Fa-f]$&quot;</span>, match.group(2)):
<a name="l02524"></a>02524     error(filename, linenum, <span class="stringliteral">&#39;runtime/memset&#39;</span>, 4,
<a name="l02525"></a>02525           <span class="stringliteral">&#39;Did you mean &quot;memset(%s, 0, %s)&quot;?&#39;</span>
<a name="l02526"></a>02526           % (match.group(1), match.group(2)))
<a name="l02527"></a>02527 
<a name="l02528"></a>02528   <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;\busing namespace\b&#39;</span>, line):
<a name="l02529"></a>02529     error(filename, linenum, <span class="stringliteral">&#39;build/namespaces&#39;</span>, 5,
<a name="l02530"></a>02530           <span class="stringliteral">&#39;Do not use namespace using-directives.  &#39;</span>
<a name="l02531"></a>02531           <span class="stringliteral">&#39;Use using-declarations instead.&#39;</span>)
<a name="l02532"></a>02532 
<a name="l02533"></a>02533   <span class="comment"># Detect variable-length arrays.</span>
<a name="l02534"></a>02534   match = Match(<span class="stringliteral">r&#39;\s*(.+::)?(\w+) [a-z]\w*\[(.+)];&#39;</span>, line)
<a name="l02535"></a>02535   <span class="keywordflow">if</span> (match <span class="keywordflow">and</span> match.group(2) != <span class="stringliteral">&#39;return&#39;</span> <span class="keywordflow">and</span> match.group(2) != <span class="stringliteral">&#39;delete&#39;</span> <span class="keywordflow">and</span>
<a name="l02536"></a>02536       match.group(3).find(<span class="stringliteral">&#39;]&#39;</span>) == -1):
<a name="l02537"></a>02537     <span class="comment"># Split the size using space and arithmetic operators as delimiters.</span>
<a name="l02538"></a>02538     <span class="comment"># If any of the resulting tokens are not compile time constants then</span>
<a name="l02539"></a>02539     <span class="comment"># report the error.</span>
<a name="l02540"></a>02540     tokens = re.split(<span class="stringliteral">r&#39;\s|\+|\-|\*|\/|&lt;&lt;|&gt;&gt;]&#39;</span>, match.group(3))
<a name="l02541"></a>02541     is_const = <span class="keyword">True</span>
<a name="l02542"></a>02542     skip_next = <span class="keyword">False</span>
<a name="l02543"></a>02543     <span class="keywordflow">for</span> tok <span class="keywordflow">in</span> tokens:
<a name="l02544"></a>02544       <span class="keywordflow">if</span> skip_next:
<a name="l02545"></a>02545         skip_next = <span class="keyword">False</span>
<a name="l02546"></a>02546         <span class="keywordflow">continue</span>
<a name="l02547"></a>02547 
<a name="l02548"></a>02548       <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;sizeof\(.+\)&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02549"></a>02549       <span class="keywordflow">if</span> Search(<span class="stringliteral">r&#39;arraysize\(\w+\)&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02550"></a>02550 
<a name="l02551"></a>02551       tok = tok.lstrip(<span class="stringliteral">&#39;(&#39;</span>)
<a name="l02552"></a>02552       tok = tok.rstrip(<span class="stringliteral">&#39;)&#39;</span>)
<a name="l02553"></a>02553       <span class="keywordflow">if</span> <span class="keywordflow">not</span> tok: <span class="keywordflow">continue</span>
<a name="l02554"></a>02554       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;\d+&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02555"></a>02555       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;0[xX][0-9a-fA-F]+&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02556"></a>02556       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;k[A-Z0-9]\w*&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02557"></a>02557       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;(.+::)?k[A-Z0-9]\w*&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02558"></a>02558       <span class="keywordflow">if</span> Match(<span class="stringliteral">r&#39;(.+::)?[A-Z][A-Z0-9_]*&#39;</span>, tok): <span class="keywordflow">continue</span>
<a name="l02559"></a>02559       <span class="comment"># A catch all for tricky sizeof cases, including &#39;sizeof expression&#39;,</span>
<a name="l02560"></a>02560       <span class="comment"># &#39;sizeof(*type)&#39;, &#39;sizeof(const type)&#39;, &#39;sizeof(struct StructName)&#39;</span>
<a name="l02561"></a>02561       <span class="comment"># requires skipping the next token becasue we split on &#39; &#39; and &#39;*&#39;.</span>
<a name="l02562"></a>02562       <span class="keywordflow">if</span> tok.startswith(<span class="stringliteral">&#39;sizeof&#39;</span>):
<a name="l02563"></a>02563         skip_next = <span class="keyword">True</span>
<a name="l02564"></a>02564         <span class="keywordflow">continue</span>
<a name="l02565"></a>02565       is_const = <span class="keyword">False</span>
<a name="l02566"></a>02566       <span class="keywordflow">break</span>
<a name="l02567"></a>02567     <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_const:
<a name="l02568"></a>02568       error(filename, linenum, <span class="stringliteral">&#39;runtime/arrays&#39;</span>, 1,
<a name="l02569"></a>02569             <span class="stringliteral">&#39;Do not use variable-length arrays.  Use an appropriately named &#39;</span>
<a name="l02570"></a>02570             <span class="stringliteral">&quot;(&#39;k&#39; followed by CamelCase) compile-time constant for the size.&quot;</span>)
<a name="l02571"></a>02571 
<a name="l02572"></a>02572   <span class="comment"># If DISALLOW_EVIL_CONSTRUCTORS, DISALLOW_COPY_AND_ASSIGN, or</span>
<a name="l02573"></a>02573   <span class="comment"># DISALLOW_IMPLICIT_CONSTRUCTORS is present, then it should be the last thing</span>
<a name="l02574"></a>02574   <span class="comment"># in the class declaration.</span>
<a name="l02575"></a>02575   match = Match(
<a name="l02576"></a>02576       (<span class="stringliteral">r&#39;\s*&#39;</span>
<a name="l02577"></a>02577        <span class="stringliteral">r&#39;(DISALLOW_(EVIL_CONSTRUCTORS|COPY_AND_ASSIGN|IMPLICIT_CONSTRUCTORS))&#39;</span>
<a name="l02578"></a>02578        <span class="stringliteral">r&#39;\(.*\);$&#39;</span>),
<a name="l02579"></a>02579       line)
<a name="l02580"></a>02580   <span class="keywordflow">if</span> match <span class="keywordflow">and</span> linenum + 1 &lt; clean_lines.NumLines():
<a name="l02581"></a>02581     next_line = clean_lines.elided[linenum + 1]
<a name="l02582"></a>02582     <span class="keywordflow">if</span> <span class="keywordflow">not</span> Search(<span class="stringliteral">r&#39;^\s*};&#39;</span>, next_line):
<a name="l02583"></a>02583       error(filename, linenum, <span class="stringliteral">&#39;readability/constructors&#39;</span>, 3,
<a name="l02584"></a>02584             match.group(1) + <span class="stringliteral">&#39; should be the last thing in the class&#39;</span>)
<a name="l02585"></a>02585 
<a name="l02586"></a>02586   <span class="comment"># Check for use of unnamed namespaces in header files.  Registration</span>
<a name="l02587"></a>02587   <span class="comment"># macros are typically OK, so we allow use of &quot;namespace {&quot; on lines</span>
<a name="l02588"></a>02588   <span class="comment"># that end with backslashes.</span>
<a name="l02589"></a>02589   <span class="keywordflow">if</span> (file_extension == <span class="stringliteral">&#39;h&#39;</span>
<a name="l02590"></a>02590       <span class="keywordflow">and</span> Search(<span class="stringliteral">r&#39;\bnamespace\s*{&#39;</span>, line)
<a name="l02591"></a>02591       <span class="keywordflow">and</span> line[-1] != <span class="stringliteral">&#39;\\&#39;</span>):
<a name="l02592"></a>02592     error(filename, linenum, <span class="stringliteral">&#39;build/namespaces&#39;</span>, 4,
<a name="l02593"></a>02593           <span class="stringliteral">&#39;Do not use unnamed namespaces in header files.  See &#39;</span>
<a name="l02594"></a>02594           <span class="stringliteral">&#39;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Namespaces&#39;</span>
<a name="l02595"></a>02595           <span class="stringliteral">&#39; for more information.&#39;</span>)
<a name="l02596"></a>02596 
<a name="l02597"></a>02597 
<a name="l02598"></a>02598 <span class="keyword">def </span>CheckCStyleCast(filename, linenum, line, raw_line, cast_type, pattern,
<a name="l02599"></a>02599                     error):
<a name="l02600"></a>02600   <span class="stringliteral">&quot;&quot;&quot;Checks for a C-style cast by looking for the pattern.</span>
<a name="l02601"></a>02601 <span class="stringliteral"></span>
<a name="l02602"></a>02602 <span class="stringliteral">  This also handles sizeof(type) warnings, due to similarity of content.</span>
<a name="l02603"></a>02603 <span class="stringliteral"></span>
<a name="l02604"></a>02604 <span class="stringliteral">  Args:</span>
<a name="l02605"></a>02605 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l02606"></a>02606 <span class="stringliteral">    linenum: The number of the line to check.</span>
<a name="l02607"></a>02607 <span class="stringliteral">    line: The line of code to check.</span>
<a name="l02608"></a>02608 <span class="stringliteral">    raw_line: The raw line of code to check, with comments.</span>
<a name="l02609"></a>02609 <span class="stringliteral">    cast_type: The string for the C++ cast to recommend.  This is either</span>
<a name="l02610"></a>02610 <span class="stringliteral">      reinterpret_cast or static_cast, depending.</span>
<a name="l02611"></a>02611 <span class="stringliteral">    pattern: The regular expression used to find C-style casts.</span>
<a name="l02612"></a>02612 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02613"></a>02613 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02614"></a>02614   match = Search(pattern, line)
<a name="l02615"></a>02615   <span class="keywordflow">if</span> <span class="keywordflow">not</span> match:
<a name="l02616"></a>02616     <span class="keywordflow">return</span>
<a name="l02617"></a>02617 
<a name="l02618"></a>02618   <span class="comment"># e.g., sizeof(int)</span>
<a name="l02619"></a>02619   sizeof_match = Match(<span class="stringliteral">r&#39;.*sizeof\s*$&#39;</span>, line[0:match.start(1) - 1])
<a name="l02620"></a>02620   <span class="keywordflow">if</span> sizeof_match:
<a name="l02621"></a>02621     error(filename, linenum, <span class="stringliteral">&#39;runtime/sizeof&#39;</span>, 1,
<a name="l02622"></a>02622           <span class="stringliteral">&#39;Using sizeof(type).  Use sizeof(varname) instead if possible&#39;</span>)
<a name="l02623"></a>02623     <span class="keywordflow">return</span>
<a name="l02624"></a>02624 
<a name="l02625"></a>02625   remainder = line[match.end(0):]
<a name="l02626"></a>02626 
<a name="l02627"></a>02627   <span class="comment"># The close paren is for function pointers as arguments to a function.</span>
<a name="l02628"></a>02628   <span class="comment"># eg, void foo(void (*bar)(int));</span>
<a name="l02629"></a>02629   <span class="comment"># The semicolon check is a more basic function check; also possibly a</span>
<a name="l02630"></a>02630   <span class="comment"># function pointer typedef.</span>
<a name="l02631"></a>02631   <span class="comment"># eg, void foo(int); or void foo(int) const;</span>
<a name="l02632"></a>02632   <span class="comment"># The equals check is for function pointer assignment.</span>
<a name="l02633"></a>02633   <span class="comment"># eg, void *(*foo)(int) = ...</span>
<a name="l02634"></a>02634   <span class="comment">#</span>
<a name="l02635"></a>02635   <span class="comment"># Right now, this will only catch cases where there&#39;s a single argument, and</span>
<a name="l02636"></a>02636   <span class="comment"># it&#39;s unnamed.  It should probably be expanded to check for multiple</span>
<a name="l02637"></a>02637   <span class="comment"># arguments with some unnamed.</span>
<a name="l02638"></a>02638   function_match = Match(<span class="stringliteral">r&#39;\s*(\)|=|(const)?\s*(;|\{|throw\(\)))&#39;</span>, remainder)
<a name="l02639"></a>02639   <span class="keywordflow">if</span> function_match:
<a name="l02640"></a>02640     <span class="keywordflow">if</span> (<span class="keywordflow">not</span> function_match.group(3) <span class="keywordflow">or</span>
<a name="l02641"></a>02641         function_match.group(3) == <span class="stringliteral">&#39;;&#39;</span> <span class="keywordflow">or</span>
<a name="l02642"></a>02642         raw_line.find(<span class="stringliteral">&#39;/*&#39;</span>) &lt; 0):
<a name="l02643"></a>02643       error(filename, linenum, <span class="stringliteral">&#39;readability/function&#39;</span>, 3,
<a name="l02644"></a>02644             <span class="stringliteral">&#39;All parameters should be named in a function&#39;</span>)
<a name="l02645"></a>02645     <span class="keywordflow">return</span>
<a name="l02646"></a>02646 
<a name="l02647"></a>02647   <span class="comment"># At this point, all that should be left is actual casts.</span>
<a name="l02648"></a>02648   error(filename, linenum, <span class="stringliteral">&#39;readability/casting&#39;</span>, 4,
<a name="l02649"></a>02649         <span class="stringliteral">&#39;Using C-style cast.  Use %s&lt;%s&gt;(...) instead&#39;</span> %
<a name="l02650"></a>02650         (cast_type, match.group(1)))
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 
<a name="l02653"></a>02653 _HEADERS_CONTAINING_TEMPLATES = (
<a name="l02654"></a>02654     (<span class="stringliteral">&#39;&lt;deque&gt;&#39;</span>, (<span class="stringliteral">&#39;deque&#39;</span>,)),
<a name="l02655"></a>02655     (<span class="stringliteral">&#39;&lt;functional&gt;&#39;</span>, (<span class="stringliteral">&#39;unary_function&#39;</span>, <span class="stringliteral">&#39;binary_function&#39;</span>,
<a name="l02656"></a>02656                       <span class="stringliteral">&#39;plus&#39;</span>, <span class="stringliteral">&#39;minus&#39;</span>, <span class="stringliteral">&#39;multiplies&#39;</span>, <span class="stringliteral">&#39;divides&#39;</span>, <span class="stringliteral">&#39;modulus&#39;</span>,
<a name="l02657"></a>02657                       <span class="stringliteral">&#39;negate&#39;</span>,
<a name="l02658"></a>02658                       <span class="stringliteral">&#39;equal_to&#39;</span>, <span class="stringliteral">&#39;not_equal_to&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>,
<a name="l02659"></a>02659                       <span class="stringliteral">&#39;greater_equal&#39;</span>, <span class="stringliteral">&#39;less_equal&#39;</span>,
<a name="l02660"></a>02660                       <span class="stringliteral">&#39;logical_and&#39;</span>, <span class="stringliteral">&#39;logical_or&#39;</span>, <span class="stringliteral">&#39;logical_not&#39;</span>,
<a name="l02661"></a>02661                       <span class="stringliteral">&#39;unary_negate&#39;</span>, <span class="stringliteral">&#39;not1&#39;</span>, <span class="stringliteral">&#39;binary_negate&#39;</span>, <span class="stringliteral">&#39;not2&#39;</span>,
<a name="l02662"></a>02662                       <span class="stringliteral">&#39;bind1st&#39;</span>, <span class="stringliteral">&#39;bind2nd&#39;</span>,
<a name="l02663"></a>02663                       <span class="stringliteral">&#39;pointer_to_unary_function&#39;</span>,
<a name="l02664"></a>02664                       <span class="stringliteral">&#39;pointer_to_binary_function&#39;</span>,
<a name="l02665"></a>02665                       <span class="stringliteral">&#39;ptr_fun&#39;</span>,
<a name="l02666"></a>02666                       <span class="stringliteral">&#39;mem_fun_t&#39;</span>, <span class="stringliteral">&#39;mem_fun&#39;</span>, <span class="stringliteral">&#39;mem_fun1_t&#39;</span>, <span class="stringliteral">&#39;mem_fun1_ref_t&#39;</span>,
<a name="l02667"></a>02667                       <span class="stringliteral">&#39;mem_fun_ref_t&#39;</span>,
<a name="l02668"></a>02668                       <span class="stringliteral">&#39;const_mem_fun_t&#39;</span>, <span class="stringliteral">&#39;const_mem_fun1_t&#39;</span>,
<a name="l02669"></a>02669                       <span class="stringliteral">&#39;const_mem_fun_ref_t&#39;</span>, <span class="stringliteral">&#39;const_mem_fun1_ref_t&#39;</span>,
<a name="l02670"></a>02670                       <span class="stringliteral">&#39;mem_fun_ref&#39;</span>,
<a name="l02671"></a>02671                      )),
<a name="l02672"></a>02672     (<span class="stringliteral">&#39;&lt;limits&gt;&#39;</span>, (<span class="stringliteral">&#39;numeric_limits&#39;</span>,)),
<a name="l02673"></a>02673     (<span class="stringliteral">&#39;&lt;list&gt;&#39;</span>, (<span class="stringliteral">&#39;list&#39;</span>,)),
<a name="l02674"></a>02674     (<span class="stringliteral">&#39;&lt;map&gt;&#39;</span>, (<span class="stringliteral">&#39;map&#39;</span>, <span class="stringliteral">&#39;multimap&#39;</span>,)),
<a name="l02675"></a>02675     (<span class="stringliteral">&#39;&lt;memory&gt;&#39;</span>, (<span class="stringliteral">&#39;allocator&#39;</span>,)),
<a name="l02676"></a>02676     (<span class="stringliteral">&#39;&lt;queue&gt;&#39;</span>, (<span class="stringliteral">&#39;queue&#39;</span>, <span class="stringliteral">&#39;priority_queue&#39;</span>,)),
<a name="l02677"></a>02677     (<span class="stringliteral">&#39;&lt;set&gt;&#39;</span>, (<span class="stringliteral">&#39;set&#39;</span>, <span class="stringliteral">&#39;multiset&#39;</span>,)),
<a name="l02678"></a>02678     (<span class="stringliteral">&#39;&lt;stack&gt;&#39;</span>, (<span class="stringliteral">&#39;stack&#39;</span>,)),
<a name="l02679"></a>02679     (<span class="stringliteral">&#39;&lt;string&gt;&#39;</span>, (<span class="stringliteral">&#39;char_traits&#39;</span>, <span class="stringliteral">&#39;basic_string&#39;</span>,)),
<a name="l02680"></a>02680     (<span class="stringliteral">&#39;&lt;utility&gt;&#39;</span>, (<span class="stringliteral">&#39;pair&#39;</span>,)),
<a name="l02681"></a>02681     (<span class="stringliteral">&#39;&lt;vector&gt;&#39;</span>, (<span class="stringliteral">&#39;vector&#39;</span>,)),
<a name="l02682"></a>02682 
<a name="l02683"></a>02683     <span class="comment"># gcc extensions.</span>
<a name="l02684"></a>02684     <span class="comment"># Note: std::hash is their hash, ::hash is our hash</span>
<a name="l02685"></a>02685     (<span class="stringliteral">&#39;&lt;hash_map&gt;&#39;</span>, (<span class="stringliteral">&#39;hash_map&#39;</span>, <span class="stringliteral">&#39;hash_multimap&#39;</span>,)),
<a name="l02686"></a>02686     (<span class="stringliteral">&#39;&lt;hash_set&gt;&#39;</span>, (<span class="stringliteral">&#39;hash_set&#39;</span>, <span class="stringliteral">&#39;hash_multiset&#39;</span>,)),
<a name="l02687"></a>02687     (<span class="stringliteral">&#39;&lt;slist&gt;&#39;</span>, (<span class="stringliteral">&#39;slist&#39;</span>,)),
<a name="l02688"></a>02688     )
<a name="l02689"></a>02689 
<a name="l02690"></a>02690 _HEADERS_ACCEPTED_BUT_NOT_PROMOTED = {
<a name="l02691"></a>02691     <span class="comment"># We can trust with reasonable confidence that map gives us pair&lt;&gt;, too.</span>
<a name="l02692"></a>02692     <span class="stringliteral">&#39;pair&lt;&gt;&#39;</span>: (<span class="stringliteral">&#39;map&#39;</span>, <span class="stringliteral">&#39;multimap&#39;</span>, <span class="stringliteral">&#39;hash_map&#39;</span>, <span class="stringliteral">&#39;hash_multimap&#39;</span>)
<a name="l02693"></a>02693 }
<a name="l02694"></a>02694 
<a name="l02695"></a>02695 _RE_PATTERN_STRING = re.compile(<span class="stringliteral">r&#39;\bstring\b&#39;</span>)
<a name="l02696"></a>02696 
<a name="l02697"></a>02697 _re_pattern_algorithm_header = []
<a name="l02698"></a>02698 <span class="keywordflow">for</span> _template <span class="keywordflow">in</span> (<span class="stringliteral">&#39;copy&#39;</span>, <span class="stringliteral">&#39;max&#39;</span>, <span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;min_element&#39;</span>, <span class="stringliteral">&#39;sort&#39;</span>, <span class="stringliteral">&#39;swap&#39;</span>,
<a name="l02699"></a>02699                   <span class="stringliteral">&#39;transform&#39;</span>):
<a name="l02700"></a>02700   <span class="comment"># Match max&lt;type&gt;(..., ...), max(..., ...), but not foo-&gt;max, foo.max or</span>
<a name="l02701"></a>02701   <span class="comment"># type::max().</span>
<a name="l02702"></a>02702   _re_pattern_algorithm_header.append(
<a name="l02703"></a>02703       (re.compile(<span class="stringliteral">r&#39;[^&gt;.]\b&#39;</span> + _template + <span class="stringliteral">r&#39;(&lt;.*?&gt;)?\([^\)]&#39;</span>),
<a name="l02704"></a>02704        _template,
<a name="l02705"></a>02705        <span class="stringliteral">&#39;&lt;algorithm&gt;&#39;</span>))
<a name="l02706"></a>02706 
<a name="l02707"></a>02707 _re_pattern_templates = []
<a name="l02708"></a>02708 <span class="keywordflow">for</span> _header, _templates <span class="keywordflow">in</span> _HEADERS_CONTAINING_TEMPLATES:
<a name="l02709"></a>02709   <span class="keywordflow">for</span> _template <span class="keywordflow">in</span> _templates:
<a name="l02710"></a>02710     _re_pattern_templates.append(
<a name="l02711"></a>02711         (re.compile(<span class="stringliteral">r&#39;(&lt;|\b)&#39;</span> + _template + <span class="stringliteral">r&#39;\s*&lt;&#39;</span>),
<a name="l02712"></a>02712          _template + <span class="stringliteral">&#39;&lt;&gt;&#39;</span>,
<a name="l02713"></a>02713          _header))
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 
<a name="l02716"></a>02716 <span class="keyword">def </span>FilesBelongToSameModule(filename_cc, filename_h):
<a name="l02717"></a>02717   <span class="stringliteral">&quot;&quot;&quot;Check if these two filenames belong to the same module.</span>
<a name="l02718"></a>02718 <span class="stringliteral"></span>
<a name="l02719"></a>02719 <span class="stringliteral">  The concept of a &#39;module&#39; here is a as follows:</span>
<a name="l02720"></a>02720 <span class="stringliteral">  foo.h, foo-inl.h, foo.cc, foo_test.cc and foo_unittest.cc belong to the</span>
<a name="l02721"></a>02721 <span class="stringliteral">  same &#39;module&#39; if they are in the same directory.</span>
<a name="l02722"></a>02722 <span class="stringliteral">  some/path/public/xyzzy and some/path/internal/xyzzy are also considered</span>
<a name="l02723"></a>02723 <span class="stringliteral">  to belong to the same module here.</span>
<a name="l02724"></a>02724 <span class="stringliteral"></span>
<a name="l02725"></a>02725 <span class="stringliteral">  If the filename_cc contains a longer path than the filename_h, for example,</span>
<a name="l02726"></a>02726 <span class="stringliteral">  &#39;/absolute/path/to/base/sysinfo.cc&#39;, and this file would include</span>
<a name="l02727"></a>02727 <span class="stringliteral">  &#39;base/sysinfo.h&#39;, this function also produces the prefix needed to open the</span>
<a name="l02728"></a>02728 <span class="stringliteral">  header. This is used by the caller of this function to more robustly open the</span>
<a name="l02729"></a>02729 <span class="stringliteral">  header file. We don&#39;t have access to the real include paths in this context,</span>
<a name="l02730"></a>02730 <span class="stringliteral">  so we need this guesswork here.</span>
<a name="l02731"></a>02731 <span class="stringliteral"></span>
<a name="l02732"></a>02732 <span class="stringliteral">  Known bugs: tools/base/bar.cc and base/bar.h belong to the same module</span>
<a name="l02733"></a>02733 <span class="stringliteral">  according to this implementation. Because of this, this function gives</span>
<a name="l02734"></a>02734 <span class="stringliteral">  some false positives. This should be sufficiently rare in practice.</span>
<a name="l02735"></a>02735 <span class="stringliteral"></span>
<a name="l02736"></a>02736 <span class="stringliteral">  Args:</span>
<a name="l02737"></a>02737 <span class="stringliteral">    filename_cc: is the path for the .cc file</span>
<a name="l02738"></a>02738 <span class="stringliteral">    filename_h: is the path for the header path</span>
<a name="l02739"></a>02739 <span class="stringliteral"></span>
<a name="l02740"></a>02740 <span class="stringliteral">  Returns:</span>
<a name="l02741"></a>02741 <span class="stringliteral">    Tuple with a bool and a string:</span>
<a name="l02742"></a>02742 <span class="stringliteral">    bool: True if filename_cc and filename_h belong to the same module.</span>
<a name="l02743"></a>02743 <span class="stringliteral">    string: the additional prefix needed to open the header file.</span>
<a name="l02744"></a>02744 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02745"></a>02745 
<a name="l02746"></a>02746   <span class="keywordflow">if</span> <span class="keywordflow">not</span> filename_cc.endswith(<span class="stringliteral">&#39;.cc&#39;</span>):
<a name="l02747"></a>02747     <span class="keywordflow">return</span> (<span class="keyword">False</span>, <span class="stringliteral">&#39;&#39;</span>)
<a name="l02748"></a>02748   filename_cc = filename_cc[:-len(<span class="stringliteral">&#39;.cc&#39;</span>)]
<a name="l02749"></a>02749   <span class="keywordflow">if</span> filename_cc.endswith(<span class="stringliteral">&#39;_unittest&#39;</span>):
<a name="l02750"></a>02750     filename_cc = filename_cc[:-len(<span class="stringliteral">&#39;_unittest&#39;</span>)]
<a name="l02751"></a>02751   <span class="keywordflow">elif</span> filename_cc.endswith(<span class="stringliteral">&#39;_test&#39;</span>):
<a name="l02752"></a>02752     filename_cc = filename_cc[:-len(<span class="stringliteral">&#39;_test&#39;</span>)]
<a name="l02753"></a>02753   filename_cc = filename_cc.replace(<span class="stringliteral">&#39;/public/&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l02754"></a>02754   filename_cc = filename_cc.replace(<span class="stringliteral">&#39;/internal/&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l02755"></a>02755 
<a name="l02756"></a>02756   <span class="keywordflow">if</span> <span class="keywordflow">not</span> filename_h.endswith(<span class="stringliteral">&#39;.h&#39;</span>):
<a name="l02757"></a>02757     <span class="keywordflow">return</span> (<span class="keyword">False</span>, <span class="stringliteral">&#39;&#39;</span>)
<a name="l02758"></a>02758   filename_h = filename_h[:-len(<span class="stringliteral">&#39;.h&#39;</span>)]
<a name="l02759"></a>02759   <span class="keywordflow">if</span> filename_h.endswith(<span class="stringliteral">&#39;-inl&#39;</span>):
<a name="l02760"></a>02760     filename_h = filename_h[:-len(<span class="stringliteral">&#39;-inl&#39;</span>)]
<a name="l02761"></a>02761   filename_h = filename_h.replace(<span class="stringliteral">&#39;/public/&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l02762"></a>02762   filename_h = filename_h.replace(<span class="stringliteral">&#39;/internal/&#39;</span>, <span class="stringliteral">&#39;/&#39;</span>)
<a name="l02763"></a>02763 
<a name="l02764"></a>02764   files_belong_to_same_module = filename_cc.endswith(filename_h)
<a name="l02765"></a>02765   common_path = <span class="stringliteral">&#39;&#39;</span>
<a name="l02766"></a>02766   <span class="keywordflow">if</span> files_belong_to_same_module:
<a name="l02767"></a>02767     common_path = filename_cc[:-len(filename_h)]
<a name="l02768"></a>02768   <span class="keywordflow">return</span> files_belong_to_same_module, common_path
<a name="l02769"></a>02769 
<a name="l02770"></a>02770 
<a name="l02771"></a>02771 <span class="keyword">def </span>UpdateIncludeState(filename, include_state, io=codecs):
<a name="l02772"></a>02772   <span class="stringliteral">&quot;&quot;&quot;Fill up the include_state with new includes found from the file.</span>
<a name="l02773"></a>02773 <span class="stringliteral"></span>
<a name="l02774"></a>02774 <span class="stringliteral">  Args:</span>
<a name="l02775"></a>02775 <span class="stringliteral">    filename: the name of the header to read.</span>
<a name="l02776"></a>02776 <span class="stringliteral">    include_state: an _IncludeState instance in which the headers are inserted.</span>
<a name="l02777"></a>02777 <span class="stringliteral">    io: The io factory to use to read the file. Provided for testability.</span>
<a name="l02778"></a>02778 <span class="stringliteral"></span>
<a name="l02779"></a>02779 <span class="stringliteral">  Returns:</span>
<a name="l02780"></a>02780 <span class="stringliteral">    True if a header was succesfully added. False otherwise.</span>
<a name="l02781"></a>02781 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02782"></a>02782   headerfile = <span class="keywordtype">None</span>
<a name="l02783"></a>02783   <span class="keywordflow">try</span>:
<a name="l02784"></a>02784     headerfile = io.open(filename, <span class="stringliteral">&#39;</span><span class="stringliteral">r&#39;, &#39;</span>utf8&#39;, &#39;replace&#39;)
<a name="l02785"></a>02785   <span class="keywordflow">except</span> IOError:
<a name="l02786"></a>02786     <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l02787"></a>02787   linenum = 0
<a name="l02788"></a>02788   <span class="keywordflow">for</span> line <span class="keywordflow">in</span> headerfile:
<a name="l02789"></a>02789     linenum += 1
<a name="l02790"></a>02790     clean_line = CleanseComments(line)
<a name="l02791"></a>02791     match = _RE_PATTERN_INCLUDE.search(clean_line)
<a name="l02792"></a>02792     <span class="keywordflow">if</span> match:
<a name="l02793"></a>02793       include = match.group(2)
<a name="l02794"></a>02794       <span class="comment"># The value formatting is cute, but not really used right now.</span>
<a name="l02795"></a>02795       <span class="comment"># What matters here is that the key is in include_state.</span>
<a name="l02796"></a>02796       include_state.setdefault(include, <span class="stringliteral">&#39;%s:%d&#39;</span> % (filename, linenum))
<a name="l02797"></a>02797   <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l02798"></a>02798 
<a name="l02799"></a>02799 
<a name="l02800"></a>02800 <span class="keyword">def </span>CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error,
<a name="l02801"></a>02801                               io=codecs):
<a name="l02802"></a>02802   <span class="stringliteral">&quot;&quot;&quot;Reports for missing stl includes.</span>
<a name="l02803"></a>02803 <span class="stringliteral"></span>
<a name="l02804"></a>02804 <span class="stringliteral">  This function will output warnings to make sure you are including the headers</span>
<a name="l02805"></a>02805 <span class="stringliteral">  necessary for the stl containers and functions that you use. We only give one</span>
<a name="l02806"></a>02806 <span class="stringliteral">  reason to include a header. For example, if you use both equal_to&lt;&gt; and</span>
<a name="l02807"></a>02807 <span class="stringliteral">  less&lt;&gt; in a .h file, only one (the latter in the file) of these will be</span>
<a name="l02808"></a>02808 <span class="stringliteral">  reported as a reason to include the &lt;functional&gt;.</span>
<a name="l02809"></a>02809 <span class="stringliteral"></span>
<a name="l02810"></a>02810 <span class="stringliteral">  Args:</span>
<a name="l02811"></a>02811 <span class="stringliteral">    filename: The name of the current file.</span>
<a name="l02812"></a>02812 <span class="stringliteral">    clean_lines: A CleansedLines instance containing the file.</span>
<a name="l02813"></a>02813 <span class="stringliteral">    include_state: An _IncludeState instance.</span>
<a name="l02814"></a>02814 <span class="stringliteral">    error: The function to call with any errors found.</span>
<a name="l02815"></a>02815 <span class="stringliteral">    io: The IO factory to use to read the header file. Provided for unittest</span>
<a name="l02816"></a>02816 <span class="stringliteral">        injection.</span>
<a name="l02817"></a>02817 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02818"></a>02818   required = {}  <span class="comment"># A map of header name to linenumber and the template entity.</span>
<a name="l02819"></a>02819                  <span class="comment"># Example of required: { &#39;&lt;functional&gt;&#39;: (1219, &#39;less&lt;&gt;&#39;) }</span>
<a name="l02820"></a>02820 
<a name="l02821"></a>02821   <span class="keywordflow">for</span> linenum <span class="keywordflow">in</span> xrange(clean_lines.NumLines()):
<a name="l02822"></a>02822     line = clean_lines.elided[linenum]
<a name="l02823"></a>02823     <span class="keywordflow">if</span> <span class="keywordflow">not</span> line <span class="keywordflow">or</span> line[0] == <span class="stringliteral">&#39;#&#39;</span>:
<a name="l02824"></a>02824       <span class="keywordflow">continue</span>
<a name="l02825"></a>02825 
<a name="l02826"></a>02826     <span class="comment"># String is special -- it is a non-templatized type in STL.</span>
<a name="l02827"></a>02827     m = _RE_PATTERN_STRING.search(line)
<a name="l02828"></a>02828     <span class="keywordflow">if</span> m:
<a name="l02829"></a>02829       <span class="comment"># Don&#39;t warn about strings in non-STL namespaces:</span>
<a name="l02830"></a>02830       <span class="comment"># (We check only the first match per line; good enough.)</span>
<a name="l02831"></a>02831       prefix = line[:m.start()]
<a name="l02832"></a>02832       <span class="keywordflow">if</span> prefix.endswith(<span class="stringliteral">&#39;std::&#39;</span>) <span class="keywordflow">or</span> <span class="keywordflow">not</span> prefix.endswith(<span class="stringliteral">&#39;::&#39;</span>):
<a name="l02833"></a>02833         required[<span class="stringliteral">&#39;&lt;string&gt;&#39;</span>] = (linenum, <span class="stringliteral">&#39;string&#39;</span>)
<a name="l02834"></a>02834 
<a name="l02835"></a>02835     <span class="keywordflow">for</span> pattern, template, header <span class="keywordflow">in</span> _re_pattern_algorithm_header:
<a name="l02836"></a>02836       <span class="keywordflow">if</span> pattern.search(line):
<a name="l02837"></a>02837         required[header] = (linenum, template)
<a name="l02838"></a>02838 
<a name="l02839"></a>02839     <span class="comment"># The following function is just a speed up, no semantics are changed.</span>
<a name="l02840"></a>02840     <span class="keywordflow">if</span> <span class="keywordflow">not</span> <span class="stringliteral">&#39;&lt;&#39;</span> <span class="keywordflow">in</span> line:  <span class="comment"># Reduces the cpu time usage by skipping lines.</span>
<a name="l02841"></a>02841       <span class="keywordflow">continue</span>
<a name="l02842"></a>02842 
<a name="l02843"></a>02843     <span class="keywordflow">for</span> pattern, template, header <span class="keywordflow">in</span> _re_pattern_templates:
<a name="l02844"></a>02844       <span class="keywordflow">if</span> pattern.search(line):
<a name="l02845"></a>02845         required[header] = (linenum, template)
<a name="l02846"></a>02846 
<a name="l02847"></a>02847   <span class="comment"># The policy is that if you #include something in foo.h you don&#39;t need to</span>
<a name="l02848"></a>02848   <span class="comment"># include it again in foo.cc. Here, we will look at possible includes.</span>
<a name="l02849"></a>02849   <span class="comment"># Let&#39;s copy the include_state so it is only messed up within this function.</span>
<a name="l02850"></a>02850   include_state = include_state.copy()
<a name="l02851"></a>02851 
<a name="l02852"></a>02852   <span class="comment"># Did we find the header for this file (if any) and succesfully load it?</span>
<a name="l02853"></a>02853   header_found = <span class="keyword">False</span>
<a name="l02854"></a>02854 
<a name="l02855"></a>02855   <span class="comment"># Use the absolute path so that matching works properly.</span>
<a name="l02856"></a>02856   abs_filename = os.path.abspath(filename)
<a name="l02857"></a>02857 
<a name="l02858"></a>02858   <span class="comment"># For Emacs&#39;s flymake.</span>
<a name="l02859"></a>02859   <span class="comment"># If cpplint is invoked from Emacs&#39;s flymake, a temporary file is generated</span>
<a name="l02860"></a>02860   <span class="comment"># by flymake and that file name might end with &#39;_flymake.cc&#39;. In that case,</span>
<a name="l02861"></a>02861   <span class="comment"># restore original file name here so that the corresponding header file can be</span>
<a name="l02862"></a>02862   <span class="comment"># found.</span>
<a name="l02863"></a>02863   <span class="comment"># e.g. If the file name is &#39;foo_flymake.cc&#39;, we should search for &#39;foo.h&#39;</span>
<a name="l02864"></a>02864   <span class="comment"># instead of &#39;foo_flymake.h&#39;</span>
<a name="l02865"></a>02865   abs_filename = re.sub(<span class="stringliteral">r&#39;_flymake\.cc$&#39;</span>, <span class="stringliteral">&#39;.cc&#39;</span>, abs_filename)
<a name="l02866"></a>02866 
<a name="l02867"></a>02867   <span class="comment"># include_state is modified during iteration, so we iterate over a copy of</span>
<a name="l02868"></a>02868   <span class="comment"># the keys.</span>
<a name="l02869"></a>02869   <span class="keywordflow">for</span> header <span class="keywordflow">in</span> include_state.keys():  <span class="comment">#NOLINT</span>
<a name="l02870"></a>02870     (same_module, common_path) = FilesBelongToSameModule(abs_filename, header)
<a name="l02871"></a>02871     fullpath = common_path + header
<a name="l02872"></a>02872     <span class="keywordflow">if</span> same_module <span class="keywordflow">and</span> UpdateIncludeState(fullpath, include_state, io):
<a name="l02873"></a>02873       header_found = <span class="keyword">True</span>
<a name="l02874"></a>02874 
<a name="l02875"></a>02875   <span class="comment"># If we can&#39;t find the header file for a .cc, assume it&#39;s because we don&#39;t</span>
<a name="l02876"></a>02876   <span class="comment"># know where to look. In that case we&#39;ll give up as we&#39;re not sure they</span>
<a name="l02877"></a>02877   <span class="comment"># didn&#39;t include it in the .h file.</span>
<a name="l02878"></a>02878   <span class="comment"># TODO(unknown): Do a better job of finding .h files so we are confident that</span>
<a name="l02879"></a>02879   <span class="comment"># not having the .h file means there isn&#39;t one.</span>
<a name="l02880"></a>02880   <span class="keywordflow">if</span> filename.endswith(<span class="stringliteral">&#39;.cc&#39;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> header_found:
<a name="l02881"></a>02881     <span class="keywordflow">return</span>
<a name="l02882"></a>02882 
<a name="l02883"></a>02883   <span class="comment"># All the lines have been processed, report the errors found.</span>
<a name="l02884"></a>02884   <span class="keywordflow">for</span> required_header_unstripped <span class="keywordflow">in</span> required:
<a name="l02885"></a>02885     template = required[required_header_unstripped][1]
<a name="l02886"></a>02886     <span class="keywordflow">if</span> template <span class="keywordflow">in</span> _HEADERS_ACCEPTED_BUT_NOT_PROMOTED:
<a name="l02887"></a>02887       headers = _HEADERS_ACCEPTED_BUT_NOT_PROMOTED[template]
<a name="l02888"></a>02888       <span class="keywordflow">if</span> [<span class="keyword">True</span> <span class="keywordflow">for</span> header <span class="keywordflow">in</span> headers <span class="keywordflow">if</span> header <span class="keywordflow">in</span> include_state]:
<a name="l02889"></a>02889         <span class="keywordflow">continue</span>
<a name="l02890"></a>02890     <span class="keywordflow">if</span> required_header_unstripped.strip(<span class="stringliteral">&#39;&lt;&gt;&quot;&#39;</span>) <span class="keywordflow">not</span> <span class="keywordflow">in</span> include_state:
<a name="l02891"></a>02891       error(filename, required[required_header_unstripped][0],
<a name="l02892"></a>02892             <span class="stringliteral">&#39;build/include_what_you_use&#39;</span>, 4,
<a name="l02893"></a>02893             <span class="stringliteral">&#39;Add #include &#39;</span> + required_header_unstripped + <span class="stringliteral">&#39; for &#39;</span> + template)
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 
<a name="l02896"></a>02896 <span class="keyword">def </span>ProcessLine(filename, file_extension,
<a name="l02897"></a>02897                 clean_lines, line, include_state, function_state,
<a name="l02898"></a>02898                 class_state, error):
<a name="l02899"></a>02899   <span class="stringliteral">&quot;&quot;&quot;Processes a single line in the file.</span>
<a name="l02900"></a>02900 <span class="stringliteral"></span>
<a name="l02901"></a>02901 <span class="stringliteral">  Args:</span>
<a name="l02902"></a>02902 <span class="stringliteral">    filename: Filename of the file that is being processed.</span>
<a name="l02903"></a>02903 <span class="stringliteral">    file_extension: The extension (dot not included) of the file.</span>
<a name="l02904"></a>02904 <span class="stringliteral">    clean_lines: An array of strings, each representing a line of the file,</span>
<a name="l02905"></a>02905 <span class="stringliteral">                 with comments stripped.</span>
<a name="l02906"></a>02906 <span class="stringliteral">    line: Number of line being processed.</span>
<a name="l02907"></a>02907 <span class="stringliteral">    include_state: An _IncludeState instance in which the headers are inserted.</span>
<a name="l02908"></a>02908 <span class="stringliteral">    function_state: A _FunctionState instance which counts function lines, etc.</span>
<a name="l02909"></a>02909 <span class="stringliteral">    class_state: A _ClassState instance which maintains information about</span>
<a name="l02910"></a>02910 <span class="stringliteral">                 the current stack of nested class declarations being parsed.</span>
<a name="l02911"></a>02911 <span class="stringliteral">    error: A callable to which errors are reported, which takes 4 arguments:</span>
<a name="l02912"></a>02912 <span class="stringliteral">           filename, line number, error level, and message</span>
<a name="l02913"></a>02913 <span class="stringliteral"></span>
<a name="l02914"></a>02914 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02915"></a>02915   raw_lines = clean_lines.raw_lines
<a name="l02916"></a>02916   ParseNolintSuppressions(filename, raw_lines[line], line, error)
<a name="l02917"></a>02917   CheckForFunctionLengths(filename, clean_lines, line, function_state, error)
<a name="l02918"></a>02918   CheckForMultilineCommentsAndStrings(filename, clean_lines, line, error)
<a name="l02919"></a>02919   CheckStyle(filename, clean_lines, line, file_extension, error)
<a name="l02920"></a>02920   CheckLanguage(filename, clean_lines, line, file_extension, include_state,
<a name="l02921"></a>02921                 error)
<a name="l02922"></a>02922   CheckForNonStandardConstructs(filename, clean_lines, line,
<a name="l02923"></a>02923                                 class_state, error)
<a name="l02924"></a>02924   CheckPosixThreading(filename, clean_lines, line, error)
<a name="l02925"></a>02925   CheckInvalidIncrement(filename, clean_lines, line, error)
<a name="l02926"></a>02926 
<a name="l02927"></a>02927 
<a name="l02928"></a>02928 <span class="keyword">def </span>ProcessFileData(filename, file_extension, lines, error):
<a name="l02929"></a>02929   <span class="stringliteral">&quot;&quot;&quot;Performs lint checks and reports any errors to the given error function.</span>
<a name="l02930"></a>02930 <span class="stringliteral"></span>
<a name="l02931"></a>02931 <span class="stringliteral">  Args:</span>
<a name="l02932"></a>02932 <span class="stringliteral">    filename: Filename of the file that is being processed.</span>
<a name="l02933"></a>02933 <span class="stringliteral">    file_extension: The extension (dot not included) of the file.</span>
<a name="l02934"></a>02934 <span class="stringliteral">    lines: An array of strings, each representing a line of the file, with the</span>
<a name="l02935"></a>02935 <span class="stringliteral">           last element being empty if the file is termined with a newline.</span>
<a name="l02936"></a>02936 <span class="stringliteral">    error: A callable to which errors are reported, which takes 4 arguments:</span>
<a name="l02937"></a>02937 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02938"></a>02938   lines = ([<span class="stringliteral">&#39;// marker so line numbers and indices both start at 1&#39;</span>] + lines +
<a name="l02939"></a>02939            [<span class="stringliteral">&#39;// marker so line numbers end in a known way&#39;</span>])
<a name="l02940"></a>02940 
<a name="l02941"></a>02941   include_state = _IncludeState()
<a name="l02942"></a>02942   function_state = _FunctionState()
<a name="l02943"></a>02943   class_state = _ClassState()
<a name="l02944"></a>02944 
<a name="l02945"></a>02945   ResetNolintSuppressions()
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   CheckForCopyright(filename, lines, error)
<a name="l02948"></a>02948 
<a name="l02949"></a>02949   <span class="keywordflow">if</span> file_extension == <span class="stringliteral">&#39;h&#39;</span>:
<a name="l02950"></a>02950     CheckForHeaderGuard(filename, lines, error)
<a name="l02951"></a>02951 
<a name="l02952"></a>02952   RemoveMultiLineComments(filename, lines, error)
<a name="l02953"></a>02953   clean_lines = CleansedLines(lines)
<a name="l02954"></a>02954   <span class="keywordflow">for</span> line <span class="keywordflow">in</span> xrange(clean_lines.NumLines()):
<a name="l02955"></a>02955     ProcessLine(filename, file_extension, clean_lines, line,
<a name="l02956"></a>02956                 include_state, function_state, class_state, error)
<a name="l02957"></a>02957   class_state.CheckFinished(filename, error)
<a name="l02958"></a>02958 
<a name="l02959"></a>02959   CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error)
<a name="l02960"></a>02960 
<a name="l02961"></a>02961   <span class="comment"># We check here rather than inside ProcessLine so that we see raw</span>
<a name="l02962"></a>02962   <span class="comment"># lines rather than &quot;cleaned&quot; lines.</span>
<a name="l02963"></a>02963   CheckForUnicodeReplacementCharacters(filename, lines, error)
<a name="l02964"></a>02964 
<a name="l02965"></a>02965   CheckForNewlineAtEOF(filename, lines, error)
<a name="l02966"></a>02966 
<a name="l02967"></a>02967 <span class="keyword">def </span>ProcessFile(filename, vlevel):
<a name="l02968"></a>02968   <span class="stringliteral">&quot;&quot;&quot;Does google-lint on a single file.</span>
<a name="l02969"></a>02969 <span class="stringliteral"></span>
<a name="l02970"></a>02970 <span class="stringliteral">  Args:</span>
<a name="l02971"></a>02971 <span class="stringliteral">    filename: The name of the file to parse.</span>
<a name="l02972"></a>02972 <span class="stringliteral"></span>
<a name="l02973"></a>02973 <span class="stringliteral">    vlevel: The level of errors to report.  Every error of confidence</span>
<a name="l02974"></a>02974 <span class="stringliteral">    &gt;= verbose_level will be reported.  0 is a good default.</span>
<a name="l02975"></a>02975 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l02976"></a>02976 
<a name="l02977"></a>02977   _SetVerboseLevel(vlevel)
<a name="l02978"></a>02978 
<a name="l02979"></a>02979   <span class="keywordflow">try</span>:
<a name="l02980"></a>02980     <span class="comment"># Support the UNIX convention of using &quot;-&quot; for stdin.  Note that</span>
<a name="l02981"></a>02981     <span class="comment"># we are not opening the file with universal newline support</span>
<a name="l02982"></a>02982     <span class="comment"># (which codecs doesn&#39;t support anyway), so the resulting lines do</span>
<a name="l02983"></a>02983     <span class="comment"># contain trailing &#39;\r&#39; characters if we are reading a file that</span>
<a name="l02984"></a>02984     <span class="comment"># has CRLF endings.</span>
<a name="l02985"></a>02985     <span class="comment"># If after the split a trailing &#39;\r&#39; is present, it is removed</span>
<a name="l02986"></a>02986     <span class="comment"># below. If it is not expected to be present (i.e. os.linesep !=</span>
<a name="l02987"></a>02987     <span class="comment"># &#39;\r\n&#39; as in Windows), a warning is issued below if this file</span>
<a name="l02988"></a>02988     <span class="comment"># is processed.</span>
<a name="l02989"></a>02989 
<a name="l02990"></a>02990     <span class="keywordflow">if</span> filename == <span class="stringliteral">&#39;-&#39;</span>:
<a name="l02991"></a>02991       lines = codecs.StreamReaderWriter(sys.stdin,
<a name="l02992"></a>02992                                         codecs.getreader(<span class="stringliteral">&#39;utf8&#39;</span>),
<a name="l02993"></a>02993                                         codecs.getwriter(<span class="stringliteral">&#39;utf8&#39;</span>),
<a name="l02994"></a>02994                                         <span class="stringliteral">&#39;replace&#39;</span>).read().split(<span class="stringliteral">&#39;\n&#39;</span>)
<a name="l02995"></a>02995     <span class="keywordflow">else</span>:
<a name="l02996"></a>02996       lines = codecs.open(filename, <span class="stringliteral">&#39;</span><span class="stringliteral">r&#39;, &#39;</span>utf8&#39;, &#39;replace&#39;).read().split(&#39;\n&#39;)
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     carriage_return_found = <span class="keyword">False</span>
<a name="l02999"></a>02999     <span class="comment"># Remove trailing &#39;\r&#39;.</span>
<a name="l03000"></a>03000     <span class="keywordflow">for</span> linenum <span class="keywordflow">in</span> range(len(lines)):
<a name="l03001"></a>03001       <span class="keywordflow">if</span> lines[linenum].endswith(<span class="stringliteral">&#39;\r&#39;</span>):
<a name="l03002"></a>03002         lines[linenum] = lines[linenum].rstrip(<span class="stringliteral">&#39;\r&#39;</span>)
<a name="l03003"></a>03003         carriage_return_found = <span class="keyword">True</span>
<a name="l03004"></a>03004 
<a name="l03005"></a>03005   <span class="keywordflow">except</span> IOError:
<a name="l03006"></a>03006     sys.stderr.write(
<a name="l03007"></a>03007         <span class="stringliteral">&quot;Skipping input &#39;%s&#39;: Can&#39;t open for reading\n&quot;</span> % filename)
<a name="l03008"></a>03008     <span class="keywordflow">return</span>
<a name="l03009"></a>03009 
<a name="l03010"></a>03010   <span class="comment"># Note, if no dot is found, this will give the entire filename as the ext.</span>
<a name="l03011"></a>03011   file_extension = filename[filename.rfind(<span class="stringliteral">&#39;.&#39;</span>) + 1:]
<a name="l03012"></a>03012 
<a name="l03013"></a>03013   <span class="comment"># When reading from stdin, the extension is unknown, so no cpplint tests</span>
<a name="l03014"></a>03014   <span class="comment"># should rely on the extension.</span>
<a name="l03015"></a>03015   <span class="keywordflow">if</span> (filename != <span class="stringliteral">&#39;-&#39;</span> <span class="keywordflow">and</span> file_extension != <span class="stringliteral">&#39;cc&#39;</span> <span class="keywordflow">and</span> file_extension != <span class="stringliteral">&#39;h&#39;</span>
<a name="l03016"></a>03016       <span class="keywordflow">and</span> file_extension != <span class="stringliteral">&#39;cpp&#39;</span>):
<a name="l03017"></a>03017     sys.stderr.write(<span class="stringliteral">&#39;Ignoring %s; not a .cc or .h file\n&#39;</span> % filename)
<a name="l03018"></a>03018   <span class="keywordflow">else</span>:
<a name="l03019"></a>03019     ProcessFileData(filename, file_extension, lines, Error)
<a name="l03020"></a>03020     <span class="keywordflow">if</span> carriage_return_found <span class="keywordflow">and</span> os.linesep != <span class="stringliteral">&#39;\r\n&#39;</span>:
<a name="l03021"></a>03021       <span class="comment"># Use 0 for linenum since outputing only one error for potentially</span>
<a name="l03022"></a>03022       <span class="comment"># several lines.</span>
<a name="l03023"></a>03023       Error(filename, 0, <span class="stringliteral">&#39;whitespace/newline&#39;</span>, 1,
<a name="l03024"></a>03024             <span class="stringliteral">&#39;One or more unexpected \\r (^M) found;&#39;</span>
<a name="l03025"></a>03025             <span class="stringliteral">&#39;better to use only a \\n&#39;</span>)
<a name="l03026"></a>03026 
<a name="l03027"></a>03027   sys.stderr.write(<span class="stringliteral">&#39;Done processing %s\n&#39;</span> % filename)
<a name="l03028"></a>03028 
<a name="l03029"></a>03029 
<a name="l03030"></a>03030 <span class="keyword">def </span>PrintUsage(message):
<a name="l03031"></a>03031   <span class="stringliteral">&quot;&quot;&quot;Prints a brief usage string and exits, optionally with an error message.</span>
<a name="l03032"></a>03032 <span class="stringliteral"></span>
<a name="l03033"></a>03033 <span class="stringliteral">  Args:</span>
<a name="l03034"></a>03034 <span class="stringliteral">    message: The optional error message.</span>
<a name="l03035"></a>03035 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l03036"></a>03036   sys.stderr.write(_USAGE)
<a name="l03037"></a>03037   <span class="keywordflow">if</span> message:
<a name="l03038"></a>03038     sys.exit(<span class="stringliteral">&#39;\nFATAL ERROR: &#39;</span> + message)
<a name="l03039"></a>03039   <span class="keywordflow">else</span>:
<a name="l03040"></a>03040     sys.exit(1)
<a name="l03041"></a>03041 
<a name="l03042"></a>03042 
<a name="l03043"></a>03043 <span class="keyword">def </span>PrintCategories():
<a name="l03044"></a>03044   <span class="stringliteral">&quot;&quot;&quot;Prints a list of all the error-categories used by error messages.</span>
<a name="l03045"></a>03045 <span class="stringliteral"></span>
<a name="l03046"></a>03046 <span class="stringliteral">  These are the categories used to filter messages via --filter.</span>
<a name="l03047"></a>03047 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l03048"></a>03048   sys.stderr.write(<span class="stringliteral">&#39;&#39;</span>.join(<span class="stringliteral">&#39;  %s\n&#39;</span> % cat <span class="keywordflow">for</span> cat <span class="keywordflow">in</span> _ERROR_CATEGORIES))
<a name="l03049"></a>03049   sys.exit(0)
<a name="l03050"></a>03050 
<a name="l03051"></a>03051 
<a name="l03052"></a>03052 <span class="keyword">def </span>ParseArguments(args):
<a name="l03053"></a>03053   <span class="stringliteral">&quot;&quot;&quot;Parses the command line arguments.</span>
<a name="l03054"></a>03054 <span class="stringliteral"></span>
<a name="l03055"></a>03055 <span class="stringliteral">  This may set the output format and verbosity level as side-effects.</span>
<a name="l03056"></a>03056 <span class="stringliteral"></span>
<a name="l03057"></a>03057 <span class="stringliteral">  Args:</span>
<a name="l03058"></a>03058 <span class="stringliteral">    args: The command line arguments:</span>
<a name="l03059"></a>03059 <span class="stringliteral"></span>
<a name="l03060"></a>03060 <span class="stringliteral">  Returns:</span>
<a name="l03061"></a>03061 <span class="stringliteral">    The list of filenames to lint.</span>
<a name="l03062"></a>03062 <span class="stringliteral">  &quot;&quot;&quot;</span>
<a name="l03063"></a>03063   <span class="keywordflow">try</span>:
<a name="l03064"></a>03064     (opts, filenames) = getopt.getopt(args, <span class="stringliteral">&#39;&#39;</span>, [<span class="stringliteral">&#39;help&#39;</span>, <span class="stringliteral">&#39;output=&#39;</span>, <span class="stringliteral">&#39;verbose=&#39;</span>,
<a name="l03065"></a>03065                                                  <span class="stringliteral">&#39;counting=&#39;</span>,
<a name="l03066"></a>03066                                                  <span class="stringliteral">&#39;filter=&#39;</span>])
<a name="l03067"></a>03067   <span class="keywordflow">except</span> getopt.GetoptError:
<a name="l03068"></a>03068     PrintUsage(<span class="stringliteral">&#39;Invalid arguments.&#39;</span>)
<a name="l03069"></a>03069 
<a name="l03070"></a>03070   verbosity = _VerboseLevel()
<a name="l03071"></a>03071   output_format = _OutputFormat()
<a name="l03072"></a>03072   filters = <span class="stringliteral">&#39;&#39;</span>
<a name="l03073"></a>03073   counting_style = <span class="stringliteral">&#39;&#39;</span>
<a name="l03074"></a>03074 
<a name="l03075"></a>03075   <span class="keywordflow">for</span> (opt, val) <span class="keywordflow">in</span> opts:
<a name="l03076"></a>03076     <span class="keywordflow">if</span> opt == <span class="stringliteral">&#39;--help&#39;</span>:
<a name="l03077"></a>03077       PrintUsage(<span class="keywordtype">None</span>)
<a name="l03078"></a>03078     <span class="keywordflow">elif</span> opt == <span class="stringliteral">&#39;--output&#39;</span>:
<a name="l03079"></a>03079       <span class="keywordflow">if</span> <span class="keywordflow">not</span> val <span class="keywordflow">in</span> (<span class="stringliteral">&#39;emacs&#39;</span>, <span class="stringliteral">&#39;vs7&#39;</span>):
<a name="l03080"></a>03080         PrintUsage(<span class="stringliteral">&#39;The only allowed output formats are emacs and vs7.&#39;</span>)
<a name="l03081"></a>03081       output_format = val
<a name="l03082"></a>03082     <span class="keywordflow">elif</span> opt == <span class="stringliteral">&#39;--verbose&#39;</span>:
<a name="l03083"></a>03083       verbosity = int(val)
<a name="l03084"></a>03084     <span class="keywordflow">elif</span> opt == <span class="stringliteral">&#39;--filter&#39;</span>:
<a name="l03085"></a>03085       filters = val
<a name="l03086"></a>03086       <span class="keywordflow">if</span> <span class="keywordflow">not</span> filters:
<a name="l03087"></a>03087         PrintCategories()
<a name="l03088"></a>03088     <span class="keywordflow">elif</span> opt == <span class="stringliteral">&#39;--counting&#39;</span>:
<a name="l03089"></a>03089       <span class="keywordflow">if</span> val <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;total&#39;</span>, <span class="stringliteral">&#39;toplevel&#39;</span>, <span class="stringliteral">&#39;detailed&#39;</span>):
<a name="l03090"></a>03090         PrintUsage(<span class="stringliteral">&#39;Valid counting options are total, toplevel, and detailed&#39;</span>)
<a name="l03091"></a>03091       counting_style = val
<a name="l03092"></a>03092 
<a name="l03093"></a>03093   <span class="keywordflow">if</span> <span class="keywordflow">not</span> filenames:
<a name="l03094"></a>03094     PrintUsage(<span class="stringliteral">&#39;No files were specified.&#39;</span>)
<a name="l03095"></a>03095 
<a name="l03096"></a>03096   _SetOutputFormat(output_format)
<a name="l03097"></a>03097   _SetVerboseLevel(verbosity)
<a name="l03098"></a>03098   _SetFilters(filters)
<a name="l03099"></a>03099   _SetCountingStyle(counting_style)
<a name="l03100"></a>03100 
<a name="l03101"></a>03101   <span class="keywordflow">return</span> filenames
<a name="l03102"></a>03102 
<a name="l03103"></a>03103 
<a name="l03104"></a>03104 <span class="keyword">def </span><a class="code" href="namespacehexjs.html#a4211122bebd6f95cd479db25c55b9b9d">main</a>():
<a name="l03105"></a>03105   filenames = ParseArguments(sys.argv[1:])
<a name="l03106"></a>03106 
<a name="l03107"></a>03107   <span class="comment"># Change stderr to write with replacement characters so we don&#39;t die</span>
<a name="l03108"></a>03108   <span class="comment"># if we try to print something containing non-ASCII characters.</span>
<a name="l03109"></a>03109   sys.stderr = codecs.StreamReaderWriter(sys.stderr,
<a name="l03110"></a>03110                                          codecs.getreader(<span class="stringliteral">&#39;utf8&#39;</span>),
<a name="l03111"></a>03111                                          codecs.getwriter(<span class="stringliteral">&#39;utf8&#39;</span>),
<a name="l03112"></a>03112                                          <span class="stringliteral">&#39;replace&#39;</span>)
<a name="l03113"></a>03113 
<a name="l03114"></a>03114   _cpplint_state.ResetErrorCounts()
<a name="l03115"></a>03115   <span class="keywordflow">for</span> filename <span class="keywordflow">in</span> filenames:
<a name="l03116"></a>03116     ProcessFile(filename, _cpplint_state.verbose_level)
<a name="l03117"></a>03117   _cpplint_state.PrintErrorCounts()
<a name="l03118"></a>03118 
<a name="l03119"></a>03119   sys.exit(_cpplint_state.error_count &gt; 0)
<a name="l03120"></a>03120 
<a name="l03121"></a>03121 
<a name="l03122"></a>03122 <span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:
<a name="l03123"></a>03123   main()
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Nov 4 22:19:46 2010 for crml by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
